<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- Module      :  Data.Singletons.Partition</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Copyright   :  (C) 2015 Richard Eisenberg</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- License     :  BSD-style (see LICENSE)</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Maintainer  :  Ryan Scott</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Stability   :  experimental</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Portability :  non-portable</span><span>
</span><span id="line-9"></span><span class="hs-comment">--</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Partitions a list of declarations into its bits</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">----------------------------------------------------------------------------</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-15"></span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.Singletons.Partition</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">exp</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Syntax.html"><span class="hs-identifier">Data.Singletons.Syntax</span></a></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Ord.html"><span class="hs-identifier">Data.Singletons.Deriving.Ord</span></a></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Bounded.html"><span class="hs-identifier">Data.Singletons.Deriving.Bounded</span></a></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Enum.html"><span class="hs-identifier">Data.Singletons.Deriving.Enum</span></a></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Foldable.html"><span class="hs-identifier">Data.Singletons.Deriving.Foldable</span></a></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Functor.html"><span class="hs-identifier">Data.Singletons.Deriving.Functor</span></a></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Show.html"><span class="hs-identifier">Data.Singletons.Deriving.Show</span></a></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Traversable.html"><span class="hs-identifier">Data.Singletons.Deriving.Traversable</span></a></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Util.html"><span class="hs-identifier">Data.Singletons.Deriving.Util</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Names.html"><span class="hs-identifier">Data.Singletons.Names</span></a></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.TH.Options.html"><span class="hs-identifier">Data.Singletons.TH.Options</span></a></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">showName</span></span><span class="hs-special">)</span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Ppr</span></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Desugar</span></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Desugar.OMap.Strict</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">OMap</span></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Desugar.OMap.Strict</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">OMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Singletons.Util.html"><span class="hs-identifier">Data.Singletons.Util</span></a></span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">bimap</span></span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Map</span></span><span class="hs-special">)</span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-keyword">data</span><span> </span><span id="PartitionedDecs"><span class="annot"><a href="Data.Singletons.Partition.html#PartitionedDecs"><span class="hs-identifier hs-var">PartitionedDecs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-45"></span><span>  </span><span id="PDecs"><span class="annot"><a href="Data.Singletons.Partition.html#PDecs"><span class="hs-identifier hs-var">PDecs</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="pd_let_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [DLetDec]
</span><a href="Data.Singletons.Partition.html#pd_let_decs"><span class="hs-identifier hs-var hs-var">pd_let_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span class="hs-special">]</span><span>
</span><span id="line-46"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_class_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [UClassDecl]
</span><a href="Data.Singletons.Partition.html#pd_class_decs"><span class="hs-identifier hs-var hs-var">pd_class_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#UClassDecl"><span class="hs-identifier hs-type">UClassDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-47"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_instance_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [UInstDecl]
</span><a href="Data.Singletons.Partition.html#pd_instance_decs"><span class="hs-identifier hs-var hs-var">pd_instance_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#UInstDecl"><span class="hs-identifier hs-type">UInstDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-48"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_data_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [DataDecl]
</span><a href="Data.Singletons.Partition.html#pd_data_decs"><span class="hs-identifier hs-var hs-var">pd_data_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#DataDecl"><span class="hs-identifier hs-type">DataDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-49"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_ty_syn_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [TySynDecl]
</span><a href="Data.Singletons.Partition.html#pd_ty_syn_decs"><span class="hs-identifier hs-var hs-var">pd_ty_syn_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#TySynDecl"><span class="hs-identifier hs-type">TySynDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-50"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_open_type_family_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [OpenTypeFamilyDecl]
</span><a href="Data.Singletons.Partition.html#pd_open_type_family_decs"><span class="hs-identifier hs-var hs-var">pd_open_type_family_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#OpenTypeFamilyDecl"><span class="hs-identifier hs-type">OpenTypeFamilyDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-51"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_closed_type_family_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [ClosedTypeFamilyDecl]
</span><a href="Data.Singletons.Partition.html#pd_closed_type_family_decs"><span class="hs-identifier hs-var hs-var">pd_closed_type_family_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#ClosedTypeFamilyDecl"><span class="hs-identifier hs-type">ClosedTypeFamilyDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-52"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_derived_eq_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [DerivedEqDecl]
</span><a href="Data.Singletons.Partition.html#pd_derived_eq_decs"><span class="hs-identifier hs-var hs-var">pd_derived_eq_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#DerivedEqDecl"><span class="hs-identifier hs-type">DerivedEqDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-53"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="pd_derived_show_decs"><span class="annot"><span class="annottext">PartitionedDecs -&gt; [DerivedShowDecl]
</span><a href="Data.Singletons.Partition.html#pd_derived_show_decs"><span class="hs-identifier hs-var hs-var">pd_derived_show_decs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#DerivedShowDecl"><span class="hs-identifier hs-type">DerivedShowDecl</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-54"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681360835"><span id="local-6989586621681360837"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="annot"><a href="Data.Singletons.Partition.html#PartitionedDecs"><span class="hs-identifier hs-type">PartitionedDecs</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-57"></span><span>  </span><span class="annot"><a href="Data.Singletons.Partition.html#PDecs"><span class="hs-identifier hs-type">PDecs</span></a></span><span> </span><span id="local-6989586621681360833"><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621681360833"><span class="hs-identifier hs-var">a1</span></a></span></span><span> </span><span id="local-6989586621681360832"><span class="annot"><span class="annottext">[UClassDecl]
</span><a href="#local-6989586621681360832"><span class="hs-identifier hs-var">b1</span></a></span></span><span> </span><span id="local-6989586621681360831"><span class="annot"><span class="annottext">[UInstDecl]
</span><a href="#local-6989586621681360831"><span class="hs-identifier hs-var">c1</span></a></span></span><span> </span><span id="local-6989586621681360830"><span class="annot"><span class="annottext">[DataDecl]
</span><a href="#local-6989586621681360830"><span class="hs-identifier hs-var">d1</span></a></span></span><span> </span><span id="local-6989586621681360829"><span class="annot"><span class="annottext">[TySynDecl]
</span><a href="#local-6989586621681360829"><span class="hs-identifier hs-var">e1</span></a></span></span><span> </span><span id="local-6989586621681360828"><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
</span><a href="#local-6989586621681360828"><span class="hs-identifier hs-var">f1</span></a></span></span><span> </span><span id="local-6989586621681360827"><span class="annot"><span class="annottext">[ClosedTypeFamilyDecl]
</span><a href="#local-6989586621681360827"><span class="hs-identifier hs-var">g1</span></a></span></span><span> </span><span id="local-6989586621681360826"><span class="annot"><span class="annottext">[DerivedEqDecl]
</span><a href="#local-6989586621681360826"><span class="hs-identifier hs-var">h1</span></a></span></span><span> </span><span id="local-6989586621681360825"><span class="annot"><span class="annottext">[DerivedShowDecl]
</span><a href="#local-6989586621681360825"><span class="hs-identifier hs-var">i1</span></a></span></span><span> </span><span id="local-6989586621681360824"><span class="annot"><span class="annottext">&lt;&gt; :: PartitionedDecs -&gt; PartitionedDecs -&gt; PartitionedDecs
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="annot"><a href="Data.Singletons.Partition.html#PDecs"><span class="hs-identifier hs-type">PDecs</span></a></span><span> </span><span id="local-6989586621681360823"><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621681360823"><span class="hs-identifier hs-var">a2</span></a></span></span><span> </span><span id="local-6989586621681360822"><span class="annot"><span class="annottext">[UClassDecl]
</span><a href="#local-6989586621681360822"><span class="hs-identifier hs-var">b2</span></a></span></span><span> </span><span id="local-6989586621681360821"><span class="annot"><span class="annottext">[UInstDecl]
</span><a href="#local-6989586621681360821"><span class="hs-identifier hs-var">c2</span></a></span></span><span> </span><span id="local-6989586621681360820"><span class="annot"><span class="annottext">[DataDecl]
</span><a href="#local-6989586621681360820"><span class="hs-identifier hs-var">d2</span></a></span></span><span> </span><span id="local-6989586621681360819"><span class="annot"><span class="annottext">[TySynDecl]
</span><a href="#local-6989586621681360819"><span class="hs-identifier hs-var">e2</span></a></span></span><span> </span><span id="local-6989586621681360818"><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
</span><a href="#local-6989586621681360818"><span class="hs-identifier hs-var">f2</span></a></span></span><span> </span><span id="local-6989586621681360817"><span class="annot"><span class="annottext">[ClosedTypeFamilyDecl]
</span><a href="#local-6989586621681360817"><span class="hs-identifier hs-var">g2</span></a></span></span><span> </span><span id="local-6989586621681360816"><span class="annot"><span class="annottext">[DerivedEqDecl]
</span><a href="#local-6989586621681360816"><span class="hs-identifier hs-var">h2</span></a></span></span><span> </span><span id="local-6989586621681360815"><span class="annot"><span class="annottext">[DerivedShowDecl]
</span><a href="#local-6989586621681360815"><span class="hs-identifier hs-var">i2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-58"></span><span>    </span><span class="annot"><span class="annottext">[DLetDec]
-&gt; [UClassDecl]
-&gt; [UInstDecl]
-&gt; [DataDecl]
-&gt; [TySynDecl]
-&gt; [OpenTypeFamilyDecl]
-&gt; [ClosedTypeFamilyDecl]
-&gt; [DerivedEqDecl]
-&gt; [DerivedShowDecl]
-&gt; PartitionedDecs
</span><a href="Data.Singletons.Partition.html#PDecs"><span class="hs-identifier hs-var">PDecs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621681360833"><span class="hs-identifier hs-var">a1</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec] -&gt; [DLetDec] -&gt; [DLetDec]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621681360823"><span class="hs-identifier hs-var">a2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[UClassDecl]
</span><a href="#local-6989586621681360832"><span class="hs-identifier hs-var">b1</span></a></span><span> </span><span class="annot"><span class="annottext">[UClassDecl] -&gt; [UClassDecl] -&gt; [UClassDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[UClassDecl]
</span><a href="#local-6989586621681360822"><span class="hs-identifier hs-var">b2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[UInstDecl]
</span><a href="#local-6989586621681360831"><span class="hs-identifier hs-var">c1</span></a></span><span> </span><span class="annot"><span class="annottext">[UInstDecl] -&gt; [UInstDecl] -&gt; [UInstDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[UInstDecl]
</span><a href="#local-6989586621681360821"><span class="hs-identifier hs-var">c2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[DataDecl]
</span><a href="#local-6989586621681360830"><span class="hs-identifier hs-var">d1</span></a></span><span> </span><span class="annot"><span class="annottext">[DataDecl] -&gt; [DataDecl] -&gt; [DataDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[DataDecl]
</span><a href="#local-6989586621681360820"><span class="hs-identifier hs-var">d2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TySynDecl]
</span><a href="#local-6989586621681360829"><span class="hs-identifier hs-var">e1</span></a></span><span> </span><span class="annot"><span class="annottext">[TySynDecl] -&gt; [TySynDecl] -&gt; [TySynDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[TySynDecl]
</span><a href="#local-6989586621681360819"><span class="hs-identifier hs-var">e2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
</span><a href="#local-6989586621681360828"><span class="hs-identifier hs-var">f1</span></a></span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
-&gt; [OpenTypeFamilyDecl] -&gt; [OpenTypeFamilyDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
</span><a href="#local-6989586621681360818"><span class="hs-identifier hs-var">f2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ClosedTypeFamilyDecl]
</span><a href="#local-6989586621681360827"><span class="hs-identifier hs-var">g1</span></a></span><span> </span><span class="annot"><span class="annottext">[ClosedTypeFamilyDecl]
-&gt; [ClosedTypeFamilyDecl] -&gt; [ClosedTypeFamilyDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ClosedTypeFamilyDecl]
</span><a href="#local-6989586621681360817"><span class="hs-identifier hs-var">g2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[DerivedEqDecl]
</span><a href="#local-6989586621681360826"><span class="hs-identifier hs-var">h1</span></a></span><span> </span><span class="annot"><span class="annottext">[DerivedEqDecl] -&gt; [DerivedEqDecl] -&gt; [DerivedEqDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[DerivedEqDecl]
</span><a href="#local-6989586621681360816"><span class="hs-identifier hs-var">h2</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[DerivedShowDecl]
</span><a href="#local-6989586621681360825"><span class="hs-identifier hs-var">i1</span></a></span><span> </span><span class="annot"><span class="annottext">[DerivedShowDecl] -&gt; [DerivedShowDecl] -&gt; [DerivedShowDecl]
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[DerivedShowDecl]
</span><a href="#local-6989586621681360815"><span class="hs-identifier hs-var">i2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681360809"><span id="local-6989586621681360811"><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="Data.Singletons.Partition.html#PartitionedDecs"><span class="hs-identifier hs-type">PartitionedDecs</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-62"></span><span>  </span><span id="local-6989586621681360807"><span class="annot"><span class="annottext">mempty :: PartitionedDecs
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">mempty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DLetDec]
-&gt; [UClassDecl]
-&gt; [UInstDecl]
-&gt; [DataDecl]
-&gt; [TySynDecl]
-&gt; [OpenTypeFamilyDecl]
-&gt; [ClosedTypeFamilyDecl]
-&gt; [DerivedEqDecl]
-&gt; [DerivedShowDecl]
-&gt; PartitionedDecs
</span><a href="Data.Singletons.Partition.html#PDecs"><span class="hs-identifier hs-var">PDecs</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">[UClassDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">[UInstDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">[DataDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">[TySynDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-63"></span><span>                 </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">[ClosedTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">[DerivedEqDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">[DerivedShowDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-comment">-- | Split up a @[DDec]@ into its pieces, extracting 'Ord' instances</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- from deriving clauses</span><span>
</span><span id="line-67"></span><span id="local-6989586621681360806"><span class="annot"><a href="Data.Singletons.Partition.html#partitionDecs"><span class="hs-identifier hs-type">partitionDecs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Singletons.TH.Options.html#OptionsMonad"><span class="hs-identifier hs-type">OptionsMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681360806"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">DDec</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681360806"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Data.Singletons.Partition.html#PartitionedDecs"><span class="hs-identifier hs-type">PartitionedDecs</span></a></span></span><span>
</span><span id="line-68"></span><span id="partitionDecs"><span class="annot"><span class="annottext">partitionDecs :: [DDec] -&gt; m PartitionedDecs
</span><a href="Data.Singletons.Partition.html#partitionDecs"><span class="hs-identifier hs-var hs-var">partitionDecs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(DDec -&gt; m PartitionedDecs) -&gt; [DDec] -&gt; m PartitionedDecs
forall (monad :: * -&gt; *) monoid (t :: * -&gt; *) a.
(Monad monad, Monoid monoid, Traversable t) =&gt;
(a -&gt; monad monoid) -&gt; t a -&gt; monad monoid
</span><a href="Data.Singletons.Util.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span> </span><span class="annot"><span class="annottext">DDec -&gt; m PartitionedDecs
forall (m :: * -&gt; *). OptionsMonad m =&gt; DDec -&gt; m PartitionedDecs
</span><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span id="local-6989586621681360963"><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-type">partitionDec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Singletons.TH.Options.html#OptionsMonad"><span class="hs-identifier hs-type">OptionsMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681360963"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DDec</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681360963"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Data.Singletons.Partition.html#PartitionedDecs"><span class="hs-identifier hs-type">PartitionedDecs</span></a></span></span><span>
</span><span id="line-71"></span><span id="partitionDec"><span class="annot"><span class="annottext">partitionDec :: DDec -&gt; m PartitionedDecs
</span><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var hs-var">partitionDec</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DPragmaD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-72"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span id="local-6989586621681360800"><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621681360800"><span class="hs-identifier hs-var">letdec</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_let_decs :: [DLetDec]
</span><a href="Data.Singletons.Partition.html#pd_let_decs"><span class="hs-identifier hs-var">pd_let_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621681360800"><span class="hs-identifier hs-var">letdec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DDataD</span></span><span> </span><span id="local-6989586621681360798"><span class="annot"><span class="annottext">NewOrData
</span><a href="#local-6989586621681360798"><span class="hs-identifier hs-var">_nd</span></a></span></span><span> </span><span id="local-6989586621681360797"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360797"><span class="hs-identifier hs-var">_cxt</span></a></span></span><span> </span><span id="local-6989586621681360796"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360796"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681360795"><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360795"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621681360794"><span class="annot"><span class="annottext">Maybe DKind
</span><a href="#local-6989586621681360794"><span class="hs-identifier hs-var">mk</span></a></span></span><span> </span><span id="local-6989586621681360793"><span class="annot"><span class="annottext">[DCon]
</span><a href="#local-6989586621681360793"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621681360792"><span class="annot"><span class="annottext">[DDerivClause]
</span><a href="#local-6989586621681360792"><span class="hs-identifier hs-var">derivings</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-75"></span><span>  </span><span id="local-6989586621681360791"><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360791"><span class="hs-identifier hs-var">all_tvbs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr] -&gt; Maybe DKind -&gt; m [DTyVarBndr]
forall (q :: * -&gt; *).
DsMonad q =&gt;
[DTyVarBndr] -&gt; Maybe DKind -&gt; q [DTyVarBndr]
</span><a href="Data.Singletons.Util.html#buildDataDTvbs"><span class="hs-identifier hs-var">buildDataDTvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360795"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DKind
</span><a href="#local-6989586621681360794"><span class="hs-identifier hs-var">mk</span></a></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681360789"><span class="annot"><span class="annottext">data_decl :: DataDecl
</span><a href="#local-6989586621681360789"><span class="hs-identifier hs-var hs-var">data_decl</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [DTyVarBndr] -&gt; [DCon] -&gt; DataDecl
</span><a href="Data.Singletons.Syntax.html#DataDecl"><span class="hs-identifier hs-var">DataDecl</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360796"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360791"><span class="hs-identifier hs-var">all_tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[DCon]
</span><a href="#local-6989586621681360793"><span class="hs-identifier hs-var">cons</span></a></span><span>
</span><span id="line-77"></span><span>      </span><span id="local-6989586621681360787"><span class="annot"><span class="annottext">derived_dec :: PartitionedDecs
</span><a href="#local-6989586621681360787"><span class="hs-identifier hs-var hs-var">derived_dec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_data_decs :: [DataDecl]
</span><a href="Data.Singletons.Partition.html#pd_data_decs"><span class="hs-identifier hs-var">pd_data_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DataDecl
</span><a href="#local-6989586621681360789"><span class="hs-identifier hs-var">data_decl</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-78"></span><span>  </span><span id="local-6989586621681360786"><span class="annot"><span class="annottext">[PartitionedDecs]
</span><a href="#local-6989586621681360786"><span class="hs-identifier hs-var">derived_decs</span></a></span></span><span>
</span><span id="line-79"></span><span>    </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">((Maybe DDerivStrategy, DKind) -&gt; m PartitionedDecs)
-&gt; [(Maybe DDerivStrategy, DKind)] -&gt; m [PartitionedDecs]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621681360784"><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360784"><span class="hs-identifier hs-var">strat</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681360783"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360783"><span class="hs-identifier hs-var">deriv_pred</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-80"></span><span>              </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681360782"><span class="annot"><span class="annottext">etad_tvbs :: [DTyVarBndr]
</span><a href="#local-6989586621681360782"><span class="hs-identifier hs-var hs-var">etad_tvbs</span></a></span></span><span>
</span><span id="line-81"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DConT</span></span><span> </span><span id="local-6989586621681360780"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360780"><span class="hs-identifier hs-var">pred_name</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[DTypeArg]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DKind -&gt; (DKind, [DTypeArg])
</span><span class="hs-identifier hs-var">unfoldDType</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360783"><span class="hs-identifier hs-var">deriv_pred</span></a></span><span>
</span><span id="line-82"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Bool
</span><a href="Data.Singletons.Deriving.Util.html#isFunctorLikeClassName"><span class="hs-identifier hs-var">isFunctorLikeClassName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360780"><span class="hs-identifier hs-var">pred_name</span></a></span><span>
</span><span id="line-83"></span><span>                      </span><span class="hs-comment">-- If deriving Functor, Foldable, or Traversable,</span><span>
</span><span id="line-84"></span><span>                      </span><span class="hs-comment">-- we need to use one less type variable than we normally do.</span><span>
</span><span id="line-85"></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [DTyVarBndr] -&gt; [DTyVarBndr]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[DTyVarBndr] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360791"><span class="hs-identifier hs-var">all_tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360791"><span class="hs-identifier hs-var">all_tvbs</span></a></span><span>
</span><span id="line-86"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-87"></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360791"><span class="hs-identifier hs-var">all_tvbs</span></a></span><span>
</span><span id="line-88"></span><span>                  </span><span id="local-6989586621681360775"><span class="annot"><span class="annottext">ty :: DKind
</span><a href="#local-6989586621681360775"><span class="hs-identifier hs-var hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DKind -&gt; [DTyVarBndr] -&gt; DKind
</span><a href="Data.Singletons.Util.html#foldTypeTvbs"><span class="hs-identifier hs-var">foldTypeTvbs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; DKind
</span><span class="hs-identifier hs-var">DConT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360796"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360782"><span class="hs-identifier hs-var">etad_tvbs</span></a></span><span>
</span><span id="line-89"></span><span>              </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
-&gt; DKind -&gt; Maybe DCxt -&gt; DKind -&gt; DataDecl -&gt; m PartitionedDecs
forall (m :: * -&gt; *).
OptionsMonad m =&gt;
Maybe DDerivStrategy
-&gt; DKind -&gt; Maybe DCxt -&gt; DKind -&gt; DataDecl -&gt; m PartitionedDecs
</span><a href="Data.Singletons.Partition.html#partitionDeriving"><span class="hs-identifier hs-var">partitionDeriving</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360784"><span class="hs-identifier hs-var">strat</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360783"><span class="hs-identifier hs-var">deriv_pred</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DCxt
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360775"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">DataDecl
</span><a href="#local-6989586621681360789"><span class="hs-identifier hs-var">data_decl</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>      </span><span class="annot"><span class="annottext">([(Maybe DDerivStrategy, DKind)] -&gt; m [PartitionedDecs])
-&gt; [(Maybe DDerivStrategy, DKind)] -&gt; m [PartitionedDecs]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(DDerivClause -&gt; [(Maybe DDerivStrategy, DKind)])
-&gt; [DDerivClause] -&gt; [(Maybe DDerivStrategy, DKind)]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><span class="hs-identifier hs-var">concatMap</span></span><span> </span><span class="annot"><span class="annottext">DDerivClause -&gt; [(Maybe DDerivStrategy, DKind)]
</span><a href="#local-6989586621681360771"><span class="hs-identifier hs-var">flatten_clause</span></a></span><span> </span><span class="annot"><span class="annottext">[DDerivClause]
</span><a href="#local-6989586621681360792"><span class="hs-identifier hs-var">derivings</span></a></span><span>
</span><span id="line-91"></span><span>  </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[PartitionedDecs] -&gt; PartitionedDecs
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span> </span><span class="annot"><span class="annottext">([PartitionedDecs] -&gt; PartitionedDecs)
-&gt; [PartitionedDecs] -&gt; PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
</span><a href="#local-6989586621681360787"><span class="hs-identifier hs-var">derived_dec</span></a></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; [PartitionedDecs] -&gt; [PartitionedDecs]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[PartitionedDecs]
</span><a href="#local-6989586621681360786"><span class="hs-identifier hs-var">derived_decs</span></a></span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-93"></span><span>    </span><span class="annot"><a href="#local-6989586621681360771"><span class="hs-identifier hs-type">flatten_clause</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DDerivClause</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DDerivStrategy</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DPred</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-94"></span><span>    </span><span id="local-6989586621681360771"><span class="annot"><span class="annottext">flatten_clause :: DDerivClause -&gt; [(Maybe DDerivStrategy, DKind)]
</span><a href="#local-6989586621681360771"><span class="hs-identifier hs-var hs-var">flatten_clause</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DDerivClause</span></span><span> </span><span id="local-6989586621681360768"><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360768"><span class="hs-identifier hs-var">strat</span></a></span></span><span> </span><span id="local-6989586621681360767"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360767"><span class="hs-identifier hs-var">preds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-95"></span><span>      </span><span class="annot"><span class="annottext">(DKind -&gt; (Maybe DDerivStrategy, DKind))
-&gt; DCxt -&gt; [(Maybe DDerivStrategy, DKind)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621681360766"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360766"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360768"><span class="hs-identifier hs-var">strat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360766"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360767"><span class="hs-identifier hs-var">preds</span></a></span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DClassD</span></span><span> </span><span id="local-6989586621681360764"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360764"><span class="hs-identifier hs-var">cxt</span></a></span></span><span> </span><span id="local-6989586621681360763"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360763"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681360762"><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360762"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621681360761"><span class="annot"><span class="annottext">[FunDep]
</span><a href="#local-6989586621681360761"><span class="hs-identifier hs-var">fds</span></a></span></span><span> </span><span id="local-6989586621681360760"><span class="annot"><span class="annottext">[DDec]
</span><a href="#local-6989586621681360760"><span class="hs-identifier hs-var">decs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-98"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621681360759"><span class="annot"><span class="annottext">ULetDecEnv
</span><a href="#local-6989586621681360759"><span class="hs-identifier hs-var">lde</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681360758"><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
</span><a href="#local-6989586621681360758"><span class="hs-identifier hs-var">otfs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(DDec -&gt; m (ULetDecEnv, [OpenTypeFamilyDecl]))
-&gt; [DDec] -&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (monad :: * -&gt; *) monoid (t :: * -&gt; *) a.
(Monad monad, Monoid monoid, Traversable t) =&gt;
(a -&gt; monad monoid) -&gt; t a -&gt; monad monoid
</span><a href="Data.Singletons.Util.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span> </span><span class="annot"><span class="annottext">DDec -&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (m :: * -&gt; *).
MonadFail m =&gt;
DDec -&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
</span><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="annot"><span class="annottext">[DDec]
</span><a href="#local-6989586621681360760"><span class="hs-identifier hs-var">decs</span></a></span><span>
</span><span id="line-99"></span><span>  </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_class_decs :: [UClassDecl]
</span><a href="Data.Singletons.Partition.html#pd_class_decs"><span class="hs-identifier hs-var">pd_class_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ClassDecl :: forall (ann :: AnnotationFlag).
DCxt
-&gt; Name
-&gt; [DTyVarBndr]
-&gt; [FunDep]
-&gt; LetDecEnv ann
-&gt; [OpenTypeFamilyDecl]
-&gt; ClassDecl ann
</span><a href="Data.Singletons.Syntax.html#ClassDecl"><span class="hs-identifier hs-type">ClassDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cd_cxt :: DCxt
</span><a href="Data.Singletons.Syntax.html#cd_cxt"><span class="hs-identifier hs-var">cd_cxt</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360764"><span class="hs-identifier hs-var">cxt</span></a></span><span>
</span><span id="line-100"></span><span>                                               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cd_name :: Name
</span><a href="Data.Singletons.Syntax.html#cd_name"><span class="hs-identifier hs-var">cd_name</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360763"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-101"></span><span>                                               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cd_tvbs :: [DTyVarBndr]
</span><a href="Data.Singletons.Syntax.html#cd_tvbs"><span class="hs-identifier hs-var">cd_tvbs</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360762"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-102"></span><span>                                               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cd_fds :: [FunDep]
</span><a href="Data.Singletons.Syntax.html#cd_fds"><span class="hs-identifier hs-var">cd_fds</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FunDep]
</span><a href="#local-6989586621681360761"><span class="hs-identifier hs-var">fds</span></a></span><span>
</span><span id="line-103"></span><span>                                               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cd_lde :: ULetDecEnv
</span><a href="Data.Singletons.Syntax.html#cd_lde"><span class="hs-identifier hs-var">cd_lde</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ULetDecEnv
</span><a href="#local-6989586621681360759"><span class="hs-identifier hs-var">lde</span></a></span><span>
</span><span id="line-104"></span><span>                                               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cd_atfs :: [OpenTypeFamilyDecl]
</span><a href="Data.Singletons.Syntax.html#cd_atfs"><span class="hs-identifier hs-var">cd_atfs</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
</span><a href="#local-6989586621681360758"><span class="hs-identifier hs-var">otfs</span></a></span><span class="hs-special">}</span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-105"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DInstanceD</span></span><span> </span><span class="annot"><span class="annottext">Maybe Overlap
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [DTyVarBndr]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681360748"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360748"><span class="hs-identifier hs-var">cxt</span></a></span></span><span> </span><span id="local-6989586621681360747"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360747"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span id="local-6989586621681360746"><span class="annot"><span class="annottext">[DDec]
</span><a href="#local-6989586621681360746"><span class="hs-identifier hs-var">decs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621681360745"><span class="annot"><span class="annottext">[(Name, ULetDecRHS)]
</span><a href="#local-6989586621681360745"><span class="hs-identifier hs-var">defns</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681360744"><span class="annot"><span class="annottext">OMap Name DKind
</span><a href="#local-6989586621681360744"><span class="hs-identifier hs-var">sigs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(([Maybe (Name, ULetDecRHS)], [OMap Name DKind])
 -&gt; ([(Name, ULetDecRHS)], OMap Name DKind))
-&gt; m ([Maybe (Name, ULetDecRHS)], [OMap Name DKind])
-&gt; m ([(Name, ULetDecRHS)], OMap Name DKind)
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([Maybe (Name, ULetDecRHS)] -&gt; [(Name, ULetDecRHS)])
-&gt; ([OMap Name DKind] -&gt; OMap Name DKind)
-&gt; ([Maybe (Name, ULetDecRHS)], [OMap Name DKind])
-&gt; ([(Name, ULetDecRHS)], OMap Name DKind)
forall (p :: * -&gt; * -&gt; *) a b c d.
Bifunctor p =&gt;
(a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d
</span><span class="hs-identifier hs-var">bimap</span></span><span> </span><span class="annot"><span class="annottext">[Maybe (Name, ULetDecRHS)] -&gt; [(Name, ULetDecRHS)]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="annot"><span class="annottext">[OMap Name DKind] -&gt; OMap Name DKind
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m ([Maybe (Name, ULetDecRHS)], [OMap Name DKind])
 -&gt; m ([(Name, ULetDecRHS)], OMap Name DKind))
-&gt; m ([Maybe (Name, ULetDecRHS)], [OMap Name DKind])
-&gt; m ([(Name, ULetDecRHS)], OMap Name DKind)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-107"></span><span>                   </span><span class="annot"><span class="annottext">(DDec -&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind))
-&gt; [DDec] -&gt; m ([Maybe (Name, ULetDecRHS)], [OMap Name DKind])
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; m (b, c)) -&gt; [a] -&gt; m ([b], [c])
</span><span class="hs-identifier hs-var">mapAndUnzipM</span></span><span> </span><span class="annot"><span class="annottext">DDec -&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
forall (m :: * -&gt; *).
MonadFail m =&gt;
DDec -&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
</span><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-var">partitionInstanceDec</span></a></span><span> </span><span class="annot"><span class="annottext">[DDec]
</span><a href="#local-6989586621681360746"><span class="hs-identifier hs-var">decs</span></a></span><span>
</span><span id="line-108"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621681360739"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360739"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681360738"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360738"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; DKind -&gt; m (Name, DCxt)
forall (m :: * -&gt; *).
MonadFail m =&gt;
DCxt -&gt; DKind -&gt; m (Name, DCxt)
</span><a href="#local-6989586621681360737"><span class="hs-identifier hs-var">split_app_tys</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360747"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-109"></span><span>  </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_instance_decs :: [UInstDecl]
</span><a href="Data.Singletons.Partition.html#pd_instance_decs"><span class="hs-identifier hs-var">pd_instance_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">InstDecl :: forall (ann :: AnnotationFlag).
DCxt
-&gt; Name
-&gt; DCxt
-&gt; OMap Name DKind
-&gt; [(Name, LetDecRHS ann)]
-&gt; InstDecl ann
</span><a href="Data.Singletons.Syntax.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">id_cxt :: DCxt
</span><a href="Data.Singletons.Syntax.html#id_cxt"><span class="hs-identifier hs-var">id_cxt</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360748"><span class="hs-identifier hs-var">cxt</span></a></span><span>
</span><span id="line-110"></span><span>                                                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_name :: Name
</span><a href="Data.Singletons.Syntax.html#id_name"><span class="hs-identifier hs-var">id_name</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360739"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-111"></span><span>                                                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_arg_tys :: DCxt
</span><a href="Data.Singletons.Syntax.html#id_arg_tys"><span class="hs-identifier hs-var">id_arg_tys</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360738"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-112"></span><span>                                                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_sigs :: OMap Name DKind
</span><a href="Data.Singletons.Syntax.html#id_sigs"><span class="hs-identifier hs-var">id_sigs</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OMap Name DKind
</span><a href="#local-6989586621681360744"><span class="hs-identifier hs-var">sigs</span></a></span><span>
</span><span id="line-113"></span><span>                                                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_meths :: [(Name, ULetDecRHS)]
</span><a href="Data.Singletons.Syntax.html#id_meths"><span class="hs-identifier hs-var">id_meths</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Name, ULetDecRHS)]
</span><a href="#local-6989586621681360745"><span class="hs-identifier hs-var">defns</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-115"></span><span>    </span><span id="local-6989586621681360737"><span class="annot"><span class="annottext">split_app_tys :: DCxt -&gt; DKind -&gt; m (Name, DCxt)
</span><a href="#local-6989586621681360737"><span class="hs-identifier hs-var hs-var">split_app_tys</span></a></span></span><span> </span><span id="local-6989586621681360730"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360730"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DAppT</span></span><span> </span><span id="local-6989586621681360728"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360728"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621681360727"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360727"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; DKind -&gt; m (Name, DCxt)
</span><a href="#local-6989586621681360737"><span class="hs-identifier hs-var">split_app_tys</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360727"><span class="hs-identifier hs-var">t2</span></a></span><span class="annot"><span class="annottext">DKind -&gt; DCxt -&gt; DCxt
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360730"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360728"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-116"></span><span>    </span><span class="annot"><a href="#local-6989586621681360737"><span class="hs-identifier hs-var">split_app_tys</span></a></span><span> </span><span id="local-6989586621681360726"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360726"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DConT</span></span><span> </span><span id="local-6989586621681360725"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360725"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name, DCxt) -&gt; m (Name, DCxt)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360725"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360726"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>    </span><span class="annot"><a href="#local-6989586621681360737"><span class="hs-identifier hs-var">split_app_tys</span></a></span><span> </span><span id="local-6989586621681360724"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360724"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DSigT</span></span><span> </span><span id="local-6989586621681360722"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360722"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; DKind -&gt; m (Name, DCxt)
</span><a href="#local-6989586621681360737"><span class="hs-identifier hs-var">split_app_tys</span></a></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360724"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360722"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-118"></span><span>    </span><span class="annot"><a href="#local-6989586621681360737"><span class="hs-identifier hs-var">split_app_tys</span></a></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; m (Name, DCxt)
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; m (Name, DCxt)) -&gt; String -&gt; m (Name, DCxt)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Illegal instance head: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">DKind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360747"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-119"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DRoleAnnotD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>  </span><span class="hs-comment">-- ignore these</span><span>
</span><span id="line-120"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DTySynD</span></span><span> </span><span id="local-6989586621681360718"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360718"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681360717"><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360717"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621681360716"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360716"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-121"></span><span>  </span><span class="hs-comment">-- See Note [Partitioning, type synonyms, and type families]</span><span>
</span><span id="line-122"></span><span>  </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_ty_syn_decs :: [TySynDecl]
</span><a href="Data.Singletons.Partition.html#pd_ty_syn_decs"><span class="hs-identifier hs-var">pd_ty_syn_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name -&gt; [DTyVarBndr] -&gt; DKind -&gt; TySynDecl
</span><a href="Data.Singletons.Syntax.html#TySynDecl"><span class="hs-identifier hs-var">TySynDecl</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360718"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360717"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360716"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-123"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DClosedTypeFamilyD</span></span><span> </span><span id="local-6989586621681360713"><span class="annot"><span class="annottext">DTypeFamilyHead
</span><a href="#local-6989586621681360713"><span class="hs-identifier hs-var">tf_head</span></a></span></span><span> </span><span class="annot"><span class="annottext">[DTySynEqn]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-124"></span><span>  </span><span class="hs-comment">-- See Note [Partitioning, type synonyms, and type families]</span><span>
</span><span id="line-125"></span><span>  </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_closed_type_family_decs :: [ClosedTypeFamilyDecl]
</span><a href="Data.Singletons.Partition.html#pd_closed_type_family_decs"><span class="hs-identifier hs-var">pd_closed_type_family_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DTypeFamilyHead -&gt; ClosedTypeFamilyDecl
forall (info :: FamilyInfo). DTypeFamilyHead -&gt; TypeFamilyDecl info
</span><a href="Data.Singletons.Syntax.html#TypeFamilyDecl"><span class="hs-identifier hs-var">TypeFamilyDecl</span></a></span><span> </span><span class="annot"><span class="annottext">DTypeFamilyHead
</span><a href="#local-6989586621681360713"><span class="hs-identifier hs-var">tf_head</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-126"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DOpenTypeFamilyD</span></span><span> </span><span id="local-6989586621681360710"><span class="annot"><span class="annottext">DTypeFamilyHead
</span><a href="#local-6989586621681360710"><span class="hs-identifier hs-var">tf_head</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-127"></span><span>  </span><span class="hs-comment">-- See Note [Partitioning, type synonyms, and type families]</span><span>
</span><span id="line-128"></span><span>  </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_open_type_family_decs :: [OpenTypeFamilyDecl]
</span><a href="Data.Singletons.Partition.html#pd_open_type_family_decs"><span class="hs-identifier hs-var">pd_open_type_family_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DTypeFamilyHead -&gt; OpenTypeFamilyDecl
forall (info :: FamilyInfo). DTypeFamilyHead -&gt; TypeFamilyDecl info
</span><a href="Data.Singletons.Syntax.html#TypeFamilyDecl"><span class="hs-identifier hs-var">TypeFamilyDecl</span></a></span><span> </span><span class="annot"><span class="annottext">DTypeFamilyHead
</span><a href="#local-6989586621681360710"><span class="hs-identifier hs-var">tf_head</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-129"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DTySynInstD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-130"></span><span>  </span><span class="hs-comment">-- There's no need to track type family instances, since</span><span>
</span><span id="line-131"></span><span>  </span><span class="hs-comment">-- we already record the type family itself separately.</span><span>
</span><span id="line-132"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DKiSigD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-133"></span><span>  </span><span class="hs-comment">-- There's no need to track standalone kind signatures, since we use</span><span>
</span><span id="line-134"></span><span>  </span><span class="hs-comment">-- dsReifyType to look them up.</span><span>
</span><span id="line-135"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DStandaloneDerivD</span></span><span> </span><span id="local-6989586621681360706"><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360706"><span class="hs-identifier hs-var">mb_strat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe [DTyVarBndr]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681360705"><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360705"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621681360704"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360704"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-136"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DKind -&gt; (DKind, [DTypeArg])
</span><span class="hs-identifier hs-var">unfoldDType</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360704"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621681360703"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360703"><span class="hs-identifier hs-var">cls_pred_ty</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681360702"><span class="annot"><span class="annottext">[DTypeArg]
</span><a href="#local-6989586621681360702"><span class="hs-identifier hs-var">cls_tys</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681360701"><span class="annot"><span class="annottext">cls_normal_tys :: DCxt
</span><a href="#local-6989586621681360701"><span class="hs-identifier hs-var hs-var">cls_normal_tys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DTypeArg] -&gt; DCxt
</span><span class="hs-identifier hs-var">filterDTANormals</span></span><span> </span><span class="annot"><span class="annottext">[DTypeArg]
</span><a href="#local-6989586621681360702"><span class="hs-identifier hs-var">cls_tys</span></a></span><span>
</span><span id="line-139"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DCxt -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360701"><span class="hs-identifier hs-var">cls_normal_tys</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- We can't handle zero-parameter type classes</span><span>
</span><span id="line-140"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681360697"><span class="annot"><span class="annottext">cls_arg_tys :: DCxt
</span><a href="#local-6989586621681360697"><span class="hs-identifier hs-var hs-var">cls_arg_tys</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; DCxt
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">init</span></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360701"><span class="hs-identifier hs-var">cls_normal_tys</span></a></span><span>
</span><span id="line-141"></span><span>            </span><span id="local-6989586621681360695"><span class="annot"><span class="annottext">data_ty :: DKind
</span><a href="#local-6989586621681360695"><span class="hs-identifier hs-var hs-var">data_ty</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; DKind
forall a. [a] -&gt; a
</span><span class="hs-identifier hs-var">last</span></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360701"><span class="hs-identifier hs-var">cls_normal_tys</span></a></span><span>
</span><span id="line-142"></span><span>            </span><span id="local-6989586621681360693"><span class="annot"><span class="annottext">data_ty_head :: DKind
</span><a href="#local-6989586621681360693"><span class="hs-identifier hs-var hs-var">data_ty_head</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DKind -&gt; (DKind, [DTypeArg])
</span><span class="hs-identifier hs-var">unfoldDType</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360695"><span class="hs-identifier hs-var">data_ty</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681360692"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360692"><span class="hs-identifier hs-var">ty_head</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[DTypeArg]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360692"><span class="hs-identifier hs-var">ty_head</span></a></span><span>
</span><span id="line-143"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DConT</span></span><span> </span><span id="local-6989586621681360691"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360691"><span class="hs-identifier hs-var">data_tycon</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360693"><span class="hs-identifier hs-var">data_ty_head</span></a></span><span> </span><span class="hs-comment">-- We can't handle deriving an instance for something</span><span>
</span><span id="line-144"></span><span>                                         </span><span class="hs-comment">-- other than a type constructor application</span><span>
</span><span id="line-145"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681360690"><span class="annot"><span class="annottext">cls_pred :: DKind
</span><a href="#local-6989586621681360690"><span class="hs-identifier hs-var hs-var">cls_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DKind -&gt; DCxt -&gt; DKind
</span><a href="Data.Singletons.Util.html#foldType"><span class="hs-identifier hs-var">foldType</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360703"><span class="hs-identifier hs-var">cls_pred_ty</span></a></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360697"><span class="hs-identifier hs-var">cls_arg_tys</span></a></span><span>
</span><span id="line-146"></span><span>            </span><span id="local-6989586621681360688"><span class="annot"><span class="annottext">Maybe DInfo
</span><a href="#local-6989586621681360688"><span class="hs-identifier hs-var">dinfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; m (Maybe DInfo)
forall (q :: * -&gt; *). DsMonad q =&gt; Name -&gt; q (Maybe DInfo)
</span><span class="hs-identifier hs-var">dsReify</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360691"><span class="hs-identifier hs-var">data_tycon</span></a></span><span>
</span><span id="line-147"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe DInfo
</span><a href="#local-6989586621681360688"><span class="hs-identifier hs-var">dinfo</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-148"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DTyConI</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DDataD</span></span><span> </span><span class="annot"><span class="annottext">NewOrData
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681360685"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360685"><span class="hs-identifier hs-var">dn</span></a></span></span><span> </span><span id="local-6989586621681360684"><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360684"><span class="hs-identifier hs-var">dtvbs</span></a></span></span><span> </span><span id="local-6989586621681360683"><span class="annot"><span class="annottext">Maybe DKind
</span><a href="#local-6989586621681360683"><span class="hs-identifier hs-var">dk</span></a></span></span><span> </span><span id="local-6989586621681360682"><span class="annot"><span class="annottext">[DCon]
</span><a href="#local-6989586621681360682"><span class="hs-identifier hs-var">dcons</span></a></span></span><span> </span><span class="annot"><span class="annottext">[DDerivClause]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe [DDec]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-149"></span><span>                </span><span id="local-6989586621681360681"><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360681"><span class="hs-identifier hs-var">all_tvbs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr] -&gt; Maybe DKind -&gt; m [DTyVarBndr]
forall (q :: * -&gt; *).
DsMonad q =&gt;
[DTyVarBndr] -&gt; Maybe DKind -&gt; q [DTyVarBndr]
</span><a href="Data.Singletons.Util.html#buildDataDTvbs"><span class="hs-identifier hs-var">buildDataDTvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360684"><span class="hs-identifier hs-var">dtvbs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DKind
</span><a href="#local-6989586621681360683"><span class="hs-identifier hs-var">dk</span></a></span><span>
</span><span id="line-150"></span><span>                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681360680"><span class="annot"><span class="annottext">data_decl :: DataDecl
</span><a href="#local-6989586621681360680"><span class="hs-identifier hs-var hs-var">data_decl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [DTyVarBndr] -&gt; [DCon] -&gt; DataDecl
</span><a href="Data.Singletons.Syntax.html#DataDecl"><span class="hs-identifier hs-var">DataDecl</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360685"><span class="hs-identifier hs-var">dn</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621681360681"><span class="hs-identifier hs-var">all_tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[DCon]
</span><a href="#local-6989586621681360682"><span class="hs-identifier hs-var">dcons</span></a></span><span>
</span><span id="line-151"></span><span>                </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
-&gt; DKind -&gt; Maybe DCxt -&gt; DKind -&gt; DataDecl -&gt; m PartitionedDecs
forall (m :: * -&gt; *).
OptionsMonad m =&gt;
Maybe DDerivStrategy
-&gt; DKind -&gt; Maybe DCxt -&gt; DKind -&gt; DataDecl -&gt; m PartitionedDecs
</span><a href="Data.Singletons.Partition.html#partitionDeriving"><span class="hs-identifier hs-var">partitionDeriving</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360706"><span class="hs-identifier hs-var">mb_strat</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360690"><span class="hs-identifier hs-var">cls_pred</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DCxt -&gt; Maybe DCxt
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">DCxt
</span><a href="#local-6989586621681360705"><span class="hs-identifier hs-var">ctxt</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360695"><span class="hs-identifier hs-var">data_ty</span></a></span><span> </span><span class="annot"><span class="annottext">DataDecl
</span><a href="#local-6989586621681360680"><span class="hs-identifier hs-var">data_decl</span></a></span><span>
</span><span id="line-152"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">DInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-153"></span><span>                </span><span class="annot"><span class="annottext">String -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; m PartitionedDecs) -&gt; String -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Standalone derived instance for something other than a datatype: &quot;</span></span><span>
</span><span id="line-154"></span><span>                       </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">DKind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360695"><span class="hs-identifier hs-var">data_ty</span></a></span><span>
</span><span id="line-155"></span><span>              </span><span class="annot"><span class="annottext">Maybe DInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; m PartitionedDecs) -&gt; String -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Cannot find &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">DKind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360695"><span class="hs-identifier hs-var">data_ty</span></a></span><span>
</span><span id="line-156"></span><span>    </span><span class="annot"><span class="annottext">(DKind, [DTypeArg])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-157"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDec"><span class="hs-identifier hs-var">partitionDec</span></a></span><span> </span><span id="local-6989586621681360679"><span class="annot"><span class="annottext">DDec
</span><a href="#local-6989586621681360679"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-158"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; m PartitionedDecs) -&gt; String -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Declaration cannot be promoted: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[Dec] -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DDec -&gt; [Dec]
</span><span class="hs-identifier hs-var">decToTH</span></span><span> </span><span class="annot"><span class="annottext">DDec
</span><a href="#local-6989586621681360679"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span id="local-6989586621681360929"><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-type">partitionClassDec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621681360929"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DDec</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681360929"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Singletons.Syntax.html#ULetDecEnv"><span class="hs-identifier hs-type">ULetDecEnv</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Singletons.Syntax.html#OpenTypeFamilyDecl"><span class="hs-identifier hs-type">OpenTypeFamilyDecl</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span><span>
</span><span id="line-161"></span><span id="partitionClassDec"><span class="annot"><span class="annottext">partitionClassDec :: DDec -&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
</span><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var hs-var">partitionClassDec</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DSigD</span></span><span> </span><span id="local-6989586621681360675"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360675"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681360674"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360674"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-162"></span><span>  </span><span class="annot"><span class="annottext">(ULetDecEnv, [OpenTypeFamilyDecl])
-&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; DKind -&gt; ULetDecEnv
</span><a href="Data.Singletons.Syntax.html#typeBinding"><span class="hs-identifier hs-var">typeBinding</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360675"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360674"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-163"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DValD</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DVarP</span></span><span> </span><span id="local-6989586621681360670"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360670"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621681360669"><span class="annot"><span class="annottext">DExp
</span><a href="#local-6989586621681360669"><span class="hs-identifier hs-var">exp</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-164"></span><span>  </span><span class="annot"><span class="annottext">(ULetDecEnv, [OpenTypeFamilyDecl])
-&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; ULetDecRHS -&gt; ULetDecEnv
</span><a href="Data.Singletons.Syntax.html#valueBinding"><span class="hs-identifier hs-var">valueBinding</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360670"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DExp -&gt; ULetDecRHS
</span><a href="Data.Singletons.Syntax.html#UValue"><span class="hs-identifier hs-var">UValue</span></a></span><span> </span><span class="annot"><span class="annottext">DExp
</span><a href="#local-6989586621681360669"><span class="hs-identifier hs-var">exp</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-165"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DFunD</span></span><span> </span><span id="local-6989586621681360665"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360665"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681360664"><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621681360664"><span class="hs-identifier hs-var">clauses</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-166"></span><span>  </span><span class="annot"><span class="annottext">(ULetDecEnv, [OpenTypeFamilyDecl])
-&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; ULetDecRHS -&gt; ULetDecEnv
</span><a href="Data.Singletons.Syntax.html#valueBinding"><span class="hs-identifier hs-var">valueBinding</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360665"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[DClause] -&gt; ULetDecRHS
</span><a href="Data.Singletons.Syntax.html#UFunction"><span class="hs-identifier hs-var">UFunction</span></a></span><span> </span><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621681360664"><span class="hs-identifier hs-var">clauses</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DInfixD</span></span><span> </span><span id="local-6989586621681360661"><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621681360661"><span class="hs-identifier hs-var">fixity</span></a></span></span><span> </span><span id="local-6989586621681360660"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360660"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-168"></span><span>  </span><span class="annot"><span class="annottext">(ULetDecEnv, [OpenTypeFamilyDecl])
-&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Fixity -&gt; Name -&gt; ULetDecEnv
</span><a href="Data.Singletons.Syntax.html#infixDecl"><span class="hs-identifier hs-var">infixDecl</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621681360661"><span class="hs-identifier hs-var">fixity</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360660"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-169"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DPragmaD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-170"></span><span>  </span><span class="annot"><span class="annottext">(ULetDecEnv, [OpenTypeFamilyDecl])
-&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ULetDecEnv
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-171"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DOpenTypeFamilyD</span></span><span> </span><span id="local-6989586621681360658"><span class="annot"><span class="annottext">DTypeFamilyHead
</span><a href="#local-6989586621681360658"><span class="hs-identifier hs-var">tf_head</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-172"></span><span>  </span><span class="hs-comment">-- See Note [Partitioning, type synonyms, and type families]</span><span>
</span><span id="line-173"></span><span>  </span><span class="annot"><span class="annottext">(ULetDecEnv, [OpenTypeFamilyDecl])
-&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ULetDecEnv
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DTypeFamilyHead -&gt; OpenTypeFamilyDecl
forall (info :: FamilyInfo). DTypeFamilyHead -&gt; TypeFamilyDecl info
</span><a href="Data.Singletons.Syntax.html#TypeFamilyDecl"><span class="hs-identifier hs-var">TypeFamilyDecl</span></a></span><span> </span><span class="annot"><span class="annottext">DTypeFamilyHead
</span><a href="#local-6989586621681360658"><span class="hs-identifier hs-var">tf_head</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-174"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DTySynInstD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-175"></span><span>  </span><span class="hs-comment">-- There's no need to track associated type family default equations, since</span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-comment">-- we already record the type family itself separately.</span><span>
</span><span id="line-177"></span><span>  </span><span class="annot"><span class="annottext">(ULetDecEnv, [OpenTypeFamilyDecl])
-&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ULetDecEnv
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[OpenTypeFamilyDecl]
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-178"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionClassDec"><span class="hs-identifier hs-var">partitionClassDec</span></a></span><span> </span><span class="annot"><span class="annottext">DDec
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-179"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; m (ULetDecEnv, [OpenTypeFamilyDecl])
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Only method declarations can be promoted within a class.&quot;</span></span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span id="local-6989586621681360908"><span class="annot"><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-type">partitionInstanceDec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621681360908"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DDec</span></span><span>
</span><span id="line-182"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681360908"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Singletons.Syntax.html#ULetDecRHS"><span class="hs-identifier hs-type">ULetDecRHS</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- right-hand sides of methods</span><span>
</span><span id="line-183"></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">OMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DType</span></span><span>          </span><span class="hs-comment">-- method type signatures</span><span>
</span><span id="line-184"></span><span>                          </span><span class="hs-special">)</span></span><span>
</span><span id="line-185"></span><span id="partitionInstanceDec"><span class="annot"><span class="annottext">partitionInstanceDec :: DDec -&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
</span><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-var hs-var">partitionInstanceDec</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DValD</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DVarP</span></span><span> </span><span id="local-6989586621681360656"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360656"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621681360655"><span class="annot"><span class="annottext">DExp
</span><a href="#local-6989586621681360655"><span class="hs-identifier hs-var">exp</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-186"></span><span>  </span><span class="annot"><span class="annottext">(Maybe (Name, ULetDecRHS), OMap Name DKind)
-&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name, ULetDecRHS) -&gt; Maybe (Name, ULetDecRHS)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360656"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DExp -&gt; ULetDecRHS
</span><a href="Data.Singletons.Syntax.html#UValue"><span class="hs-identifier hs-var">UValue</span></a></span><span> </span><span class="annot"><span class="annottext">DExp
</span><a href="#local-6989586621681360655"><span class="hs-identifier hs-var">exp</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">OMap Name DKind
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-187"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-var">partitionInstanceDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DFunD</span></span><span> </span><span id="local-6989586621681360654"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360654"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681360653"><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621681360653"><span class="hs-identifier hs-var">clauses</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-188"></span><span>  </span><span class="annot"><span class="annottext">(Maybe (Name, ULetDecRHS), OMap Name DKind)
-&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name, ULetDecRHS) -&gt; Maybe (Name, ULetDecRHS)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360654"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[DClause] -&gt; ULetDecRHS
</span><a href="Data.Singletons.Syntax.html#UFunction"><span class="hs-identifier hs-var">UFunction</span></a></span><span> </span><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621681360653"><span class="hs-identifier hs-var">clauses</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">OMap Name DKind
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-var">partitionInstanceDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DSigD</span></span><span> </span><span id="local-6989586621681360652"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360652"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681360651"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360651"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-190"></span><span>  </span><span class="annot"><span class="annottext">(Maybe (Name, ULetDecRHS), OMap Name DKind)
-&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (Name, ULetDecRHS)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; DKind -&gt; OMap Name DKind
forall k v. k -&gt; v -&gt; OMap k v
</span><span class="hs-identifier hs-var">OMap.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360652"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360651"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-191"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-var">partitionInstanceDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DLetDec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DPragmaD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-192"></span><span>  </span><span class="annot"><span class="annottext">(Maybe (Name, ULetDecRHS), OMap Name DKind)
-&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (Name, ULetDecRHS)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">OMap Name DKind
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-var">partitionInstanceDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DTySynInstD</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-194"></span><span>  </span><span class="annot"><span class="annottext">(Maybe (Name, ULetDecRHS), OMap Name DKind)
-&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (Name, ULetDecRHS)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">OMap Name DKind
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-comment">-- There's no need to track associated type family instances, since</span><span>
</span><span id="line-196"></span><span>  </span><span class="hs-comment">-- we already record the type family itself separately.</span><span>
</span><span id="line-197"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionInstanceDec"><span class="hs-identifier hs-var">partitionInstanceDec</span></a></span><span> </span><span class="annot"><span class="annottext">DDec
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-198"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; m (Maybe (Name, ULetDecRHS), OMap Name DKind)
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Only method bodies can be promoted within an instance.&quot;</span></span><span>
</span><span id="line-199"></span><span>
</span><span id="line-200"></span><span class="annot"><a href="Data.Singletons.Partition.html#partitionDeriving"><span class="hs-identifier hs-type">partitionDeriving</span></a></span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681360937"><span class="annot"><a href="#local-6989586621681360937"><span class="hs-identifier hs-type">m</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Data.Singletons.TH.Options.html#OptionsMonad"><span class="hs-identifier hs-type">OptionsMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681360937"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-202"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DDerivStrategy</span></span><span>
</span><span id="line-203"></span><span>                </span><span class="hs-comment">-- ^ The deriving strategy, if present.</span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DPred</span></span><span>      </span><span class="hs-comment">-- ^ The class being derived (e.g., 'Eq'), possibly applied to</span><span>
</span><span id="line-205"></span><span>                </span><span class="hs-comment">--   some number of arguments (e.g., @C Int Bool@).</span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DCxt</span></span><span> </span><span class="hs-comment">-- ^ @'Just' ctx@ if @ctx@ was provided via @StandaloneDeriving@.</span><span>
</span><span id="line-207"></span><span>                </span><span class="hs-comment">--   'Nothing' if using a @deriving@ clause.</span><span>
</span><span id="line-208"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DType</span></span><span>      </span><span class="hs-comment">-- ^ The data type argument to the class.</span><span>
</span><span id="line-209"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Singletons.Syntax.html#DataDecl"><span class="hs-identifier hs-type">DataDecl</span></a></span><span>   </span><span class="hs-comment">-- ^ The original data type information (e.g., its constructors).</span><span>
</span><span id="line-210"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681360937"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Data.Singletons.Partition.html#PartitionedDecs"><span class="hs-identifier hs-type">PartitionedDecs</span></a></span><span>
</span><span id="line-211"></span><span id="partitionDeriving"><span class="annot"><span class="annottext">partitionDeriving :: Maybe DDerivStrategy
-&gt; DKind -&gt; Maybe DCxt -&gt; DKind -&gt; DataDecl -&gt; m PartitionedDecs
</span><a href="Data.Singletons.Partition.html#partitionDeriving"><span class="hs-identifier hs-var hs-var">partitionDeriving</span></a></span></span><span> </span><span id="local-6989586621681360649"><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360649"><span class="hs-identifier hs-var">mb_strat</span></a></span></span><span> </span><span id="local-6989586621681360648"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360648"><span class="hs-identifier hs-var">deriv_pred</span></a></span></span><span> </span><span id="local-6989586621681360647"><span class="annot"><span class="annottext">Maybe DCxt
</span><a href="#local-6989586621681360647"><span class="hs-identifier hs-var">mb_ctxt</span></a></span></span><span> </span><span id="local-6989586621681360646"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360646"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span id="local-6989586621681360645"><span class="annot"><span class="annottext">DataDecl
</span><a href="#local-6989586621681360645"><span class="hs-identifier hs-var">data_decl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DKind -&gt; (DKind, [DTypeArg])
</span><span class="hs-identifier hs-var">unfoldDType</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360648"><span class="hs-identifier hs-var">deriv_pred</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-213"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DConT</span></span><span> </span><span id="local-6989586621681360644"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360644"><span class="hs-identifier hs-var">deriv_name</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681360643"><span class="annot"><span class="annottext">[DTypeArg]
</span><a href="#local-6989586621681360643"><span class="hs-identifier hs-var">arg_tys</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-214"></span><span>         </span><span class="hs-comment">-- Here, we are more conservative than GHC: DeriveAnyClass only kicks</span><span>
</span><span id="line-215"></span><span>         </span><span class="hs-comment">-- in if the user explicitly chooses to do so with the anyclass</span><span>
</span><span id="line-216"></span><span>         </span><span class="hs-comment">-- deriving strategy</span><span>
</span><span id="line-217"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">DDerivStrategy
</span><span class="hs-identifier hs-var">DAnyclassStrategy</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360649"><span class="hs-identifier hs-var">mb_strat</span></a></span><span>
</span><span id="line-218"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var">mk_derived_inst</span></a></span><span>
</span><span id="line-219"></span><span>           </span><span class="annot"><span class="annottext">InstDecl :: forall (ann :: AnnotationFlag).
DCxt
-&gt; Name
-&gt; DCxt
-&gt; OMap Name DKind
-&gt; [(Name, LetDecRHS ann)]
-&gt; InstDecl ann
</span><a href="Data.Singletons.Syntax.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">id_cxt :: DCxt
</span><a href="Data.Singletons.Syntax.html#id_cxt"><span class="hs-identifier hs-var">id_cxt</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; Maybe DCxt -&gt; DCxt
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Maybe DCxt
</span><a href="#local-6989586621681360647"><span class="hs-identifier hs-var">mb_ctxt</span></a></span><span>
</span><span id="line-220"></span><span>                      </span><span class="hs-comment">-- For now at least, there's no point in attempting to</span><span>
</span><span id="line-221"></span><span>                      </span><span class="hs-comment">-- infer an instance context for DeriveAnyClass, since</span><span>
</span><span id="line-222"></span><span>                      </span><span class="hs-comment">-- the other language feature that requires it,</span><span>
</span><span id="line-223"></span><span>                      </span><span class="hs-comment">-- DefaultSignatures, can't be singled. Thus, inferring an</span><span>
</span><span id="line-224"></span><span>                      </span><span class="hs-comment">-- empty context will Just Work for all currently supported</span><span>
</span><span id="line-225"></span><span>                      </span><span class="hs-comment">-- default implementations.</span><span>
</span><span id="line-226"></span><span>                      </span><span class="hs-comment">--</span><span>
</span><span id="line-227"></span><span>                      </span><span class="hs-comment">-- (Of course, if a user specifies a context with</span><span>
</span><span id="line-228"></span><span>                      </span><span class="hs-comment">-- StandaloneDeriving, use that.)</span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_name :: Name
</span><a href="Data.Singletons.Syntax.html#id_name"><span class="hs-identifier hs-var">id_name</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360644"><span class="hs-identifier hs-var">deriv_name</span></a></span><span>
</span><span id="line-231"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_arg_tys :: DCxt
</span><a href="Data.Singletons.Syntax.html#id_arg_tys"><span class="hs-identifier hs-var">id_arg_tys</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DTypeArg] -&gt; DCxt
</span><span class="hs-identifier hs-var">filterDTANormals</span></span><span> </span><span class="annot"><span class="annottext">[DTypeArg]
</span><a href="#local-6989586621681360643"><span class="hs-identifier hs-var">arg_tys</span></a></span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; DCxt -&gt; DCxt
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360646"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-232"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_sigs :: OMap Name DKind
</span><a href="Data.Singletons.Syntax.html#id_sigs"><span class="hs-identifier hs-var">id_sigs</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OMap Name DKind
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-233"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">id_meths :: [(Name, ULetDecRHS)]
</span><a href="Data.Singletons.Syntax.html#id_meths"><span class="hs-identifier hs-var">id_meths</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">DDerivStrategy
</span><span class="hs-identifier hs-var">DNewtypeStrategy</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360649"><span class="hs-identifier hs-var">mb_strat</span></a></span><span>
</span><span id="line-236"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">String -&gt; m ()
forall (q :: * -&gt; *). Quasi q =&gt; String -&gt; q ()
</span><a href="Data.Singletons.Util.html#qReportWarning"><span class="hs-identifier hs-var">qReportWarning</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;GeneralizedNewtypeDeriving is ignored by `singletons`.&quot;</span></span><span>
</span><span id="line-237"></span><span>            </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-238"></span><span>
</span><span id="line-239"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DViaStrategy</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360649"><span class="hs-identifier hs-var">mb_strat</span></a></span><span>
</span><span id="line-240"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">String -&gt; m ()
forall (q :: * -&gt; *). Quasi q =&gt; String -&gt; q ()
</span><a href="Data.Singletons.Util.html#qReportWarning"><span class="hs-identifier hs-var">qReportWarning</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;DerivingVia is ignored by `singletons`.&quot;</span></span><span>
</span><span id="line-241"></span><span>            </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-242"></span><span>
</span><span id="line-243"></span><span>    </span><span class="hs-comment">-- Stock classes. These are derived only if `singletons` supports them</span><span>
</span><span id="line-244"></span><span>    </span><span class="hs-comment">-- (and, optionally, if an explicit stock deriving strategy is used)</span><span>
</span><span id="line-245"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DConT</span></span><span> </span><span id="local-6989586621681360636"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360636"><span class="hs-identifier hs-var">deriv_name</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- For now, all stock derivable class supported in</span><span>
</span><span id="line-246"></span><span>                           </span><span class="hs-comment">-- singletons take just one argument (the data</span><span>
</span><span id="line-247"></span><span>                           </span><span class="hs-comment">-- type itself)</span><span>
</span><span id="line-248"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681360635"><span class="hs-identifier hs-var">stock_or_default</span></a></span><span>
</span><span id="line-249"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621681360634"><span class="annot"><span class="annottext">m PartitionedDecs
</span><a href="#local-6989586621681360634"><span class="hs-identifier hs-var">decs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name (m PartitionedDecs) -&gt; Maybe (m PartitionedDecs)
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360636"><span class="hs-identifier hs-var">deriv_name</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name (m PartitionedDecs)
</span><a href="#local-6989586621681360632"><span class="hs-identifier hs-var">stock_map</span></a></span><span>
</span><span id="line-250"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m PartitionedDecs
</span><a href="#local-6989586621681360634"><span class="hs-identifier hs-var">decs</span></a></span><span>
</span><span id="line-251"></span><span>
</span><span id="line-252"></span><span>         </span><span class="hs-comment">-- If we can't find a stock class, but the user bothered to use an</span><span>
</span><span id="line-253"></span><span>         </span><span class="hs-comment">-- explicit stock keyword, we can at least warn them about it.</span><span>
</span><span id="line-254"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">DDerivStrategy
</span><span class="hs-identifier hs-var">DStockStrategy</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360649"><span class="hs-identifier hs-var">mb_strat</span></a></span><span>
</span><span id="line-255"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">String -&gt; m ()
forall (q :: * -&gt; *). Quasi q =&gt; String -&gt; q ()
</span><a href="Data.Singletons.Util.html#qReportWarning"><span class="hs-identifier hs-var">qReportWarning</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; m ()) -&gt; String -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;`singletons` doesn't recognize the stock class &quot;</span></span><span>
</span><span id="line-256"></span><span>                             </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360636"><span class="hs-identifier hs-var">deriv_name</span></a></span><span>
</span><span id="line-257"></span><span>            </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-258"></span><span>
</span><span id="line-259"></span><span>    </span><span class="annot"><span class="annottext">(DKind, [DTypeArg])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-comment">-- singletons doesn't support deriving this instance</span><span>
</span><span id="line-260"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-261"></span><span>      </span><span class="annot"><a href="#local-6989586621681360629"><span class="hs-identifier hs-type">mk_instance</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Singletons.Deriving.Util.html#DerivDesc"><span class="hs-identifier hs-type">DerivDesc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681360937"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681360937"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Data.Singletons.Syntax.html#UInstDecl"><span class="hs-identifier hs-type">UInstDecl</span></a></span><span>
</span><span id="line-262"></span><span>      </span><span id="local-6989586621681360629"><span class="annot"><span class="annottext">mk_instance :: DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var hs-var">mk_instance</span></a></span></span><span> </span><span id="local-6989586621681360628"><span class="annot"><span class="annottext">DerivDesc m
</span><a href="#local-6989586621681360628"><span class="hs-identifier hs-var">maker</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DerivDesc m
</span><a href="#local-6989586621681360628"><span class="hs-identifier hs-var">maker</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DCxt
</span><a href="#local-6989586621681360647"><span class="hs-identifier hs-var">mb_ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360646"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">DataDecl
</span><a href="#local-6989586621681360645"><span class="hs-identifier hs-var">data_decl</span></a></span><span>
</span><span id="line-263"></span><span>
</span><span id="line-264"></span><span>      </span><span id="local-6989586621681360641"><span class="annot"><span class="annottext">mk_derived_inst :: UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var hs-var">mk_derived_inst</span></a></span></span><span>    </span><span id="local-6989586621681360627"><span class="annot"><span class="annottext">UInstDecl
</span><a href="#local-6989586621681360627"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_instance_decs :: [UInstDecl]
</span><a href="Data.Singletons.Partition.html#pd_instance_decs"><span class="hs-identifier hs-var">pd_instance_decs</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">UInstDecl
</span><a href="#local-6989586621681360627"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-265"></span><span>      </span><span id="local-6989586621681360626"><span class="annot"><span class="annottext">mk_derived_eq_inst :: DerivedEqDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360626"><span class="hs-identifier hs-var hs-var">mk_derived_eq_inst</span></a></span></span><span> </span><span id="local-6989586621681360625"><span class="annot"><span class="annottext">DerivedEqDecl
</span><a href="#local-6989586621681360625"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_derived_eq_decs :: [DerivedEqDecl]
</span><a href="Data.Singletons.Partition.html#pd_derived_eq_decs"><span class="hs-identifier hs-var">pd_derived_eq_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DerivedEqDecl
</span><a href="#local-6989586621681360625"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span>      </span><span id="local-6989586621681360856"><span class="annot"><a href="#local-6989586621681360624"><span class="hs-identifier hs-type">derived_decl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Singletons.Syntax.html#DerivedDecl"><span class="hs-identifier hs-type">DerivedDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681360856"><span class="hs-identifier hs-type">cls</span></a></span></span><span>
</span><span id="line-268"></span><span>      </span><span id="local-6989586621681360624"><span class="annot"><span class="annottext">derived_decl :: DerivedDecl cls
</span><a href="#local-6989586621681360624"><span class="hs-identifier hs-var hs-var">derived_decl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DerivedDecl :: forall (cls :: * -&gt; Constraint).
Maybe DCxt -&gt; DKind -&gt; Name -&gt; DataDecl -&gt; DerivedDecl cls
</span><a href="Data.Singletons.Syntax.html#DerivedDecl"><span class="hs-identifier hs-type">DerivedDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ded_mb_cxt :: Maybe DCxt
</span><a href="Data.Singletons.Syntax.html#ded_mb_cxt"><span class="hs-identifier hs-var">ded_mb_cxt</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe DCxt
</span><a href="#local-6989586621681360647"><span class="hs-identifier hs-var">mb_ctxt</span></a></span><span>
</span><span id="line-269"></span><span>                                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ded_type :: DKind
</span><a href="Data.Singletons.Syntax.html#ded_type"><span class="hs-identifier hs-var">ded_type</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360646"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-270"></span><span>                                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ded_type_tycon :: Name
</span><a href="Data.Singletons.Syntax.html#ded_type_tycon"><span class="hs-identifier hs-var">ded_type_tycon</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360619"><span class="hs-identifier hs-var">ty_tycon</span></a></span><span>
</span><span id="line-271"></span><span>                                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ded_decl :: DataDecl
</span><a href="Data.Singletons.Syntax.html#ded_decl"><span class="hs-identifier hs-var">ded_decl</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataDecl
</span><a href="#local-6989586621681360645"><span class="hs-identifier hs-var">data_decl</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-272"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-273"></span><span>          </span><span class="annot"><a href="#local-6989586621681360619"><span class="hs-identifier hs-type">ty_tycon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-274"></span><span>          </span><span id="local-6989586621681360619"><span class="annot"><span class="annottext">ty_tycon :: Name
</span><a href="#local-6989586621681360619"><span class="hs-identifier hs-var hs-var">ty_tycon</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DKind -&gt; (DKind, [DTypeArg])
</span><span class="hs-identifier hs-var">unfoldDType</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360646"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-275"></span><span>                       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DConT</span></span><span> </span><span id="local-6989586621681360617"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360617"><span class="hs-identifier hs-var">tc</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[DTypeArg]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681360617"><span class="hs-identifier hs-var">tc</span></a></span><span>
</span><span id="line-276"></span><span>                       </span><span class="hs-special">(</span><span id="local-6989586621681360616"><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360616"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">,</span><span>        </span><span class="annot"><span class="annottext">[DTypeArg]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Name) -&gt; String -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Not a data type: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">DKind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DKind
</span><a href="#local-6989586621681360616"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-277"></span><span>      </span><span id="local-6989586621681360635"><span class="annot"><span class="annottext">stock_or_default :: Bool
</span><a href="#local-6989586621681360635"><span class="hs-identifier hs-var hs-var">stock_or_default</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy -&gt; Bool
</span><a href="Data.Singletons.Partition.html#isStockOrDefault"><span class="hs-identifier hs-var">isStockOrDefault</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><a href="#local-6989586621681360649"><span class="hs-identifier hs-var">mb_strat</span></a></span><span>
</span><span id="line-278"></span><span>
</span><span id="line-279"></span><span>      </span><span class="hs-comment">-- A mapping from all stock derivable classes (that singletons supports)</span><span>
</span><span id="line-280"></span><span>      </span><span class="hs-comment">-- to to derived code that they produce.</span><span>
</span><span id="line-281"></span><span>      </span><span class="annot"><a href="#local-6989586621681360632"><span class="hs-identifier hs-type">stock_map</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621681360937"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Data.Singletons.Partition.html#PartitionedDecs"><span class="hs-identifier hs-type">PartitionedDecs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-282"></span><span>      </span><span id="local-6989586621681360632"><span class="annot"><span class="annottext">stock_map :: Map Name (m PartitionedDecs)
</span><a href="#local-6989586621681360632"><span class="hs-identifier hs-var hs-var">stock_map</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Name, m PartitionedDecs)] -&gt; Map Name (m PartitionedDecs)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span>
</span><span id="line-283"></span><span>        </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#ordName"><span class="hs-identifier hs-var">ordName</span></a></span><span class="hs-special">,</span><span>         </span><span class="annot"><span class="annottext">UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var">mk_derived_inst</span></a></span><span> </span><span class="annot"><span class="annottext">(UInstDecl -&gt; PartitionedDecs) -&gt; m UInstDecl -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var">mk_instance</span></a></span><span> </span><span class="annot"><span class="annottext">DerivDesc m
forall (q :: * -&gt; *). DsMonad q =&gt; DerivDesc q
</span><a href="Data.Singletons.Deriving.Ord.html#mkOrdInstance"><span class="hs-identifier hs-var">mkOrdInstance</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-284"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#boundedName"><span class="hs-identifier hs-var">boundedName</span></a></span><span class="hs-special">,</span><span>     </span><span class="annot"><span class="annottext">UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var">mk_derived_inst</span></a></span><span> </span><span class="annot"><span class="annottext">(UInstDecl -&gt; PartitionedDecs) -&gt; m UInstDecl -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var">mk_instance</span></a></span><span> </span><span class="annot"><span class="annottext">DerivDesc m
forall (q :: * -&gt; *). DsMonad q =&gt; DerivDesc q
</span><a href="Data.Singletons.Deriving.Bounded.html#mkBoundedInstance"><span class="hs-identifier hs-var">mkBoundedInstance</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-285"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#enumName"><span class="hs-identifier hs-var">enumName</span></a></span><span class="hs-special">,</span><span>        </span><span class="annot"><span class="annottext">UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var">mk_derived_inst</span></a></span><span> </span><span class="annot"><span class="annottext">(UInstDecl -&gt; PartitionedDecs) -&gt; m UInstDecl -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var">mk_instance</span></a></span><span> </span><span class="annot"><span class="annottext">DerivDesc m
forall (q :: * -&gt; *). DsMonad q =&gt; DerivDesc q
</span><a href="Data.Singletons.Deriving.Enum.html#mkEnumInstance"><span class="hs-identifier hs-var">mkEnumInstance</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-286"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#functorName"><span class="hs-identifier hs-var">functorName</span></a></span><span class="hs-special">,</span><span>     </span><span class="annot"><span class="annottext">UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var">mk_derived_inst</span></a></span><span> </span><span class="annot"><span class="annottext">(UInstDecl -&gt; PartitionedDecs) -&gt; m UInstDecl -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var">mk_instance</span></a></span><span> </span><span class="annot"><span class="annottext">DerivDesc m
forall (q :: * -&gt; *). DsMonad q =&gt; DerivDesc q
</span><a href="Data.Singletons.Deriving.Functor.html#mkFunctorInstance"><span class="hs-identifier hs-var">mkFunctorInstance</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#foldableName"><span class="hs-identifier hs-var">foldableName</span></a></span><span class="hs-special">,</span><span>    </span><span class="annot"><span class="annottext">UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var">mk_derived_inst</span></a></span><span> </span><span class="annot"><span class="annottext">(UInstDecl -&gt; PartitionedDecs) -&gt; m UInstDecl -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var">mk_instance</span></a></span><span> </span><span class="annot"><span class="annottext">DerivDesc m
forall (q :: * -&gt; *). DsMonad q =&gt; DerivDesc q
</span><a href="Data.Singletons.Deriving.Foldable.html#mkFoldableInstance"><span class="hs-identifier hs-var">mkFoldableInstance</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#traversableName"><span class="hs-identifier hs-var">traversableName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">UInstDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360641"><span class="hs-identifier hs-var">mk_derived_inst</span></a></span><span> </span><span class="annot"><span class="annottext">(UInstDecl -&gt; PartitionedDecs) -&gt; m UInstDecl -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var">mk_instance</span></a></span><span> </span><span class="annot"><span class="annottext">DerivDesc m
forall (q :: * -&gt; *). DsMonad q =&gt; DerivDesc q
</span><a href="Data.Singletons.Deriving.Traversable.html#mkTraversableInstance"><span class="hs-identifier hs-var">mkTraversableInstance</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-289"></span><span>          </span><span class="hs-comment">-- See Note [DerivedDecl] in Data.Singletons.Syntax</span><span>
</span><span id="line-290"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#eqName"><span class="hs-identifier hs-var">eqName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DerivedEqDecl -&gt; PartitionedDecs
</span><a href="#local-6989586621681360626"><span class="hs-identifier hs-var">mk_derived_eq_inst</span></a></span><span> </span><span class="annot"><span class="annottext">DerivedEqDecl
forall (cls :: * -&gt; Constraint). DerivedDecl cls
</span><a href="#local-6989586621681360624"><span class="hs-identifier hs-var">derived_decl</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>          </span><span class="hs-comment">-- See Note [DerivedDecl] in Data.Singletons.Syntax</span><span>
</span><span id="line-292"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Data.Singletons.Names.html#showName"><span class="hs-identifier hs-var">showName</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-comment">-- These will become PShow/SShow instances...</span><span>
</span><span id="line-293"></span><span>                         </span><span id="local-6989586621681360597"><span class="annot"><span class="annottext">UInstDecl
</span><a href="#local-6989586621681360597"><span class="hs-identifier hs-var">inst_for_promotion</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DerivDesc m -&gt; m UInstDecl
</span><a href="#local-6989586621681360629"><span class="hs-identifier hs-var">mk_instance</span></a></span><span> </span><span class="annot"><span class="annottext">(DerivDesc m -&gt; m UInstDecl) -&gt; DerivDesc m -&gt; m UInstDecl
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ShowMode -&gt; DerivDesc m
forall (q :: * -&gt; *). OptionsMonad q =&gt; ShowMode -&gt; DerivDesc q
</span><a href="Data.Singletons.Deriving.Show.html#mkShowInstance"><span class="hs-identifier hs-var">mkShowInstance</span></a></span><span> </span><span class="annot"><span class="annottext">ShowMode
</span><a href="Data.Singletons.Deriving.Show.html#ForPromotion"><span class="hs-identifier hs-var">ForPromotion</span></a></span><span>
</span><span id="line-294"></span><span>                         </span><span class="hs-comment">-- ...and this will become a Show instance.</span><span>
</span><span id="line-295"></span><span>                         </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681360594"><span class="annot"><span class="annottext">inst_for_show :: DerivedDecl cls
</span><a href="#local-6989586621681360594"><span class="hs-identifier hs-var hs-var">inst_for_show</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DerivedDecl cls
forall (cls :: * -&gt; Constraint). DerivedDecl cls
</span><a href="#local-6989586621681360624"><span class="hs-identifier hs-var">derived_decl</span></a></span><span>
</span><span id="line-296"></span><span>                         </span><span class="annot"><span class="annottext">PartitionedDecs -&gt; m PartitionedDecs
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(PartitionedDecs -&gt; m PartitionedDecs)
-&gt; PartitionedDecs -&gt; m PartitionedDecs
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">PartitionedDecs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pd_instance_decs :: [UInstDecl]
</span><a href="Data.Singletons.Partition.html#pd_instance_decs"><span class="hs-identifier hs-var">pd_instance_decs</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">UInstDecl
</span><a href="#local-6989586621681360597"><span class="hs-identifier hs-var">inst_for_promotion</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-297"></span><span>                                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pd_derived_show_decs :: [DerivedShowDecl]
</span><a href="Data.Singletons.Partition.html#pd_derived_show_decs"><span class="hs-identifier hs-var">pd_derived_show_decs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DerivedShowDecl
forall (cls :: * -&gt; Constraint). DerivedDecl cls
</span><a href="#local-6989586621681360594"><span class="hs-identifier hs-var">inst_for_show</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-298"></span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span class="hs-comment">-- Is this being used with an explicit stock strategy, or no strategy at all?</span><span>
</span><span id="line-301"></span><span class="annot"><a href="Data.Singletons.Partition.html#isStockOrDefault"><span class="hs-identifier hs-type">isStockOrDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DDerivStrategy</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-302"></span><span id="isStockOrDefault"><span class="annot"><span class="annottext">isStockOrDefault :: Maybe DDerivStrategy -&gt; Bool
</span><a href="Data.Singletons.Partition.html#isStockOrDefault"><span class="hs-identifier hs-var hs-var">isStockOrDefault</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe DDerivStrategy
</span><span class="hs-identifier hs-var">Nothing</span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-303"></span><span class="annot"><a href="Data.Singletons.Partition.html#isStockOrDefault"><span class="hs-identifier hs-var">isStockOrDefault</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">DDerivStrategy
</span><span class="hs-identifier hs-var">DStockStrategy</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-304"></span><span class="annot"><a href="Data.Singletons.Partition.html#isStockOrDefault"><span class="hs-identifier hs-var">isStockOrDefault</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">DDerivStrategy
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-305"></span><span>
</span><span id="line-306"></span><span class="hs-comment">{-
Note [Partitioning, type synonyms, and type families]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The process of singling does not produce any new declarations corresponding to
type synonyms or type families, so they are &quot;ignored&quot; in a sense. Nevertheless,
we explicitly track them during partitioning, since we want to create
defunctionalization symbols for them.

Also note that:

1. Other uses of type synonyms in singled code will be expanded away.
2. Other uses of type families in singled code are unlikely to work at present
   due to Trac #12564.
3. We track open type families, closed type families, and associated type
   families separately, as each form of type family has different kind
   inference behavior. See defunTopLevelTypeDecls and
   defunAssociatedTypeFamilies in D.S.Promote.Defun for how these differences
   manifest.
-}</span><span>
</span><span id="line-325"></span></pre></body></html>