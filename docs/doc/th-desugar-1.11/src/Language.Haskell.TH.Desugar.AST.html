<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">{- Language/Haskell/TH/Desugar/AST.hs

(c) Ryan Scott 2018

Defines the desugared Template Haskell AST. The desugared types and
constructors are prefixed with a D.
-}</span><span>
</span><span id="line-8"></span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE CPP, DeriveDataTypeable, DeriveGeneric #-}</span><span>
</span><span id="line-10"></span><span>
</span><span id="line-11"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Desugar.AST</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-12"></span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Fixity</span></span><span class="hs-special">)</span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Fixity</span></span><span class="hs-special">)</span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Util</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#ForallVisFlag"><span class="hs-identifier">ForallVisFlag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span class="hs-comment">-- | Corresponds to TH's @Exp@ type. Note that @DLamE@ takes names, not patterns.</span><span>
</span><span id="line-19"></span><span id="local-6989586621679400957"><span id="local-6989586621679400958"></span></span><span class="hs-keyword">data</span><span> </span><span id="DExp"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-var">DExp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DVarE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarE"><span class="hs-identifier hs-var">DVarE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-20"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DConE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConE"><span class="hs-identifier hs-var">DConE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-21"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DLitE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLitE"><span class="hs-identifier hs-var">DLitE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Lit</span></span><span>
</span><span id="line-22"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DAppE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppE"><span class="hs-identifier hs-var">DAppE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-23"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DAppTypeE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppTypeE"><span class="hs-identifier hs-var">DAppTypeE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-24"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DLamE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLamE"><span class="hs-identifier hs-var">DLamE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-25"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DCaseE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCaseE"><span class="hs-identifier hs-var">DCaseE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier hs-type">DMatch</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-26"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DLetE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetE"><span class="hs-identifier hs-var">DLetE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-27"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DSigE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigE"><span class="hs-identifier hs-var">DSigE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-28"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DStaticE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DStaticE"><span class="hs-identifier hs-var">DStaticE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-29"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400942"><span id="local-6989586621679400944"><span class="annot"><span class="annottext">DExp -&gt; DExp -&gt; Bool
(DExp -&gt; DExp -&gt; Bool) -&gt; (DExp -&gt; DExp -&gt; Bool) -&gt; Eq DExp
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DExp -&gt; DExp -&gt; Bool
$c/= :: DExp -&gt; DExp -&gt; Bool
== :: DExp -&gt; DExp -&gt; Bool
$c== :: DExp -&gt; DExp -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400935"><span id="local-6989586621679400937"><span id="local-6989586621679400939"><span class="annot"><span class="annottext">Int -&gt; DExp -&gt; ShowS
[DExp] -&gt; ShowS
DExp -&gt; String
(Int -&gt; DExp -&gt; ShowS)
-&gt; (DExp -&gt; String) -&gt; ([DExp] -&gt; ShowS) -&gt; Show DExp
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DExp] -&gt; ShowS
$cshowList :: [DExp] -&gt; ShowS
show :: DExp -&gt; String
$cshow :: DExp -&gt; String
showsPrec :: Int -&gt; DExp -&gt; ShowS
$cshowsPrec :: Int -&gt; DExp -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDStaticE"><span id="%24cDSigE"><span id="%24cDLetE"><span id="%24cDCaseE"><span id="%24cDLamE"><span id="%24cDAppTypeE"><span id="%24cDAppE"><span id="%24cDLitE"><span id="%24cDConE"><span id="%24cDVarE"><span id="%24tDExp"><span id="local-6989586621679400905"><span id="local-6989586621679400907"><span id="local-6989586621679400909"><span id="local-6989586621679400911"><span id="local-6989586621679400913"><span id="local-6989586621679400915"><span id="local-6989586621679400917"><span id="local-6989586621679400919"><span id="local-6989586621679400921"><span id="local-6989586621679400923"><span id="local-6989586621679400925"><span id="local-6989586621679400927"><span id="local-6989586621679400929"><span id="local-6989586621679400931"><span class="annot"><span class="annottext">Typeable DExp
DataType
Constr
Typeable DExp
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp)
-&gt; (DExp -&gt; Constr)
-&gt; (DExp -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DExp))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DExp))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DExp -&gt; DExp)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp)
-&gt; Data DExp
DExp -&gt; DataType
DExp -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DExp -&gt; DExp
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DExp)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DExp)
$cDStaticE :: Constr
$cDSigE :: Constr
$cDLetE :: Constr
$cDCaseE :: Constr
$cDLamE :: Constr
$cDAppTypeE :: Constr
$cDAppE :: Constr
$cDLitE :: Constr
$cDConE :: Constr
$cDVarE :: Constr
$tDExp :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DExp -&gt; DExp
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DExp -&gt; DExp
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DExp)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DExp)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DExp)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DExp)
dataTypeOf :: DExp -&gt; DataType
$cdataTypeOf :: DExp -&gt; DataType
toConstr :: DExp -&gt; Constr
$ctoConstr :: DExp -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp
$cp1Data :: Typeable DExp
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DExp -&gt; Rep DExp x)
-&gt; (forall x. Rep DExp x -&gt; DExp) -&gt; Generic DExp
forall x. Rep DExp x -&gt; DExp
forall x. DExp -&gt; Rep DExp x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DExp x -&gt; DExp
$cfrom :: forall x. DExp -&gt; Rep DExp x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-comment">-- | Corresponds to TH's @Pat@ type.</span><span>
</span><span id="line-33"></span><span id="local-6989586621679400888"><span id="local-6989586621679400889"></span></span><span class="hs-keyword">data</span><span> </span><span id="DPat"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-var">DPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DLitP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLitP"><span class="hs-identifier hs-var">DLitP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Lit</span></span><span>
</span><span id="line-34"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DVarP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-var">DVarP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-35"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DConP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConP"><span class="hs-identifier hs-var">DConP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-36"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DTildeP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTildeP"><span class="hs-identifier hs-var">DTildeP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span>
</span><span id="line-37"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DBangP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangP"><span class="hs-identifier hs-var">DBangP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span>
</span><span id="line-38"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DSigP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigP"><span class="hs-identifier hs-var">DSigP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-39"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DWildP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DWildP"><span class="hs-identifier hs-var">DWildP</span></a></span></span><span>
</span><span id="line-40"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400877"><span id="local-6989586621679400879"><span class="annot"><span class="annottext">DPat -&gt; DPat -&gt; Bool
(DPat -&gt; DPat -&gt; Bool) -&gt; (DPat -&gt; DPat -&gt; Bool) -&gt; Eq DPat
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DPat -&gt; DPat -&gt; Bool
$c/= :: DPat -&gt; DPat -&gt; Bool
== :: DPat -&gt; DPat -&gt; Bool
$c== :: DPat -&gt; DPat -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400871"><span id="local-6989586621679400873"><span id="local-6989586621679400875"><span class="annot"><span class="annottext">Int -&gt; DPat -&gt; ShowS
[DPat] -&gt; ShowS
DPat -&gt; String
(Int -&gt; DPat -&gt; ShowS)
-&gt; (DPat -&gt; String) -&gt; ([DPat] -&gt; ShowS) -&gt; Show DPat
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DPat] -&gt; ShowS
$cshowList :: [DPat] -&gt; ShowS
show :: DPat -&gt; String
$cshow :: DPat -&gt; String
showsPrec :: Int -&gt; DPat -&gt; ShowS
$cshowsPrec :: Int -&gt; DPat -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDWildP"><span id="%24cDSigP"><span id="%24cDBangP"><span id="%24cDTildeP"><span id="%24cDConP"><span id="%24cDVarP"><span id="%24cDLitP"><span id="%24tDPat"><span id="local-6989586621679400842"><span id="local-6989586621679400844"><span id="local-6989586621679400846"><span id="local-6989586621679400848"><span id="local-6989586621679400850"><span id="local-6989586621679400852"><span id="local-6989586621679400854"><span id="local-6989586621679400856"><span id="local-6989586621679400858"><span id="local-6989586621679400860"><span id="local-6989586621679400862"><span id="local-6989586621679400864"><span id="local-6989586621679400866"><span id="local-6989586621679400868"><span class="annot"><span class="annottext">Typeable DPat
DataType
Constr
Typeable DPat
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat)
-&gt; (DPat -&gt; Constr)
-&gt; (DPat -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPat))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPat))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DPat -&gt; DPat)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat)
-&gt; Data DPat
DPat -&gt; DataType
DPat -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DPat -&gt; DPat
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPat)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPat)
$cDWildP :: Constr
$cDSigP :: Constr
$cDBangP :: Constr
$cDTildeP :: Constr
$cDConP :: Constr
$cDVarP :: Constr
$cDLitP :: Constr
$tDPat :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPat -&gt; DPat
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPat -&gt; DPat
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPat)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPat)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPat)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPat)
dataTypeOf :: DPat -&gt; DataType
$cdataTypeOf :: DPat -&gt; DataType
toConstr :: DPat -&gt; Constr
$ctoConstr :: DPat -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat
$cp1Data :: Typeable DPat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DPat -&gt; Rep DPat x)
-&gt; (forall x. Rep DPat x -&gt; DPat) -&gt; Generic DPat
forall x. Rep DPat x -&gt; DPat
forall x. DPat -&gt; Rep DPat x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DPat x -&gt; DPat
$cfrom :: forall x. DPat -&gt; Rep DPat x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span class="hs-comment">-- | Corresponds to TH's @Type@ type, used to represent</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- types and kinds.</span><span>
</span><span id="line-44"></span><span id="local-6989586621679400830"><span id="local-6989586621679400831"></span></span><span class="hs-keyword">data</span><span> </span><span id="DType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-var">DType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DForallT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForallT"><span class="hs-identifier hs-var">DForallT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#ForallVisFlag"><span class="hs-identifier hs-type">ForallVisFlag</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-45"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DConstrainedT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConstrainedT"><span class="hs-identifier hs-var">DConstrainedT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-46"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DAppT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppT"><span class="hs-identifier hs-var">DAppT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-47"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DAppKindT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppKindT"><span class="hs-identifier hs-var">DAppKindT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-48"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DSigT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigT"><span class="hs-identifier hs-var">DSigT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-49"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DVarT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarT"><span class="hs-identifier hs-var">DVarT</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-50"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DConT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConT"><span class="hs-identifier hs-var">DConT</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-51"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DArrowT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DArrowT"><span class="hs-identifier hs-var">DArrowT</span></a></span></span><span>
</span><span id="line-52"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DLitT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLitT"><span class="hs-identifier hs-var">DLitT</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyLit</span></span><span>
</span><span id="line-53"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DWildCardT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DWildCardT"><span class="hs-identifier hs-var">DWildCardT</span></a></span></span><span>
</span><span id="line-54"></span><span>           </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400813"><span id="local-6989586621679400815"><span class="annot"><span class="annottext">DType -&gt; DType -&gt; Bool
(DType -&gt; DType -&gt; Bool) -&gt; (DType -&gt; DType -&gt; Bool) -&gt; Eq DType
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DType -&gt; DType -&gt; Bool
$c/= :: DType -&gt; DType -&gt; Bool
== :: DType -&gt; DType -&gt; Bool
$c== :: DType -&gt; DType -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400807"><span id="local-6989586621679400809"><span id="local-6989586621679400811"><span class="annot"><span class="annottext">Int -&gt; DType -&gt; ShowS
[DType] -&gt; ShowS
DType -&gt; String
(Int -&gt; DType -&gt; ShowS)
-&gt; (DType -&gt; String) -&gt; ([DType] -&gt; ShowS) -&gt; Show DType
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DType] -&gt; ShowS
$cshowList :: [DType] -&gt; ShowS
show :: DType -&gt; String
$cshow :: DType -&gt; String
showsPrec :: Int -&gt; DType -&gt; ShowS
$cshowsPrec :: Int -&gt; DType -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDWildCardT"><span id="%24cDLitT"><span id="%24cDArrowT"><span id="%24cDConT"><span id="%24cDVarT"><span id="%24cDSigT"><span id="%24cDAppKindT"><span id="%24cDAppT"><span id="%24cDConstrainedT"><span id="%24cDForallT"><span id="%24tDType"><span id="local-6989586621679400778"><span id="local-6989586621679400780"><span id="local-6989586621679400782"><span id="local-6989586621679400784"><span id="local-6989586621679400786"><span id="local-6989586621679400788"><span id="local-6989586621679400790"><span id="local-6989586621679400792"><span id="local-6989586621679400794"><span id="local-6989586621679400796"><span id="local-6989586621679400798"><span id="local-6989586621679400800"><span id="local-6989586621679400802"><span id="local-6989586621679400804"><span class="annot"><span class="annottext">Typeable DType
DataType
Constr
Typeable DType
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType)
-&gt; (DType -&gt; Constr)
-&gt; (DType -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DType))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DType))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DType -&gt; DType)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType)
-&gt; Data DType
DType -&gt; DataType
DType -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DType -&gt; DType
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DType)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DType)
$cDWildCardT :: Constr
$cDLitT :: Constr
$cDArrowT :: Constr
$cDConT :: Constr
$cDVarT :: Constr
$cDSigT :: Constr
$cDAppKindT :: Constr
$cDAppT :: Constr
$cDConstrainedT :: Constr
$cDForallT :: Constr
$tDType :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DType -&gt; DType
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DType -&gt; DType
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DType)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DType)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DType)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DType)
dataTypeOf :: DType -&gt; DataType
$cdataTypeOf :: DType -&gt; DataType
toConstr :: DType -&gt; Constr
$ctoConstr :: DType -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType
$cp1Data :: Typeable DType
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DType -&gt; Rep DType x)
-&gt; (forall x. Rep DType x -&gt; DType) -&gt; Generic DType
forall x. Rep DType x -&gt; DType
forall x. DType -&gt; Rep DType x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DType x -&gt; DType
$cfrom :: forall x. DType -&gt; Rep DType x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-comment">-- | Kinds are types. Corresponds to TH's @Kind@</span><span>
</span><span id="line-57"></span><span class="hs-keyword">type</span><span> </span><span id="DKind"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-var">DKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="hs-comment">-- | Predicates are types. Corresponds to TH's @Pred@</span><span>
</span><span id="line-60"></span><span class="hs-keyword">type</span><span> </span><span id="DPred"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPred"><span class="hs-identifier hs-var">DPred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span class="hs-comment">-- | Corresponds to TH's @Cxt@</span><span>
</span><span id="line-63"></span><span class="hs-keyword">type</span><span> </span><span id="DCxt"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-var">DCxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPred"><span class="hs-identifier hs-type">DPred</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-comment">-- | Corresponds to TH's @TyVarBndr@</span><span>
</span><span id="line-66"></span><span id="local-6989586621679400762"><span id="local-6989586621679400763"></span></span><span class="hs-keyword">data</span><span> </span><span id="DTyVarBndr"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-var">DTyVarBndr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DPlainTV"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPlainTV"><span class="hs-identifier hs-var">DPlainTV</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-67"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="DKindedTV"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKindedTV"><span class="hs-identifier hs-var">DKindedTV</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-68"></span><span>                </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400756"><span id="local-6989586621679400758"><span class="annot"><span class="annottext">DTyVarBndr -&gt; DTyVarBndr -&gt; Bool
(DTyVarBndr -&gt; DTyVarBndr -&gt; Bool)
-&gt; (DTyVarBndr -&gt; DTyVarBndr -&gt; Bool) -&gt; Eq DTyVarBndr
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DTyVarBndr -&gt; DTyVarBndr -&gt; Bool
$c/= :: DTyVarBndr -&gt; DTyVarBndr -&gt; Bool
== :: DTyVarBndr -&gt; DTyVarBndr -&gt; Bool
$c== :: DTyVarBndr -&gt; DTyVarBndr -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400750"><span id="local-6989586621679400752"><span id="local-6989586621679400754"><span class="annot"><span class="annottext">Int -&gt; DTyVarBndr -&gt; ShowS
[DTyVarBndr] -&gt; ShowS
DTyVarBndr -&gt; String
(Int -&gt; DTyVarBndr -&gt; ShowS)
-&gt; (DTyVarBndr -&gt; String)
-&gt; ([DTyVarBndr] -&gt; ShowS)
-&gt; Show DTyVarBndr
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DTyVarBndr] -&gt; ShowS
$cshowList :: [DTyVarBndr] -&gt; ShowS
show :: DTyVarBndr -&gt; String
$cshow :: DTyVarBndr -&gt; String
showsPrec :: Int -&gt; DTyVarBndr -&gt; ShowS
$cshowsPrec :: Int -&gt; DTyVarBndr -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDKindedTV"><span id="%24cDPlainTV"><span id="%24tDTyVarBndr"><span id="local-6989586621679400721"><span id="local-6989586621679400723"><span id="local-6989586621679400725"><span id="local-6989586621679400727"><span id="local-6989586621679400729"><span id="local-6989586621679400731"><span id="local-6989586621679400733"><span id="local-6989586621679400735"><span id="local-6989586621679400737"><span id="local-6989586621679400739"><span id="local-6989586621679400741"><span id="local-6989586621679400743"><span id="local-6989586621679400745"><span id="local-6989586621679400747"><span class="annot"><span class="annottext">Typeable DTyVarBndr
DataType
Constr
Typeable DTyVarBndr
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr -&gt; c DTyVarBndr)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTyVarBndr)
-&gt; (DTyVarBndr -&gt; Constr)
-&gt; (DTyVarBndr -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTyVarBndr))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DTyVarBndr))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DTyVarBndr -&gt; DTyVarBndr)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr)
-&gt; Data DTyVarBndr
DTyVarBndr -&gt; DataType
DTyVarBndr -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DTyVarBndr -&gt; DTyVarBndr
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr -&gt; c DTyVarBndr
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTyVarBndr
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTyVarBndr
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr -&gt; c DTyVarBndr
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTyVarBndr)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTyVarBndr)
$cDKindedTV :: Constr
$cDPlainTV :: Constr
$tDTyVarBndr :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTyVarBndr -&gt; m DTyVarBndr
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTyVarBndr -&gt; DTyVarBndr
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTyVarBndr -&gt; DTyVarBndr
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTyVarBndr)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTyVarBndr)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTyVarBndr)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTyVarBndr)
dataTypeOf :: DTyVarBndr -&gt; DataType
$cdataTypeOf :: DTyVarBndr -&gt; DataType
toConstr :: DTyVarBndr -&gt; Constr
$ctoConstr :: DTyVarBndr -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTyVarBndr
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTyVarBndr
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr -&gt; c DTyVarBndr
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr -&gt; c DTyVarBndr
$cp1Data :: Typeable DTyVarBndr
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DTyVarBndr -&gt; Rep DTyVarBndr x)
-&gt; (forall x. Rep DTyVarBndr x -&gt; DTyVarBndr) -&gt; Generic DTyVarBndr
forall x. Rep DTyVarBndr x -&gt; DTyVarBndr
forall x. DTyVarBndr -&gt; Rep DTyVarBndr x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DTyVarBndr x -&gt; DTyVarBndr
$cfrom :: forall x. DTyVarBndr -&gt; Rep DTyVarBndr x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span class="hs-comment">-- | Corresponds to TH's @Match@ type.</span><span>
</span><span id="line-71"></span><span id="local-6989586621679400714"><span id="local-6989586621679400715"></span></span><span class="hs-keyword">data</span><span> </span><span id="DMatch"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier hs-var">DMatch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DMatch"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier hs-var">DMatch</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400709"><span id="local-6989586621679400711"><span class="annot"><span class="annottext">DMatch -&gt; DMatch -&gt; Bool
(DMatch -&gt; DMatch -&gt; Bool)
-&gt; (DMatch -&gt; DMatch -&gt; Bool) -&gt; Eq DMatch
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DMatch -&gt; DMatch -&gt; Bool
$c/= :: DMatch -&gt; DMatch -&gt; Bool
== :: DMatch -&gt; DMatch -&gt; Bool
$c== :: DMatch -&gt; DMatch -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400703"><span id="local-6989586621679400705"><span id="local-6989586621679400707"><span class="annot"><span class="annottext">Int -&gt; DMatch -&gt; ShowS
[DMatch] -&gt; ShowS
DMatch -&gt; String
(Int -&gt; DMatch -&gt; ShowS)
-&gt; (DMatch -&gt; String) -&gt; ([DMatch] -&gt; ShowS) -&gt; Show DMatch
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DMatch] -&gt; ShowS
$cshowList :: [DMatch] -&gt; ShowS
show :: DMatch -&gt; String
$cshow :: DMatch -&gt; String
showsPrec :: Int -&gt; DMatch -&gt; ShowS
$cshowsPrec :: Int -&gt; DMatch -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDMatch"><span id="%24tDMatch"><span id="local-6989586621679400674"><span id="local-6989586621679400676"><span id="local-6989586621679400678"><span id="local-6989586621679400680"><span id="local-6989586621679400682"><span id="local-6989586621679400684"><span id="local-6989586621679400686"><span id="local-6989586621679400688"><span id="local-6989586621679400690"><span id="local-6989586621679400692"><span id="local-6989586621679400694"><span id="local-6989586621679400696"><span id="local-6989586621679400698"><span id="local-6989586621679400700"><span class="annot"><span class="annottext">Typeable DMatch
DataType
Constr
Typeable DMatch
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch)
-&gt; (DMatch -&gt; Constr)
-&gt; (DMatch -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DMatch))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DMatch))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DMatch -&gt; DMatch)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch)
-&gt; Data DMatch
DMatch -&gt; DataType
DMatch -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DMatch -&gt; DMatch
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DMatch)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DMatch)
$cDMatch :: Constr
$tDMatch :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DMatch -&gt; DMatch
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DMatch -&gt; DMatch
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DMatch)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DMatch)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DMatch)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DMatch)
dataTypeOf :: DMatch -&gt; DataType
$cdataTypeOf :: DMatch -&gt; DataType
toConstr :: DMatch -&gt; Constr
$ctoConstr :: DMatch -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch
$cp1Data :: Typeable DMatch
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DMatch -&gt; Rep DMatch x)
-&gt; (forall x. Rep DMatch x -&gt; DMatch) -&gt; Generic DMatch
forall x. Rep DMatch x -&gt; DMatch
forall x. DMatch -&gt; Rep DMatch x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DMatch x -&gt; DMatch
$cfrom :: forall x. DMatch -&gt; Rep DMatch x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span class="hs-comment">-- | Corresponds to TH's @Clause@ type.</span><span>
</span><span id="line-75"></span><span id="local-6989586621679400668"><span id="local-6989586621679400669"></span></span><span class="hs-keyword">data</span><span> </span><span id="DClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-var">DClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-var">DClause</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400663"><span id="local-6989586621679400665"><span class="annot"><span class="annottext">DClause -&gt; DClause -&gt; Bool
(DClause -&gt; DClause -&gt; Bool)
-&gt; (DClause -&gt; DClause -&gt; Bool) -&gt; Eq DClause
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DClause -&gt; DClause -&gt; Bool
$c/= :: DClause -&gt; DClause -&gt; Bool
== :: DClause -&gt; DClause -&gt; Bool
$c== :: DClause -&gt; DClause -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400657"><span id="local-6989586621679400659"><span id="local-6989586621679400661"><span class="annot"><span class="annottext">Int -&gt; DClause -&gt; ShowS
[DClause] -&gt; ShowS
DClause -&gt; String
(Int -&gt; DClause -&gt; ShowS)
-&gt; (DClause -&gt; String) -&gt; ([DClause] -&gt; ShowS) -&gt; Show DClause
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DClause] -&gt; ShowS
$cshowList :: [DClause] -&gt; ShowS
show :: DClause -&gt; String
$cshow :: DClause -&gt; String
showsPrec :: Int -&gt; DClause -&gt; ShowS
$cshowsPrec :: Int -&gt; DClause -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDClause"><span id="%24tDClause"><span id="local-6989586621679400628"><span id="local-6989586621679400630"><span id="local-6989586621679400632"><span id="local-6989586621679400634"><span id="local-6989586621679400636"><span id="local-6989586621679400638"><span id="local-6989586621679400640"><span id="local-6989586621679400642"><span id="local-6989586621679400644"><span id="local-6989586621679400646"><span id="local-6989586621679400648"><span id="local-6989586621679400650"><span id="local-6989586621679400652"><span id="local-6989586621679400654"><span class="annot"><span class="annottext">Typeable DClause
DataType
Constr
Typeable DClause
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause)
-&gt; (DClause -&gt; Constr)
-&gt; (DClause -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DClause))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DClause))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DClause -&gt; DClause)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause)
-&gt; Data DClause
DClause -&gt; DataType
DClause -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DClause -&gt; DClause
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DClause)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DClause)
$cDClause :: Constr
$tDClause :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DClause -&gt; DClause
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DClause -&gt; DClause
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DClause)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DClause)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DClause)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DClause)
dataTypeOf :: DClause -&gt; DataType
$cdataTypeOf :: DClause -&gt; DataType
toConstr :: DClause -&gt; Constr
$ctoConstr :: DClause -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause
$cp1Data :: Typeable DClause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DClause -&gt; Rep DClause x)
-&gt; (forall x. Rep DClause x -&gt; DClause) -&gt; Generic DClause
forall x. Rep DClause x -&gt; DClause
forall x. DClause -&gt; Rep DClause x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DClause x -&gt; DClause
$cfrom :: forall x. DClause -&gt; Rep DClause x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="hs-comment">-- | Declarations as used in a @let@ statement.</span><span>
</span><span id="line-79"></span><span id="local-6989586621679400622"><span id="local-6989586621679400623"></span></span><span class="hs-keyword">data</span><span> </span><span id="DLetDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-var">DLetDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DFunD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFunD"><span class="hs-identifier hs-var">DFunD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-type">DClause</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-80"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DValD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DValD"><span class="hs-identifier hs-var">DValD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-81"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigD"><span class="hs-identifier hs-var">DSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-82"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DInfixD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInfixD"><span class="hs-identifier hs-var">DInfixD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-83"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DPragmaD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPragmaD"><span class="hs-identifier hs-var">DPragmaD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPragma"><span class="hs-identifier hs-type">DPragma</span></a></span><span>
</span><span id="line-84"></span><span>             </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400612"><span id="local-6989586621679400614"><span class="annot"><span class="annottext">DLetDec -&gt; DLetDec -&gt; Bool
(DLetDec -&gt; DLetDec -&gt; Bool)
-&gt; (DLetDec -&gt; DLetDec -&gt; Bool) -&gt; Eq DLetDec
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DLetDec -&gt; DLetDec -&gt; Bool
$c/= :: DLetDec -&gt; DLetDec -&gt; Bool
== :: DLetDec -&gt; DLetDec -&gt; Bool
$c== :: DLetDec -&gt; DLetDec -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400606"><span id="local-6989586621679400608"><span id="local-6989586621679400610"><span class="annot"><span class="annottext">Int -&gt; DLetDec -&gt; ShowS
[DLetDec] -&gt; ShowS
DLetDec -&gt; String
(Int -&gt; DLetDec -&gt; ShowS)
-&gt; (DLetDec -&gt; String) -&gt; ([DLetDec] -&gt; ShowS) -&gt; Show DLetDec
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DLetDec] -&gt; ShowS
$cshowList :: [DLetDec] -&gt; ShowS
show :: DLetDec -&gt; String
$cshow :: DLetDec -&gt; String
showsPrec :: Int -&gt; DLetDec -&gt; ShowS
$cshowsPrec :: Int -&gt; DLetDec -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDPragmaD"><span id="%24cDInfixD"><span id="%24cDSigD"><span id="%24cDValD"><span id="%24cDFunD"><span id="%24tDLetDec"><span id="local-6989586621679400577"><span id="local-6989586621679400579"><span id="local-6989586621679400581"><span id="local-6989586621679400583"><span id="local-6989586621679400585"><span id="local-6989586621679400587"><span id="local-6989586621679400589"><span id="local-6989586621679400591"><span id="local-6989586621679400593"><span id="local-6989586621679400595"><span id="local-6989586621679400597"><span id="local-6989586621679400599"><span id="local-6989586621679400601"><span id="local-6989586621679400603"><span class="annot"><span class="annottext">Typeable DLetDec
DataType
Constr
Typeable DLetDec
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec)
-&gt; (DLetDec -&gt; Constr)
-&gt; (DLetDec -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DLetDec))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DLetDec))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DLetDec -&gt; DLetDec)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec)
-&gt; Data DLetDec
DLetDec -&gt; DataType
DLetDec -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DLetDec -&gt; DLetDec
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DLetDec)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DLetDec)
$cDPragmaD :: Constr
$cDInfixD :: Constr
$cDSigD :: Constr
$cDValD :: Constr
$cDFunD :: Constr
$tDLetDec :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DLetDec -&gt; DLetDec
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DLetDec -&gt; DLetDec
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DLetDec)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DLetDec)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DLetDec)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DLetDec)
dataTypeOf :: DLetDec -&gt; DataType
$cdataTypeOf :: DLetDec -&gt; DataType
toConstr :: DLetDec -&gt; Constr
$ctoConstr :: DLetDec -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec
$cp1Data :: Typeable DLetDec
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DLetDec -&gt; Rep DLetDec x)
-&gt; (forall x. Rep DLetDec x -&gt; DLetDec) -&gt; Generic DLetDec
forall x. Rep DLetDec x -&gt; DLetDec
forall x. DLetDec -&gt; Rep DLetDec x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DLetDec x -&gt; DLetDec
$cfrom :: forall x. DLetDec -&gt; Rep DLetDec x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span class="hs-comment">-- | Is it a @newtype@ or a @data@ type?</span><span>
</span><span id="line-87"></span><span id="local-6989586621679400567"><span id="local-6989586621679400568"></span></span><span class="hs-keyword">data</span><span> </span><span id="NewOrData"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#NewOrData"><span class="hs-identifier hs-var">NewOrData</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Newtype"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a></span></span><span>
</span><span id="line-88"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="Data"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#Data"><span class="hs-identifier hs-var">Data</span></a></span></span><span>
</span><span id="line-89"></span><span>               </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400561"><span id="local-6989586621679400563"><span class="annot"><span class="annottext">NewOrData -&gt; NewOrData -&gt; Bool
(NewOrData -&gt; NewOrData -&gt; Bool)
-&gt; (NewOrData -&gt; NewOrData -&gt; Bool) -&gt; Eq NewOrData
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: NewOrData -&gt; NewOrData -&gt; Bool
$c/= :: NewOrData -&gt; NewOrData -&gt; Bool
== :: NewOrData -&gt; NewOrData -&gt; Bool
$c== :: NewOrData -&gt; NewOrData -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400555"><span id="local-6989586621679400557"><span id="local-6989586621679400559"><span class="annot"><span class="annottext">Int -&gt; NewOrData -&gt; ShowS
[NewOrData] -&gt; ShowS
NewOrData -&gt; String
(Int -&gt; NewOrData -&gt; ShowS)
-&gt; (NewOrData -&gt; String)
-&gt; ([NewOrData] -&gt; ShowS)
-&gt; Show NewOrData
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [NewOrData] -&gt; ShowS
$cshowList :: [NewOrData] -&gt; ShowS
show :: NewOrData -&gt; String
$cshow :: NewOrData -&gt; String
showsPrec :: Int -&gt; NewOrData -&gt; ShowS
$cshowsPrec :: Int -&gt; NewOrData -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cData"><span id="%24cNewtype"><span id="%24tNewOrData"><span id="local-6989586621679400526"><span id="local-6989586621679400528"><span id="local-6989586621679400530"><span id="local-6989586621679400532"><span id="local-6989586621679400534"><span id="local-6989586621679400536"><span id="local-6989586621679400538"><span id="local-6989586621679400540"><span id="local-6989586621679400542"><span id="local-6989586621679400544"><span id="local-6989586621679400546"><span id="local-6989586621679400548"><span id="local-6989586621679400550"><span id="local-6989586621679400552"><span class="annot"><span class="annottext">Typeable NewOrData
DataType
Constr
Typeable NewOrData
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData)
-&gt; (NewOrData -&gt; Constr)
-&gt; (NewOrData -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData)
-&gt; Data NewOrData
NewOrData -&gt; DataType
NewOrData -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
$cData :: Constr
$cNewtype :: Constr
$tNewOrData :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
dataTypeOf :: NewOrData -&gt; DataType
$cdataTypeOf :: NewOrData -&gt; DataType
toConstr :: NewOrData -&gt; Constr
$ctoConstr :: NewOrData -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
$cp1Data :: Typeable NewOrData
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. NewOrData -&gt; Rep NewOrData x)
-&gt; (forall x. Rep NewOrData x -&gt; NewOrData) -&gt; Generic NewOrData
forall x. Rep NewOrData x -&gt; NewOrData
forall x. NewOrData -&gt; Rep NewOrData x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep NewOrData x -&gt; NewOrData
$cfrom :: forall x. NewOrData -&gt; Rep NewOrData x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="hs-comment">-- | Corresponds to TH's @Dec@ type.</span><span>
</span><span id="line-92"></span><span id="local-6989586621679400519"><span id="local-6989586621679400520"></span></span><span class="hs-keyword">data</span><span> </span><span id="DDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-var">DDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DLetDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-var">DLetDec</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span>
</span><span id="line-93"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDataD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDataD"><span class="hs-identifier hs-var">DDataD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#NewOrData"><span class="hs-identifier hs-type">NewOrData</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-type">DDerivClause</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-94"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DTySynD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynD"><span class="hs-identifier hs-var">DTySynD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-95"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DClassD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClassD"><span class="hs-identifier hs-var">DClassD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">FunDep</span></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-96"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DInstanceD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInstanceD"><span class="hs-identifier hs-var">DInstanceD</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Overlap</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-97"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DForeignD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForeignD"><span class="hs-identifier hs-var">DForeignD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForeign"><span class="hs-identifier hs-type">DForeign</span></a></span><span>
</span><span id="line-98"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DOpenTypeFamilyD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DOpenTypeFamilyD"><span class="hs-identifier hs-var">DOpenTypeFamilyD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-type">DTypeFamilyHead</span></a></span><span>
</span><span id="line-99"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DClosedTypeFamilyD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClosedTypeFamilyD"><span class="hs-identifier hs-var">DClosedTypeFamilyD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-type">DTypeFamilyHead</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-type">DTySynEqn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-100"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDataFamilyD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDataFamilyD"><span class="hs-identifier hs-var">DDataFamilyD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-101"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDataInstD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDataInstD"><span class="hs-identifier hs-var">DDataInstD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#NewOrData"><span class="hs-identifier hs-type">NewOrData</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span>                       </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-type">DDerivClause</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-103"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DTySynInstD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynInstD"><span class="hs-identifier hs-var">DTySynInstD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-type">DTySynEqn</span></a></span><span>
</span><span id="line-104"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DRoleAnnotD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRoleAnnotD"><span class="hs-identifier hs-var">DRoleAnnotD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Role</span></span><span class="hs-special">]</span><span>
</span><span id="line-105"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DStandaloneDerivD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DStandaloneDerivD"><span class="hs-identifier hs-var">DStandaloneDerivD</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivStrategy"><span class="hs-identifier hs-type">DDerivStrategy</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-106"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDefaultSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDefaultSigD"><span class="hs-identifier hs-var">DDefaultSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-107"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DPatSynD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynD"><span class="hs-identifier hs-var">DPatSynD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">PatSynArgs</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynDir"><span class="hs-identifier hs-type">DPatSynDir</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span>
</span><span id="line-108"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DPatSynSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynSigD"><span class="hs-identifier hs-var">DPatSynSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynType"><span class="hs-identifier hs-type">DPatSynType</span></a></span><span>
</span><span id="line-109"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DKiSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKiSigD"><span class="hs-identifier hs-var">DKiSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-110"></span><span>              </span><span class="hs-comment">-- DKiSigD is part of DDec, not DLetDec, because standalone kind</span><span>
</span><span id="line-111"></span><span>              </span><span class="hs-comment">-- signatures can only appear on the top level.</span><span>
</span><span id="line-112"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400495"><span id="local-6989586621679400497"><span class="annot"><span class="annottext">DDec -&gt; DDec -&gt; Bool
(DDec -&gt; DDec -&gt; Bool) -&gt; (DDec -&gt; DDec -&gt; Bool) -&gt; Eq DDec
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DDec -&gt; DDec -&gt; Bool
$c/= :: DDec -&gt; DDec -&gt; Bool
== :: DDec -&gt; DDec -&gt; Bool
$c== :: DDec -&gt; DDec -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400489"><span id="local-6989586621679400491"><span id="local-6989586621679400493"><span class="annot"><span class="annottext">Int -&gt; DDec -&gt; ShowS
[DDec] -&gt; ShowS
DDec -&gt; String
(Int -&gt; DDec -&gt; ShowS)
-&gt; (DDec -&gt; String) -&gt; ([DDec] -&gt; ShowS) -&gt; Show DDec
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DDec] -&gt; ShowS
$cshowList :: [DDec] -&gt; ShowS
show :: DDec -&gt; String
$cshow :: DDec -&gt; String
showsPrec :: Int -&gt; DDec -&gt; ShowS
$cshowsPrec :: Int -&gt; DDec -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDKiSigD"><span id="%24cDPatSynSigD"><span id="%24cDPatSynD"><span id="%24cDDefaultSigD"><span id="%24cDStandaloneDerivD"><span id="%24cDRoleAnnotD"><span id="%24cDTySynInstD"><span id="%24cDDataInstD"><span id="%24cDDataFamilyD"><span id="%24cDClosedTypeFamilyD"><span id="%24cDOpenTypeFamilyD"><span id="%24cDForeignD"><span id="%24cDInstanceD"><span id="%24cDClassD"><span id="%24cDTySynD"><span id="%24cDDataD"><span id="%24cDLetDec"><span id="%24tDDec"><span id="local-6989586621679400460"><span id="local-6989586621679400462"><span id="local-6989586621679400464"><span id="local-6989586621679400466"><span id="local-6989586621679400468"><span id="local-6989586621679400470"><span id="local-6989586621679400472"><span id="local-6989586621679400474"><span id="local-6989586621679400476"><span id="local-6989586621679400478"><span id="local-6989586621679400480"><span id="local-6989586621679400482"><span id="local-6989586621679400484"><span id="local-6989586621679400486"><span class="annot"><span class="annottext">Typeable DDec
DataType
Constr
Typeable DDec
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec)
-&gt; (DDec -&gt; Constr)
-&gt; (DDec -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDec))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DDec))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DDec -&gt; DDec)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec)
-&gt; Data DDec
DDec -&gt; DataType
DDec -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DDec -&gt; DDec
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDec)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DDec)
$cDKiSigD :: Constr
$cDPatSynSigD :: Constr
$cDPatSynD :: Constr
$cDDefaultSigD :: Constr
$cDStandaloneDerivD :: Constr
$cDRoleAnnotD :: Constr
$cDTySynInstD :: Constr
$cDDataInstD :: Constr
$cDDataFamilyD :: Constr
$cDClosedTypeFamilyD :: Constr
$cDOpenTypeFamilyD :: Constr
$cDForeignD :: Constr
$cDInstanceD :: Constr
$cDClassD :: Constr
$cDTySynD :: Constr
$cDDataD :: Constr
$cDLetDec :: Constr
$tDDec :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDec -&gt; DDec
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDec -&gt; DDec
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DDec)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DDec)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDec)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDec)
dataTypeOf :: DDec -&gt; DataType
$cdataTypeOf :: DDec -&gt; DataType
toConstr :: DDec -&gt; Constr
$ctoConstr :: DDec -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec
$cp1Data :: Typeable DDec
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DDec -&gt; Rep DDec x)
-&gt; (forall x. Rep DDec x -&gt; DDec) -&gt; Generic DDec
forall x. Rep DDec x -&gt; DDec
forall x. DDec -&gt; Rep DDec x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DDec x -&gt; DDec
$cfrom :: forall x. DDec -&gt; Rep DDec x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt; 711
</span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">Overlap</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Overlappable</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">Overlapping</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">Overlaps</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">Incoherent</span><span>
</span><span id="line-116"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- | Corresponds to TH's 'PatSynDir' type</span><span>
</span><span id="line-120"></span><span id="local-6989586621679400438"><span id="local-6989586621679400439"></span></span><span class="hs-keyword">data</span><span> </span><span id="DPatSynDir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynDir"><span class="hs-identifier hs-var">DPatSynDir</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DUnidir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DUnidir"><span class="hs-identifier hs-var">DUnidir</span></a></span></span><span>              </span><span class="hs-comment">-- ^ @pattern P x {&lt;-} p@</span><span>
</span><span id="line-121"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="DImplBidir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DImplBidir"><span class="hs-identifier hs-var">DImplBidir</span></a></span></span><span>           </span><span class="hs-comment">-- ^ @pattern P x {=} p@</span><span>
</span><span id="line-122"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="DExplBidir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExplBidir"><span class="hs-identifier hs-var">DExplBidir</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-type">DClause</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ @pattern P x {&lt;-} p where P x = e@</span><span>
</span><span id="line-123"></span><span>                </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400431"><span id="local-6989586621679400433"><span class="annot"><span class="annottext">DPatSynDir -&gt; DPatSynDir -&gt; Bool
(DPatSynDir -&gt; DPatSynDir -&gt; Bool)
-&gt; (DPatSynDir -&gt; DPatSynDir -&gt; Bool) -&gt; Eq DPatSynDir
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
$c/= :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
== :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
$c== :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400425"><span id="local-6989586621679400427"><span id="local-6989586621679400429"><span class="annot"><span class="annottext">Int -&gt; DPatSynDir -&gt; ShowS
[DPatSynDir] -&gt; ShowS
DPatSynDir -&gt; String
(Int -&gt; DPatSynDir -&gt; ShowS)
-&gt; (DPatSynDir -&gt; String)
-&gt; ([DPatSynDir] -&gt; ShowS)
-&gt; Show DPatSynDir
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DPatSynDir] -&gt; ShowS
$cshowList :: [DPatSynDir] -&gt; ShowS
show :: DPatSynDir -&gt; String
$cshow :: DPatSynDir -&gt; String
showsPrec :: Int -&gt; DPatSynDir -&gt; ShowS
$cshowsPrec :: Int -&gt; DPatSynDir -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDExplBidir"><span id="%24cDImplBidir"><span id="%24cDUnidir"><span id="%24tDPatSynDir"><span id="local-6989586621679400396"><span id="local-6989586621679400398"><span id="local-6989586621679400400"><span id="local-6989586621679400402"><span id="local-6989586621679400404"><span id="local-6989586621679400406"><span id="local-6989586621679400408"><span id="local-6989586621679400410"><span id="local-6989586621679400412"><span id="local-6989586621679400414"><span id="local-6989586621679400416"><span id="local-6989586621679400418"><span id="local-6989586621679400420"><span id="local-6989586621679400422"><span class="annot"><span class="annottext">Typeable DPatSynDir
DataType
Constr
Typeable DPatSynDir
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir)
-&gt; (DPatSynDir -&gt; Constr)
-&gt; (DPatSynDir -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPatSynDir))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DPatSynDir))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DPatSynDir -&gt; DPatSynDir)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir)
-&gt; Data DPatSynDir
DPatSynDir -&gt; DataType
DPatSynDir -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DPatSynDir -&gt; DPatSynDir
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPatSynDir)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPatSynDir)
$cDExplBidir :: Constr
$cDImplBidir :: Constr
$cDUnidir :: Constr
$tDPatSynDir :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPatSynDir -&gt; DPatSynDir
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPatSynDir -&gt; DPatSynDir
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPatSynDir)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPatSynDir)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPatSynDir)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPatSynDir)
dataTypeOf :: DPatSynDir -&gt; DataType
$cdataTypeOf :: DPatSynDir -&gt; DataType
toConstr :: DPatSynDir -&gt; Constr
$ctoConstr :: DPatSynDir -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir
$cp1Data :: Typeable DPatSynDir
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DPatSynDir -&gt; Rep DPatSynDir x)
-&gt; (forall x. Rep DPatSynDir x -&gt; DPatSynDir) -&gt; Generic DPatSynDir
forall x. Rep DPatSynDir x -&gt; DPatSynDir
forall x. DPatSynDir -&gt; Rep DPatSynDir x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DPatSynDir x -&gt; DPatSynDir
$cfrom :: forall x. DPatSynDir -&gt; Rep DPatSynDir x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span class="hs-comment">-- | Corresponds to TH's 'PatSynType' type</span><span>
</span><span id="line-126"></span><span class="hs-keyword">type</span><span> </span><span id="DPatSynType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynType"><span class="hs-identifier hs-var">DPatSynType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt; 801
</span><span class="hs-comment">-- | Same as @PatSynArgs@ from TH; defined here for backwards compatibility.</span><span>
</span><span id="line-130"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">PatSynArgs</span><span>
</span><span id="line-131"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">PrefixPatSyn</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Name</span><span class="hs-special">]</span><span>        </span><span class="hs-comment">-- ^ @pattern P {x y z} = p@</span><span>
</span><span id="line-132"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">InfixPatSyn</span><span> </span><span class="hs-identifier">Name</span><span> </span><span class="hs-identifier">Name</span><span>      </span><span class="hs-comment">-- ^ @pattern {x P y} = p@</span><span>
</span><span id="line-133"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">RecordPatSyn</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Name</span><span class="hs-special">]</span><span>        </span><span class="hs-comment">-- ^ @pattern P { {x,y,z} } = p@</span><span>
</span><span id="line-134"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- | Corresponds to TH's 'TypeFamilyHead' type</span><span>
</span><span id="line-138"></span><span id="local-6989586621679400388"><span id="local-6989586621679400389"></span></span><span class="hs-keyword">data</span><span> </span><span id="DTypeFamilyHead"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-var">DTypeFamilyHead</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DTypeFamilyHead"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-var">DTypeFamilyHead</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFamilyResultSig"><span class="hs-identifier hs-type">DFamilyResultSig</span></a></span><span>
</span><span id="line-139"></span><span>                                       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InjectivityAnn</span></span><span class="hs-special">)</span><span>
</span><span id="line-140"></span><span>                     </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400383"><span id="local-6989586621679400385"><span class="annot"><span class="annottext">DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
(DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool)
-&gt; (DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool)
-&gt; Eq DTypeFamilyHead
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
$c/= :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
== :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
$c== :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400377"><span id="local-6989586621679400379"><span id="local-6989586621679400381"><span class="annot"><span class="annottext">Int -&gt; DTypeFamilyHead -&gt; ShowS
[DTypeFamilyHead] -&gt; ShowS
DTypeFamilyHead -&gt; String
(Int -&gt; DTypeFamilyHead -&gt; ShowS)
-&gt; (DTypeFamilyHead -&gt; String)
-&gt; ([DTypeFamilyHead] -&gt; ShowS)
-&gt; Show DTypeFamilyHead
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DTypeFamilyHead] -&gt; ShowS
$cshowList :: [DTypeFamilyHead] -&gt; ShowS
show :: DTypeFamilyHead -&gt; String
$cshow :: DTypeFamilyHead -&gt; String
showsPrec :: Int -&gt; DTypeFamilyHead -&gt; ShowS
$cshowsPrec :: Int -&gt; DTypeFamilyHead -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDTypeFamilyHead"><span id="%24tDTypeFamilyHead"><span id="local-6989586621679400348"><span id="local-6989586621679400350"><span id="local-6989586621679400352"><span id="local-6989586621679400354"><span id="local-6989586621679400356"><span id="local-6989586621679400358"><span id="local-6989586621679400360"><span id="local-6989586621679400362"><span id="local-6989586621679400364"><span id="local-6989586621679400366"><span id="local-6989586621679400368"><span id="local-6989586621679400370"><span id="local-6989586621679400372"><span id="local-6989586621679400374"><span class="annot"><span class="annottext">Typeable DTypeFamilyHead
DataType
Constr
Typeable DTypeFamilyHead
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead)
-&gt; (DTypeFamilyHead -&gt; Constr)
-&gt; (DTypeFamilyHead -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTypeFamilyHead))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DTypeFamilyHead))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; DTypeFamilyHead -&gt; DTypeFamilyHead)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead)
-&gt; Data DTypeFamilyHead
DTypeFamilyHead -&gt; DataType
DTypeFamilyHead -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DTypeFamilyHead -&gt; DTypeFamilyHead
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTypeFamilyHead)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DTypeFamilyHead)
$cDTypeFamilyHead :: Constr
$tDTypeFamilyHead :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTypeFamilyHead -&gt; DTypeFamilyHead
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTypeFamilyHead -&gt; DTypeFamilyHead
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DTypeFamilyHead)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DTypeFamilyHead)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTypeFamilyHead)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTypeFamilyHead)
dataTypeOf :: DTypeFamilyHead -&gt; DataType
$cdataTypeOf :: DTypeFamilyHead -&gt; DataType
toConstr :: DTypeFamilyHead -&gt; Constr
$ctoConstr :: DTypeFamilyHead -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead
$cp1Data :: Typeable DTypeFamilyHead
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DTypeFamilyHead -&gt; Rep DTypeFamilyHead x)
-&gt; (forall x. Rep DTypeFamilyHead x -&gt; DTypeFamilyHead)
-&gt; Generic DTypeFamilyHead
forall x. Rep DTypeFamilyHead x -&gt; DTypeFamilyHead
forall x. DTypeFamilyHead -&gt; Rep DTypeFamilyHead x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DTypeFamilyHead x -&gt; DTypeFamilyHead
$cfrom :: forall x. DTypeFamilyHead -&gt; Rep DTypeFamilyHead x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-comment">-- | Corresponds to TH's 'FamilyResultSig' type</span><span>
</span><span id="line-143"></span><span id="local-6989586621679400342"><span id="local-6989586621679400343"></span></span><span class="hs-keyword">data</span><span> </span><span id="DFamilyResultSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFamilyResultSig"><span class="hs-identifier hs-var">DFamilyResultSig</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DNoSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DNoSig"><span class="hs-identifier hs-var">DNoSig</span></a></span></span><span>
</span><span id="line-144"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span id="DKindSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKindSig"><span class="hs-identifier hs-var">DKindSig</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-145"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span id="DTyVarSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarSig"><span class="hs-identifier hs-var">DTyVarSig</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span>
</span><span id="line-146"></span><span>                      </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400335"><span id="local-6989586621679400337"><span class="annot"><span class="annottext">DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
(DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool)
-&gt; (DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool)
-&gt; Eq DFamilyResultSig
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
$c/= :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
== :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
$c== :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400329"><span id="local-6989586621679400331"><span id="local-6989586621679400333"><span class="annot"><span class="annottext">Int -&gt; DFamilyResultSig -&gt; ShowS
[DFamilyResultSig] -&gt; ShowS
DFamilyResultSig -&gt; String
(Int -&gt; DFamilyResultSig -&gt; ShowS)
-&gt; (DFamilyResultSig -&gt; String)
-&gt; ([DFamilyResultSig] -&gt; ShowS)
-&gt; Show DFamilyResultSig
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DFamilyResultSig] -&gt; ShowS
$cshowList :: [DFamilyResultSig] -&gt; ShowS
show :: DFamilyResultSig -&gt; String
$cshow :: DFamilyResultSig -&gt; String
showsPrec :: Int -&gt; DFamilyResultSig -&gt; ShowS
$cshowsPrec :: Int -&gt; DFamilyResultSig -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDTyVarSig"><span id="%24cDKindSig"><span id="%24cDNoSig"><span id="%24tDFamilyResultSig"><span id="local-6989586621679400300"><span id="local-6989586621679400302"><span id="local-6989586621679400304"><span id="local-6989586621679400306"><span id="local-6989586621679400308"><span id="local-6989586621679400310"><span id="local-6989586621679400312"><span id="local-6989586621679400314"><span id="local-6989586621679400316"><span id="local-6989586621679400318"><span id="local-6989586621679400320"><span id="local-6989586621679400322"><span id="local-6989586621679400324"><span id="local-6989586621679400326"><span class="annot"><span class="annottext">Typeable DFamilyResultSig
DataType
Constr
Typeable DFamilyResultSig
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig)
-&gt; (DFamilyResultSig -&gt; Constr)
-&gt; (DFamilyResultSig -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DFamilyResultSig))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DFamilyResultSig))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; DFamilyResultSig -&gt; DFamilyResultSig)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DFamilyResultSig -&gt; m DFamilyResultSig)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DFamilyResultSig -&gt; m DFamilyResultSig)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DFamilyResultSig -&gt; m DFamilyResultSig)
-&gt; Data DFamilyResultSig
DFamilyResultSig -&gt; DataType
DFamilyResultSig -&gt; Constr
(forall b. Data b =&gt; b -&gt; b)
-&gt; DFamilyResultSig -&gt; DFamilyResultSig
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DFamilyResultSig)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DFamilyResultSig)
$cDTyVarSig :: Constr
$cDKindSig :: Constr
$cDNoSig :: Constr
$tDFamilyResultSig :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DFamilyResultSig -&gt; DFamilyResultSig
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DFamilyResultSig -&gt; DFamilyResultSig
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DFamilyResultSig)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DFamilyResultSig)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DFamilyResultSig)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DFamilyResultSig)
dataTypeOf :: DFamilyResultSig -&gt; DataType
$cdataTypeOf :: DFamilyResultSig -&gt; DataType
toConstr :: DFamilyResultSig -&gt; Constr
$ctoConstr :: DFamilyResultSig -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig
$cp1Data :: Typeable DFamilyResultSig
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DFamilyResultSig -&gt; Rep DFamilyResultSig x)
-&gt; (forall x. Rep DFamilyResultSig x -&gt; DFamilyResultSig)
-&gt; Generic DFamilyResultSig
forall x. Rep DFamilyResultSig x -&gt; DFamilyResultSig
forall x. DFamilyResultSig -&gt; Rep DFamilyResultSig x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DFamilyResultSig x -&gt; DFamilyResultSig
$cfrom :: forall x. DFamilyResultSig -&gt; Rep DFamilyResultSig x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt;= 710
</span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">InjectivityAnn</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">InjectivityAnn</span><span> </span><span class="hs-identifier">Name</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Name</span><span class="hs-special">]</span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- | Corresponds to TH's 'Con' type. Unlike 'Con', all 'DCon's reflect GADT</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- syntax. This is beneficial for @th-desugar@'s since it means</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- that all data type declarations can support explicit return kinds, so</span><span>
</span><span id="line-156"></span><span class="hs-comment">-- one does not need to represent them with something like @'Maybe' 'DKind'@,</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- since Haskell98-style data declaration syntax isn't used. Accordingly,</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- there are some differences between 'DCon' and 'Con' to keep in mind:</span><span>
</span><span id="line-159"></span><span class="hs-comment">--</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- * Unlike 'ForallC', where the meaning of the 'TyVarBndr's changes depending</span><span>
</span><span id="line-161"></span><span class="hs-comment">--   on whether it's followed by 'GadtC'/'RecGadtC' or not, the meaning of the</span><span>
</span><span id="line-162"></span><span class="hs-comment">--   'DTyVarBndr's in a 'DCon' is always the same: it is the list of</span><span>
</span><span id="line-163"></span><span class="hs-comment">--   universally /and/ existentially quantified type variables. Note that it is</span><span>
</span><span id="line-164"></span><span class="hs-comment">--   not guaranteed that one set of type variables will appear before the</span><span>
</span><span id="line-165"></span><span class="hs-comment">--   other.</span><span>
</span><span id="line-166"></span><span class="hs-comment">--</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- * A 'DCon' always has an explicit return type.</span><span>
</span><span id="line-168"></span><span id="local-6989586621679400292"><span id="local-6989586621679400293"></span></span><span class="hs-keyword">data</span><span> </span><span id="DCon"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-var">DCon</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DCon"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-var">DCon</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConFields"><span class="hs-identifier hs-type">DConFields</span></a></span><span>
</span><span id="line-169"></span><span>                 </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>  </span><span class="hs-comment">-- ^ The GADT result type</span><span>
</span><span id="line-170"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400287"><span id="local-6989586621679400289"><span class="annot"><span class="annottext">DCon -&gt; DCon -&gt; Bool
(DCon -&gt; DCon -&gt; Bool) -&gt; (DCon -&gt; DCon -&gt; Bool) -&gt; Eq DCon
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DCon -&gt; DCon -&gt; Bool
$c/= :: DCon -&gt; DCon -&gt; Bool
== :: DCon -&gt; DCon -&gt; Bool
$c== :: DCon -&gt; DCon -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400281"><span id="local-6989586621679400283"><span id="local-6989586621679400285"><span class="annot"><span class="annottext">Int -&gt; DCon -&gt; ShowS
[DCon] -&gt; ShowS
DCon -&gt; String
(Int -&gt; DCon -&gt; ShowS)
-&gt; (DCon -&gt; String) -&gt; ([DCon] -&gt; ShowS) -&gt; Show DCon
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DCon] -&gt; ShowS
$cshowList :: [DCon] -&gt; ShowS
show :: DCon -&gt; String
$cshow :: DCon -&gt; String
showsPrec :: Int -&gt; DCon -&gt; ShowS
$cshowsPrec :: Int -&gt; DCon -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDCon"><span id="%24tDCon"><span id="local-6989586621679400252"><span id="local-6989586621679400254"><span id="local-6989586621679400256"><span id="local-6989586621679400258"><span id="local-6989586621679400260"><span id="local-6989586621679400262"><span id="local-6989586621679400264"><span id="local-6989586621679400266"><span id="local-6989586621679400268"><span id="local-6989586621679400270"><span id="local-6989586621679400272"><span id="local-6989586621679400274"><span id="local-6989586621679400276"><span id="local-6989586621679400278"><span class="annot"><span class="annottext">Typeable DCon
DataType
Constr
Typeable DCon
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon)
-&gt; (DCon -&gt; Constr)
-&gt; (DCon -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DCon))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DCon))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DCon -&gt; DCon)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon)
-&gt; Data DCon
DCon -&gt; DataType
DCon -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DCon -&gt; DCon
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DCon)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DCon)
$cDCon :: Constr
$tDCon :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DCon -&gt; DCon
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DCon -&gt; DCon
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DCon)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DCon)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DCon)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DCon)
dataTypeOf :: DCon -&gt; DataType
$cdataTypeOf :: DCon -&gt; DataType
toConstr :: DCon -&gt; Constr
$ctoConstr :: DCon -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon
$cp1Data :: Typeable DCon
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DCon -&gt; Rep DCon x)
-&gt; (forall x. Rep DCon x -&gt; DCon) -&gt; Generic DCon
forall x. Rep DCon x -&gt; DCon
forall x. DCon -&gt; Rep DCon x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DCon x -&gt; DCon
$cfrom :: forall x. DCon -&gt; Rep DCon x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-171"></span><span>
</span><span id="line-172"></span><span class="hs-comment">-- | A list of fields either for a standard data constructor or a record</span><span>
</span><span id="line-173"></span><span class="hs-comment">-- data constructor.</span><span>
</span><span id="line-174"></span><span id="local-6989586621679400246"><span id="local-6989586621679400247"></span></span><span class="hs-keyword">data</span><span> </span><span id="DConFields"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConFields"><span class="hs-identifier hs-var">DConFields</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DNormalC"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DNormalC"><span class="hs-identifier hs-var">DNormalC</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDeclaredInfix"><span class="hs-identifier hs-type">DDeclaredInfix</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangType"><span class="hs-identifier hs-type">DBangType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-175"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="DRecC"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRecC"><span class="hs-identifier hs-var">DRecC</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarBangType"><span class="hs-identifier hs-type">DVarBangType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-176"></span><span>                </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400237"><span id="local-6989586621679400239"><span class="annot"><span class="annottext">DConFields -&gt; DConFields -&gt; Bool
(DConFields -&gt; DConFields -&gt; Bool)
-&gt; (DConFields -&gt; DConFields -&gt; Bool) -&gt; Eq DConFields
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DConFields -&gt; DConFields -&gt; Bool
$c/= :: DConFields -&gt; DConFields -&gt; Bool
== :: DConFields -&gt; DConFields -&gt; Bool
$c== :: DConFields -&gt; DConFields -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400231"><span id="local-6989586621679400233"><span id="local-6989586621679400235"><span class="annot"><span class="annottext">Int -&gt; DConFields -&gt; ShowS
[DConFields] -&gt; ShowS
DConFields -&gt; String
(Int -&gt; DConFields -&gt; ShowS)
-&gt; (DConFields -&gt; String)
-&gt; ([DConFields] -&gt; ShowS)
-&gt; Show DConFields
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DConFields] -&gt; ShowS
$cshowList :: [DConFields] -&gt; ShowS
show :: DConFields -&gt; String
$cshow :: DConFields -&gt; String
showsPrec :: Int -&gt; DConFields -&gt; ShowS
$cshowsPrec :: Int -&gt; DConFields -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDRecC"><span id="%24cDNormalC"><span id="%24tDConFields"><span id="local-6989586621679400202"><span id="local-6989586621679400204"><span id="local-6989586621679400206"><span id="local-6989586621679400208"><span id="local-6989586621679400210"><span id="local-6989586621679400212"><span id="local-6989586621679400214"><span id="local-6989586621679400216"><span id="local-6989586621679400218"><span id="local-6989586621679400220"><span id="local-6989586621679400222"><span id="local-6989586621679400224"><span id="local-6989586621679400226"><span id="local-6989586621679400228"><span class="annot"><span class="annottext">Typeable DConFields
DataType
Constr
Typeable DConFields
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields)
-&gt; (DConFields -&gt; Constr)
-&gt; (DConFields -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DConFields))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DConFields))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DConFields -&gt; DConFields)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields)
-&gt; Data DConFields
DConFields -&gt; DataType
DConFields -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DConFields -&gt; DConFields
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DConFields)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DConFields)
$cDRecC :: Constr
$cDNormalC :: Constr
$tDConFields :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DConFields -&gt; DConFields
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DConFields -&gt; DConFields
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DConFields)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DConFields)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DConFields)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DConFields)
dataTypeOf :: DConFields -&gt; DataType
$cdataTypeOf :: DConFields -&gt; DataType
toConstr :: DConFields -&gt; Constr
$ctoConstr :: DConFields -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields
$cp1Data :: Typeable DConFields
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DConFields -&gt; Rep DConFields x)
-&gt; (forall x. Rep DConFields x -&gt; DConFields) -&gt; Generic DConFields
forall x. Rep DConFields x -&gt; DConFields
forall x. DConFields -&gt; Rep DConFields x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DConFields x -&gt; DConFields
$cfrom :: forall x. DConFields -&gt; Rep DConFields x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="hs-comment">-- | 'True' if a constructor is declared infix. For normal ADTs, this means</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- that is was written in infix style. For example, both of the constructors</span><span>
</span><span id="line-180"></span><span class="hs-comment">-- below are declared infix.</span><span>
</span><span id="line-181"></span><span class="hs-comment">--</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- data Infix = Int `Infix` Int | Int :*: Int</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-185"></span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- Whereas neither of these constructors are declared infix:</span><span>
</span><span id="line-187"></span><span class="hs-comment">--</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- data Prefix = Prefix Int Int | (:+:) Int Int</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-191"></span><span class="hs-comment">--</span><span>
</span><span id="line-192"></span><span class="hs-comment">-- For GADTs, detecting whether a constructor is declared infix is a bit</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- trickier, as one cannot write a GADT constructor &quot;infix-style&quot; like one</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- can for normal ADT constructors. GHC considers a GADT constructor to be</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- declared infix if it meets the following three criteria:</span><span>
</span><span id="line-196"></span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- 1. Its name uses operator syntax (e.g., @(:*:)@).</span><span>
</span><span id="line-198"></span><span class="hs-comment">-- 2. It has exactly two fields (without record syntax).</span><span>
</span><span id="line-199"></span><span class="hs-comment">-- 3. It has a programmer-specified fixity declaration.</span><span>
</span><span id="line-200"></span><span class="hs-comment">--</span><span>
</span><span id="line-201"></span><span class="hs-comment">-- For example, in the following GADT:</span><span>
</span><span id="line-202"></span><span class="hs-comment">--</span><span>
</span><span id="line-203"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-204"></span><span class="hs-comment">-- infixl 5 :**:, :&amp;&amp;:, :^^:, `ActuallyPrefix`</span><span>
</span><span id="line-205"></span><span class="hs-comment">-- data InfixGADT a where</span><span>
</span><span id="line-206"></span><span class="hs-comment">--   (:**:) :: Int -&gt; b -&gt; InfixGADT (Maybe b) -- Only this one is infix</span><span>
</span><span id="line-207"></span><span class="hs-comment">--   ActuallyPrefix :: Char -&gt; Bool -&gt; InfixGADT Double</span><span>
</span><span id="line-208"></span><span class="hs-comment">--   (:&amp;&amp;:) :: { infixGADT1 :: b, infixGADT2 :: Int } -&gt; InfixGADT [b]</span><span>
</span><span id="line-209"></span><span class="hs-comment">--   (:^^:) :: Int -&gt; Int -&gt; Int -&gt; InfixGADT Int</span><span>
</span><span id="line-210"></span><span class="hs-comment">--   (:!!:) :: Char -&gt; Char -&gt; InfixGADT Char</span><span>
</span><span id="line-211"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-212"></span><span class="hs-comment">--</span><span>
</span><span id="line-213"></span><span class="hs-comment">-- Only the @(:**:)@ constructor is declared infix. The other constructors</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- are not declared infix, because:</span><span>
</span><span id="line-215"></span><span class="hs-comment">--</span><span>
</span><span id="line-216"></span><span class="hs-comment">-- * @ActuallyPrefix@ does not use operator syntax (criterion 1).</span><span>
</span><span id="line-217"></span><span class="hs-comment">-- * @(:&amp;&amp;:)@ uses record syntax (criterion 2).</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- * @(:^^:)@ does not have exactly two fields (criterion 2).</span><span>
</span><span id="line-219"></span><span class="hs-comment">-- * @(:!!:)@ does not have a programmer-specified fixity declaration (criterion 3).</span><span>
</span><span id="line-220"></span><span class="hs-keyword">type</span><span> </span><span id="DDeclaredInfix"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDeclaredInfix"><span class="hs-identifier hs-var">DDeclaredInfix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span class="hs-comment">-- | Corresponds to TH's @BangType@ type.</span><span>
</span><span id="line-223"></span><span class="hs-keyword">type</span><span> </span><span id="DBangType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangType"><span class="hs-identifier hs-var">DBangType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-224"></span><span>
</span><span id="line-225"></span><span class="hs-comment">-- | Corresponds to TH's @VarBangType@ type.</span><span>
</span><span id="line-226"></span><span class="hs-keyword">type</span><span> </span><span id="DVarBangType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarBangType"><span class="hs-identifier hs-var">DVarBangType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span class="hs-special">)</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt;= 710
</span><span class="hs-comment">-- | Corresponds to TH's definition</span><span>
</span><span id="line-230"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">SourceUnpackedness</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">NoSourceUnpackedness</span><span>
</span><span id="line-231"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceNoUnpack</span><span>
</span><span id="line-232"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceUnpack</span><span>
</span><span id="line-233"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span class="hs-comment">-- | Corresponds to TH's definition</span><span>
</span><span id="line-236"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">SourceStrictness</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">NoSourceStrictness</span><span>
</span><span id="line-237"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceLazy</span><span>
</span><span id="line-238"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceStrict</span><span>
</span><span id="line-239"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span class="hs-comment">-- | Corresponds to TH's definition</span><span>
</span><span id="line-242"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">Bang</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Bang</span><span> </span><span class="hs-identifier">SourceUnpackedness</span><span> </span><span class="hs-identifier">SourceStrictness</span><span>
</span><span id="line-243"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-246"></span><span class="hs-comment">-- | Corresponds to TH's @Foreign@ type.</span><span>
</span><span id="line-247"></span><span id="local-6989586621679400194"><span id="local-6989586621679400195"></span></span><span class="hs-keyword">data</span><span> </span><span id="DForeign"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForeign"><span class="hs-identifier hs-var">DForeign</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DImportF"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DImportF"><span class="hs-identifier hs-var">DImportF</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Callconv</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Safety</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-248"></span><span>              </span><span class="hs-glyph">|</span><span> </span><span id="DExportF"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExportF"><span class="hs-identifier hs-var">DExportF</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Callconv</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-249"></span><span>              </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400186"><span id="local-6989586621679400188"><span class="annot"><span class="annottext">DForeign -&gt; DForeign -&gt; Bool
(DForeign -&gt; DForeign -&gt; Bool)
-&gt; (DForeign -&gt; DForeign -&gt; Bool) -&gt; Eq DForeign
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DForeign -&gt; DForeign -&gt; Bool
$c/= :: DForeign -&gt; DForeign -&gt; Bool
== :: DForeign -&gt; DForeign -&gt; Bool
$c== :: DForeign -&gt; DForeign -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400180"><span id="local-6989586621679400182"><span id="local-6989586621679400184"><span class="annot"><span class="annottext">Int -&gt; DForeign -&gt; ShowS
[DForeign] -&gt; ShowS
DForeign -&gt; String
(Int -&gt; DForeign -&gt; ShowS)
-&gt; (DForeign -&gt; String) -&gt; ([DForeign] -&gt; ShowS) -&gt; Show DForeign
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DForeign] -&gt; ShowS
$cshowList :: [DForeign] -&gt; ShowS
show :: DForeign -&gt; String
$cshow :: DForeign -&gt; String
showsPrec :: Int -&gt; DForeign -&gt; ShowS
$cshowsPrec :: Int -&gt; DForeign -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDExportF"><span id="%24cDImportF"><span id="%24tDForeign"><span id="local-6989586621679400151"><span id="local-6989586621679400153"><span id="local-6989586621679400155"><span id="local-6989586621679400157"><span id="local-6989586621679400159"><span id="local-6989586621679400161"><span id="local-6989586621679400163"><span id="local-6989586621679400165"><span id="local-6989586621679400167"><span id="local-6989586621679400169"><span id="local-6989586621679400171"><span id="local-6989586621679400173"><span id="local-6989586621679400175"><span id="local-6989586621679400177"><span class="annot"><span class="annottext">Typeable DForeign
DataType
Constr
Typeable DForeign
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign)
-&gt; (DForeign -&gt; Constr)
-&gt; (DForeign -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForeign))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DForeign))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DForeign -&gt; DForeign)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign)
-&gt; Data DForeign
DForeign -&gt; DataType
DForeign -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DForeign -&gt; DForeign
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForeign)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DForeign)
$cDExportF :: Constr
$cDImportF :: Constr
$tDForeign :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DForeign -&gt; DForeign
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DForeign -&gt; DForeign
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DForeign)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DForeign)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForeign)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForeign)
dataTypeOf :: DForeign -&gt; DataType
$cdataTypeOf :: DForeign -&gt; DataType
toConstr :: DForeign -&gt; Constr
$ctoConstr :: DForeign -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign
$cp1Data :: Typeable DForeign
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DForeign -&gt; Rep DForeign x)
-&gt; (forall x. Rep DForeign x -&gt; DForeign) -&gt; Generic DForeign
forall x. Rep DForeign x -&gt; DForeign
forall x. DForeign -&gt; Rep DForeign x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DForeign x -&gt; DForeign
$cfrom :: forall x. DForeign -&gt; Rep DForeign x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span class="hs-comment">-- | Corresponds to TH's @Pragma@ type.</span><span>
</span><span id="line-252"></span><span id="local-6989586621679400144"><span id="local-6989586621679400145"></span></span><span class="hs-keyword">data</span><span> </span><span id="DPragma"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPragma"><span class="hs-identifier hs-var">DPragma</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DInlineP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInlineP"><span class="hs-identifier hs-var">DInlineP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Inline</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuleMatch</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Phases</span></span><span>
</span><span id="line-253"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DSpecialiseP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSpecialiseP"><span class="hs-identifier hs-var">DSpecialiseP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Inline</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Phases</span></span><span>
</span><span id="line-254"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DSpecialiseInstP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSpecialiseInstP"><span class="hs-identifier hs-var">DSpecialiseInstP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-255"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DRuleP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleP"><span class="hs-identifier hs-var">DRuleP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleBndr"><span class="hs-identifier hs-type">DRuleBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Phases</span></span><span>
</span><span id="line-256"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DAnnP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAnnP"><span class="hs-identifier hs-var">DAnnP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">AnnTarget</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-257"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DLineP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLineP"><span class="hs-identifier hs-var">DLineP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-258"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DCompleteP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCompleteP"><span class="hs-identifier hs-var">DCompleteP</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-259"></span><span>             </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400129"><span id="local-6989586621679400131"><span class="annot"><span class="annottext">DPragma -&gt; DPragma -&gt; Bool
(DPragma -&gt; DPragma -&gt; Bool)
-&gt; (DPragma -&gt; DPragma -&gt; Bool) -&gt; Eq DPragma
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DPragma -&gt; DPragma -&gt; Bool
$c/= :: DPragma -&gt; DPragma -&gt; Bool
== :: DPragma -&gt; DPragma -&gt; Bool
$c== :: DPragma -&gt; DPragma -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400123"><span id="local-6989586621679400125"><span id="local-6989586621679400127"><span class="annot"><span class="annottext">Int -&gt; DPragma -&gt; ShowS
[DPragma] -&gt; ShowS
DPragma -&gt; String
(Int -&gt; DPragma -&gt; ShowS)
-&gt; (DPragma -&gt; String) -&gt; ([DPragma] -&gt; ShowS) -&gt; Show DPragma
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DPragma] -&gt; ShowS
$cshowList :: [DPragma] -&gt; ShowS
show :: DPragma -&gt; String
$cshow :: DPragma -&gt; String
showsPrec :: Int -&gt; DPragma -&gt; ShowS
$cshowsPrec :: Int -&gt; DPragma -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDCompleteP"><span id="%24cDLineP"><span id="%24cDAnnP"><span id="%24cDRuleP"><span id="%24cDSpecialiseInstP"><span id="%24cDSpecialiseP"><span id="%24cDInlineP"><span id="%24tDPragma"><span id="local-6989586621679400094"><span id="local-6989586621679400096"><span id="local-6989586621679400098"><span id="local-6989586621679400100"><span id="local-6989586621679400102"><span id="local-6989586621679400104"><span id="local-6989586621679400106"><span id="local-6989586621679400108"><span id="local-6989586621679400110"><span id="local-6989586621679400112"><span id="local-6989586621679400114"><span id="local-6989586621679400116"><span id="local-6989586621679400118"><span id="local-6989586621679400120"><span class="annot"><span class="annottext">Typeable DPragma
DataType
Constr
Typeable DPragma
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma)
-&gt; (DPragma -&gt; Constr)
-&gt; (DPragma -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPragma))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPragma))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DPragma -&gt; DPragma)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma)
-&gt; Data DPragma
DPragma -&gt; DataType
DPragma -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DPragma -&gt; DPragma
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPragma)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPragma)
$cDCompleteP :: Constr
$cDLineP :: Constr
$cDAnnP :: Constr
$cDRuleP :: Constr
$cDSpecialiseInstP :: Constr
$cDSpecialiseP :: Constr
$cDInlineP :: Constr
$tDPragma :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPragma -&gt; DPragma
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPragma -&gt; DPragma
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPragma)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPragma)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPragma)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPragma)
dataTypeOf :: DPragma -&gt; DataType
$cdataTypeOf :: DPragma -&gt; DataType
toConstr :: DPragma -&gt; Constr
$ctoConstr :: DPragma -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma
$cp1Data :: Typeable DPragma
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DPragma -&gt; Rep DPragma x)
-&gt; (forall x. Rep DPragma x -&gt; DPragma) -&gt; Generic DPragma
forall x. Rep DPragma x -&gt; DPragma
forall x. DPragma -&gt; Rep DPragma x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DPragma x -&gt; DPragma
$cfrom :: forall x. DPragma -&gt; Rep DPragma x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>
</span><span id="line-261"></span><span class="hs-comment">-- | Corresponds to TH's @RuleBndr@ type.</span><span>
</span><span id="line-262"></span><span id="local-6989586621679400082"><span id="local-6989586621679400083"></span></span><span class="hs-keyword">data</span><span> </span><span id="DRuleBndr"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleBndr"><span class="hs-identifier hs-var">DRuleBndr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DRuleVar"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleVar"><span class="hs-identifier hs-var">DRuleVar</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-263"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="DTypedRuleVar"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypedRuleVar"><span class="hs-identifier hs-var">DTypedRuleVar</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-264"></span><span>               </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400076"><span id="local-6989586621679400078"><span class="annot"><span class="annottext">DRuleBndr -&gt; DRuleBndr -&gt; Bool
(DRuleBndr -&gt; DRuleBndr -&gt; Bool)
-&gt; (DRuleBndr -&gt; DRuleBndr -&gt; Bool) -&gt; Eq DRuleBndr
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
$c/= :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
== :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
$c== :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400070"><span id="local-6989586621679400072"><span id="local-6989586621679400074"><span class="annot"><span class="annottext">Int -&gt; DRuleBndr -&gt; ShowS
[DRuleBndr] -&gt; ShowS
DRuleBndr -&gt; String
(Int -&gt; DRuleBndr -&gt; ShowS)
-&gt; (DRuleBndr -&gt; String)
-&gt; ([DRuleBndr] -&gt; ShowS)
-&gt; Show DRuleBndr
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DRuleBndr] -&gt; ShowS
$cshowList :: [DRuleBndr] -&gt; ShowS
show :: DRuleBndr -&gt; String
$cshow :: DRuleBndr -&gt; String
showsPrec :: Int -&gt; DRuleBndr -&gt; ShowS
$cshowsPrec :: Int -&gt; DRuleBndr -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDTypedRuleVar"><span id="%24cDRuleVar"><span id="%24tDRuleBndr"><span id="local-6989586621679400041"><span id="local-6989586621679400043"><span id="local-6989586621679400045"><span id="local-6989586621679400047"><span id="local-6989586621679400049"><span id="local-6989586621679400051"><span id="local-6989586621679400053"><span id="local-6989586621679400055"><span id="local-6989586621679400057"><span id="local-6989586621679400059"><span id="local-6989586621679400061"><span id="local-6989586621679400063"><span id="local-6989586621679400065"><span id="local-6989586621679400067"><span class="annot"><span class="annottext">Typeable DRuleBndr
DataType
Constr
Typeable DRuleBndr
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr)
-&gt; (DRuleBndr -&gt; Constr)
-&gt; (DRuleBndr -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DRuleBndr))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DRuleBndr))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DRuleBndr -&gt; DRuleBndr)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr)
-&gt; Data DRuleBndr
DRuleBndr -&gt; DataType
DRuleBndr -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DRuleBndr -&gt; DRuleBndr
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DRuleBndr)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DRuleBndr)
$cDTypedRuleVar :: Constr
$cDRuleVar :: Constr
$tDRuleBndr :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DRuleBndr -&gt; DRuleBndr
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DRuleBndr -&gt; DRuleBndr
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DRuleBndr)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DRuleBndr)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DRuleBndr)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DRuleBndr)
dataTypeOf :: DRuleBndr -&gt; DataType
$cdataTypeOf :: DRuleBndr -&gt; DataType
toConstr :: DRuleBndr -&gt; Constr
$ctoConstr :: DRuleBndr -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr
$cp1Data :: Typeable DRuleBndr
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DRuleBndr -&gt; Rep DRuleBndr x)
-&gt; (forall x. Rep DRuleBndr x -&gt; DRuleBndr) -&gt; Generic DRuleBndr
forall x. Rep DRuleBndr x -&gt; DRuleBndr
forall x. DRuleBndr -&gt; Rep DRuleBndr x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DRuleBndr x -&gt; DRuleBndr
$cfrom :: forall x. DRuleBndr -&gt; Rep DRuleBndr x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-265"></span><span>
</span><span id="line-266"></span><span class="hs-comment">-- | Corresponds to TH's @TySynEqn@ type (to store type family equations).</span><span>
</span><span id="line-267"></span><span id="local-6989586621679400034"><span id="local-6989586621679400035"></span></span><span class="hs-keyword">data</span><span> </span><span id="DTySynEqn"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-var">DTySynEqn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DTySynEqn"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-var">DTySynEqn</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-268"></span><span>               </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679400029"><span id="local-6989586621679400031"><span class="annot"><span class="annottext">DTySynEqn -&gt; DTySynEqn -&gt; Bool
(DTySynEqn -&gt; DTySynEqn -&gt; Bool)
-&gt; (DTySynEqn -&gt; DTySynEqn -&gt; Bool) -&gt; Eq DTySynEqn
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
$c/= :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
== :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
$c== :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679400023"><span id="local-6989586621679400025"><span id="local-6989586621679400027"><span class="annot"><span class="annottext">Int -&gt; DTySynEqn -&gt; ShowS
[DTySynEqn] -&gt; ShowS
DTySynEqn -&gt; String
(Int -&gt; DTySynEqn -&gt; ShowS)
-&gt; (DTySynEqn -&gt; String)
-&gt; ([DTySynEqn] -&gt; ShowS)
-&gt; Show DTySynEqn
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DTySynEqn] -&gt; ShowS
$cshowList :: [DTySynEqn] -&gt; ShowS
show :: DTySynEqn -&gt; String
$cshow :: DTySynEqn -&gt; String
showsPrec :: Int -&gt; DTySynEqn -&gt; ShowS
$cshowsPrec :: Int -&gt; DTySynEqn -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDTySynEqn"><span id="%24tDTySynEqn"><span id="local-6989586621679399994"><span id="local-6989586621679399996"><span id="local-6989586621679399998"><span id="local-6989586621679400000"><span id="local-6989586621679400002"><span id="local-6989586621679400004"><span id="local-6989586621679400006"><span id="local-6989586621679400008"><span id="local-6989586621679400010"><span id="local-6989586621679400012"><span id="local-6989586621679400014"><span id="local-6989586621679400016"><span id="local-6989586621679400018"><span id="local-6989586621679400020"><span class="annot"><span class="annottext">Typeable DTySynEqn
DataType
Constr
Typeable DTySynEqn
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn)
-&gt; (DTySynEqn -&gt; Constr)
-&gt; (DTySynEqn -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTySynEqn))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTySynEqn))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DTySynEqn -&gt; DTySynEqn)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn)
-&gt; Data DTySynEqn
DTySynEqn -&gt; DataType
DTySynEqn -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DTySynEqn -&gt; DTySynEqn
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTySynEqn)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTySynEqn)
$cDTySynEqn :: Constr
$tDTySynEqn :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTySynEqn -&gt; DTySynEqn
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTySynEqn -&gt; DTySynEqn
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTySynEqn)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTySynEqn)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTySynEqn)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTySynEqn)
dataTypeOf :: DTySynEqn -&gt; DataType
$cdataTypeOf :: DTySynEqn -&gt; DataType
toConstr :: DTySynEqn -&gt; Constr
$ctoConstr :: DTySynEqn -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn
$cp1Data :: Typeable DTySynEqn
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DTySynEqn -&gt; Rep DTySynEqn x)
-&gt; (forall x. Rep DTySynEqn x -&gt; DTySynEqn) -&gt; Generic DTySynEqn
forall x. Rep DTySynEqn x -&gt; DTySynEqn
forall x. DTySynEqn -&gt; Rep DTySynEqn x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DTySynEqn x -&gt; DTySynEqn
$cfrom :: forall x. DTySynEqn -&gt; Rep DTySynEqn x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-269"></span><span>
</span><span id="line-270"></span><span class="hs-comment">-- | Corresponds to TH's @Info@ type.</span><span>
</span><span id="line-271"></span><span id="local-6989586621679399988"><span id="local-6989586621679399989"></span></span><span class="hs-keyword">data</span><span> </span><span id="DInfo"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInfo"><span class="hs-identifier hs-var">DInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DTyConI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyConI"><span class="hs-identifier hs-var">DTyConI</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInstanceDec"><span class="hs-identifier hs-type">DInstanceDec</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-272"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DVarI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarI"><span class="hs-identifier hs-var">DVarI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>               </span><span class="hs-comment">-- ^ The @Maybe Name@ stores the name of the enclosing definition</span><span>
</span><span id="line-274"></span><span>               </span><span class="hs-comment">-- (datatype, for a data constructor; class, for a method),</span><span>
</span><span id="line-275"></span><span>               </span><span class="hs-comment">-- if any</span><span>
</span><span id="line-276"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DTyVarI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarI"><span class="hs-identifier hs-var">DTyVarI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-277"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DPrimTyConI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPrimTyConI"><span class="hs-identifier hs-var">DPrimTyConI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-278"></span><span>               </span><span class="hs-comment">-- ^ The @Int@ is the arity; the @Bool@ is whether this tycon</span><span>
</span><span id="line-279"></span><span>               </span><span class="hs-comment">-- is unlifted.</span><span>
</span><span id="line-280"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DPatSynI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynI"><span class="hs-identifier hs-var">DPatSynI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynType"><span class="hs-identifier hs-type">DPatSynType</span></a></span><span>
</span><span id="line-281"></span><span>           </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679399978"><span id="local-6989586621679399980"><span class="annot"><span class="annottext">DInfo -&gt; DInfo -&gt; Bool
(DInfo -&gt; DInfo -&gt; Bool) -&gt; (DInfo -&gt; DInfo -&gt; Bool) -&gt; Eq DInfo
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DInfo -&gt; DInfo -&gt; Bool
$c/= :: DInfo -&gt; DInfo -&gt; Bool
== :: DInfo -&gt; DInfo -&gt; Bool
$c== :: DInfo -&gt; DInfo -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679399972"><span id="local-6989586621679399974"><span id="local-6989586621679399976"><span class="annot"><span class="annottext">Int -&gt; DInfo -&gt; ShowS
[DInfo] -&gt; ShowS
DInfo -&gt; String
(Int -&gt; DInfo -&gt; ShowS)
-&gt; (DInfo -&gt; String) -&gt; ([DInfo] -&gt; ShowS) -&gt; Show DInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DInfo] -&gt; ShowS
$cshowList :: [DInfo] -&gt; ShowS
show :: DInfo -&gt; String
$cshow :: DInfo -&gt; String
showsPrec :: Int -&gt; DInfo -&gt; ShowS
$cshowsPrec :: Int -&gt; DInfo -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDPatSynI"><span id="%24cDPrimTyConI"><span id="%24cDTyVarI"><span id="%24cDVarI"><span id="%24cDTyConI"><span id="%24tDInfo"><span id="local-6989586621679399943"><span id="local-6989586621679399945"><span id="local-6989586621679399947"><span id="local-6989586621679399949"><span id="local-6989586621679399951"><span id="local-6989586621679399953"><span id="local-6989586621679399955"><span id="local-6989586621679399957"><span id="local-6989586621679399959"><span id="local-6989586621679399961"><span id="local-6989586621679399963"><span id="local-6989586621679399965"><span id="local-6989586621679399967"><span id="local-6989586621679399969"><span class="annot"><span class="annottext">Typeable DInfo
DataType
Constr
Typeable DInfo
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo)
-&gt; (DInfo -&gt; Constr)
-&gt; (DInfo -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DInfo))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DInfo))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DInfo -&gt; DInfo)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo)
-&gt; Data DInfo
DInfo -&gt; DataType
DInfo -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DInfo -&gt; DInfo
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DInfo)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DInfo)
$cDPatSynI :: Constr
$cDPrimTyConI :: Constr
$cDTyVarI :: Constr
$cDVarI :: Constr
$cDTyConI :: Constr
$tDInfo :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DInfo -&gt; DInfo
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DInfo -&gt; DInfo
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DInfo)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DInfo)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DInfo)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DInfo)
dataTypeOf :: DInfo -&gt; DataType
$cdataTypeOf :: DInfo -&gt; DataType
toConstr :: DInfo -&gt; Constr
$ctoConstr :: DInfo -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo
$cp1Data :: Typeable DInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DInfo -&gt; Rep DInfo x)
-&gt; (forall x. Rep DInfo x -&gt; DInfo) -&gt; Generic DInfo
forall x. Rep DInfo x -&gt; DInfo
forall x. DInfo -&gt; Rep DInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DInfo x -&gt; DInfo
$cfrom :: forall x. DInfo -&gt; Rep DInfo x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span class="hs-keyword">type</span><span> </span><span id="DInstanceDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInstanceDec"><span class="hs-identifier hs-var">DInstanceDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span> </span><span class="hs-comment">-- ^ Guaranteed to be an instance declaration</span><span>
</span><span id="line-284"></span><span>
</span><span id="line-285"></span><span class="hs-comment">-- | Corresponds to TH's @DerivClause@ type.</span><span>
</span><span id="line-286"></span><span id="local-6989586621679399933"><span id="local-6989586621679399934"></span></span><span class="hs-keyword">data</span><span> </span><span id="DDerivClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-var">DDerivClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DDerivClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-var">DDerivClause</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivStrategy"><span class="hs-identifier hs-type">DDerivStrategy</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span>
</span><span id="line-287"></span><span>                  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679399928"><span id="local-6989586621679399930"><span class="annot"><span class="annottext">DDerivClause -&gt; DDerivClause -&gt; Bool
(DDerivClause -&gt; DDerivClause -&gt; Bool)
-&gt; (DDerivClause -&gt; DDerivClause -&gt; Bool) -&gt; Eq DDerivClause
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DDerivClause -&gt; DDerivClause -&gt; Bool
$c/= :: DDerivClause -&gt; DDerivClause -&gt; Bool
== :: DDerivClause -&gt; DDerivClause -&gt; Bool
$c== :: DDerivClause -&gt; DDerivClause -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679399922"><span id="local-6989586621679399924"><span id="local-6989586621679399926"><span class="annot"><span class="annottext">Int -&gt; DDerivClause -&gt; ShowS
[DDerivClause] -&gt; ShowS
DDerivClause -&gt; String
(Int -&gt; DDerivClause -&gt; ShowS)
-&gt; (DDerivClause -&gt; String)
-&gt; ([DDerivClause] -&gt; ShowS)
-&gt; Show DDerivClause
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DDerivClause] -&gt; ShowS
$cshowList :: [DDerivClause] -&gt; ShowS
show :: DDerivClause -&gt; String
$cshow :: DDerivClause -&gt; String
showsPrec :: Int -&gt; DDerivClause -&gt; ShowS
$cshowsPrec :: Int -&gt; DDerivClause -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDDerivClause"><span id="%24tDDerivClause"><span id="local-6989586621679399893"><span id="local-6989586621679399895"><span id="local-6989586621679399897"><span id="local-6989586621679399899"><span id="local-6989586621679399901"><span id="local-6989586621679399903"><span id="local-6989586621679399905"><span id="local-6989586621679399907"><span id="local-6989586621679399909"><span id="local-6989586621679399911"><span id="local-6989586621679399913"><span id="local-6989586621679399915"><span id="local-6989586621679399917"><span id="local-6989586621679399919"><span class="annot"><span class="annottext">Typeable DDerivClause
DataType
Constr
Typeable DDerivClause
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause)
-&gt; (DDerivClause -&gt; Constr)
-&gt; (DDerivClause -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivClause))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DDerivClause))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DDerivClause -&gt; DDerivClause)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause)
-&gt; Data DDerivClause
DDerivClause -&gt; DataType
DDerivClause -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DDerivClause -&gt; DDerivClause
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivClause)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivClause)
$cDDerivClause :: Constr
$tDDerivClause :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivClause -&gt; DDerivClause
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivClause -&gt; DDerivClause
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivClause)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivClause)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivClause)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivClause)
dataTypeOf :: DDerivClause -&gt; DataType
$cdataTypeOf :: DDerivClause -&gt; DataType
toConstr :: DDerivClause -&gt; Constr
$ctoConstr :: DDerivClause -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause
$cp1Data :: Typeable DDerivClause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DDerivClause -&gt; Rep DDerivClause x)
-&gt; (forall x. Rep DDerivClause x -&gt; DDerivClause)
-&gt; Generic DDerivClause
forall x. Rep DDerivClause x -&gt; DDerivClause
forall x. DDerivClause -&gt; Rep DDerivClause x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DDerivClause x -&gt; DDerivClause
$cfrom :: forall x. DDerivClause -&gt; Rep DDerivClause x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span>
</span><span id="line-289"></span><span class="hs-comment">-- | Corresponds to TH's @DerivStrategy@ type.</span><span>
</span><span id="line-290"></span><span id="local-6989586621679399887"><span id="local-6989586621679399888"></span></span><span class="hs-keyword">data</span><span> </span><span id="DDerivStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivStrategy"><span class="hs-identifier hs-var">DDerivStrategy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DStockStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DStockStrategy"><span class="hs-identifier hs-var">DStockStrategy</span></a></span></span><span>     </span><span class="hs-comment">-- ^ A \&quot;standard\&quot; derived instance</span><span>
</span><span id="line-291"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="DAnyclassStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAnyclassStrategy"><span class="hs-identifier hs-var">DAnyclassStrategy</span></a></span></span><span>  </span><span class="hs-comment">-- ^ @-XDeriveAnyClass@</span><span>
</span><span id="line-292"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="DNewtypeStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DNewtypeStrategy"><span class="hs-identifier hs-var">DNewtypeStrategy</span></a></span></span><span>   </span><span class="hs-comment">-- ^ @-XGeneralizedNewtypeDeriving@</span><span>
</span><span id="line-293"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="DViaStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DViaStrategy"><span class="hs-identifier hs-var">DViaStrategy</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-comment">-- ^ @-XDerivingVia@</span><span>
</span><span id="line-294"></span><span>                    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679399879"><span id="local-6989586621679399881"><span class="annot"><span class="annottext">DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
(DDerivStrategy -&gt; DDerivStrategy -&gt; Bool)
-&gt; (DDerivStrategy -&gt; DDerivStrategy -&gt; Bool) -&gt; Eq DDerivStrategy
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
$c/= :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
== :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
$c== :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679399873"><span id="local-6989586621679399875"><span id="local-6989586621679399877"><span class="annot"><span class="annottext">Int -&gt; DDerivStrategy -&gt; ShowS
[DDerivStrategy] -&gt; ShowS
DDerivStrategy -&gt; String
(Int -&gt; DDerivStrategy -&gt; ShowS)
-&gt; (DDerivStrategy -&gt; String)
-&gt; ([DDerivStrategy] -&gt; ShowS)
-&gt; Show DDerivStrategy
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DDerivStrategy] -&gt; ShowS
$cshowList :: [DDerivStrategy] -&gt; ShowS
show :: DDerivStrategy -&gt; String
$cshow :: DDerivStrategy -&gt; String
showsPrec :: Int -&gt; DDerivStrategy -&gt; ShowS
$cshowsPrec :: Int -&gt; DDerivStrategy -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDViaStrategy"><span id="%24cDNewtypeStrategy"><span id="%24cDAnyclassStrategy"><span id="%24cDStockStrategy"><span id="%24tDDerivStrategy"><span id="local-6989586621679399844"><span id="local-6989586621679399846"><span id="local-6989586621679399848"><span id="local-6989586621679399850"><span id="local-6989586621679399852"><span id="local-6989586621679399854"><span id="local-6989586621679399856"><span id="local-6989586621679399858"><span id="local-6989586621679399860"><span id="local-6989586621679399862"><span id="local-6989586621679399864"><span id="local-6989586621679399866"><span id="local-6989586621679399868"><span id="local-6989586621679399870"><span class="annot"><span class="annottext">Typeable DDerivStrategy
DataType
Constr
Typeable DDerivStrategy
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy)
-&gt; (DDerivStrategy -&gt; Constr)
-&gt; (DDerivStrategy -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivStrategy))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DDerivStrategy))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; DDerivStrategy -&gt; DDerivStrategy)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DDerivStrategy -&gt; m DDerivStrategy)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DDerivStrategy -&gt; m DDerivStrategy)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DDerivStrategy -&gt; m DDerivStrategy)
-&gt; Data DDerivStrategy
DDerivStrategy -&gt; DataType
DDerivStrategy -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DDerivStrategy -&gt; DDerivStrategy
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivStrategy)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivStrategy)
$cDViaStrategy :: Constr
$cDNewtypeStrategy :: Constr
$cDAnyclassStrategy :: Constr
$cDStockStrategy :: Constr
$tDDerivStrategy :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivStrategy -&gt; DDerivStrategy
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivStrategy -&gt; DDerivStrategy
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivStrategy)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivStrategy)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivStrategy)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivStrategy)
dataTypeOf :: DDerivStrategy -&gt; DataType
$cdataTypeOf :: DDerivStrategy -&gt; DataType
toConstr :: DDerivStrategy -&gt; Constr
$ctoConstr :: DDerivStrategy -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy
$cp1Data :: Typeable DDerivStrategy
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. DDerivStrategy -&gt; Rep DDerivStrategy x)
-&gt; (forall x. Rep DDerivStrategy x -&gt; DDerivStrategy)
-&gt; Generic DDerivStrategy
forall x. Rep DDerivStrategy x -&gt; DDerivStrategy
forall x. DDerivStrategy -&gt; Rep DDerivStrategy x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DDerivStrategy x -&gt; DDerivStrategy
$cfrom :: forall x. DDerivStrategy -&gt; Rep DDerivStrategy x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-295"></span></pre></body></html>