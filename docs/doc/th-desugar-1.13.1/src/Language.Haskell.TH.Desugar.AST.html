<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621679502579"><span id="local-6989586621679502580"><span id="local-6989586621679502581"><span id="local-6989586621679502582"><span id="local-6989586621679502583"><span id="local-6989586621679502584"><span id="local-6989586621679502585"><span id="local-6989586621679502586"><span id="local-6989586621679502587"><span id="local-6989586621679502588"><span id="local-6989586621679502589"><span id="local-6989586621679502590"><span id="local-6989586621679502591"><span id="local-6989586621679502592"><span id="local-6989586621679502593"><span id="local-6989586621679502594"><span id="local-6989586621679502595"><span id="local-6989586621679502596"><span id="local-6989586621679502597"><span id="local-6989586621679502598"><span id="local-6989586621679502599"><span id="local-6989586621679502600"><span id="local-6989586621679502601"><span id="local-6989586621679502602"><span id="local-6989586621679502603"><span id="local-6989586621679502604"><span id="local-6989586621679502605"><span id="local-6989586621679502606"><span id="local-6989586621679502607"><span id="local-6989586621679502608"><span id="local-6989586621679502609"><span id="local-6989586621679502610"><span id="local-6989586621679502611"><span id="local-6989586621679502612"><span id="local-6989586621679502613"><span id="local-6989586621679502614"><span id="local-6989586621679502615"><span id="local-6989586621679502616"><span id="local-6989586621679502617"><span id="local-6989586621679502618"><span id="local-6989586621679502619"><span id="local-6989586621679502620"><span id="local-6989586621679502621"><span id="local-6989586621679502622"><span id="local-6989586621679502623"><span id="local-6989586621679502624"><span id="local-6989586621679502625"><span id="local-6989586621679502626"><span id="local-6989586621679502627"><span id="local-6989586621679502628"><span id="local-6989586621679502629"><span id="local-6989586621679502630"><span id="local-6989586621679502631"><span id="local-6989586621679502632"><span id="local-6989586621679502633"><span id="local-6989586621679502634"><span id="local-6989586621679502635"><span id="local-6989586621679502636"><span id="local-6989586621679502637"><span id="local-6989586621679502638"><span id="local-6989586621679502639"><span id="local-6989586621679502640"><span id="local-6989586621679502641"><span id="local-6989586621679502642"><span id="local-6989586621679502643"><span id="local-6989586621679502644"><span id="local-6989586621679502645"><span id="local-6989586621679502646"><span id="local-6989586621679502647"><span id="local-6989586621679502648"><span id="local-6989586621679502649"><span id="local-6989586621679502650"><span id="local-6989586621679502651"><span id="local-6989586621679502652"><span id="local-6989586621679502653"><span id="local-6989586621679502654"><span id="local-6989586621679502655"><span id="local-6989586621679502656"><span id="local-6989586621679502657"><span id="local-6989586621679502658"><span id="local-6989586621679502659"><span id="local-6989586621679502660"><span id="local-6989586621679502661"><span id="local-6989586621679502662"><span id="local-6989586621679502663"><span id="local-6989586621679502664"><span id="local-6989586621679502665"><span id="local-6989586621679502666"><span id="local-6989586621679502667"><span id="local-6989586621679502668"><span id="local-6989586621679502669"><span id="local-6989586621679502670"><span id="local-6989586621679502671"><span id="local-6989586621679502672"><span id="local-6989586621679502673"><span id="local-6989586621679502674"><span id="local-6989586621679502675"><span id="local-6989586621679502676"><span id="local-6989586621679502677"><span id="local-6989586621679502678"><span id="local-6989586621679502679"><span id="local-6989586621679502680"><span id="local-6989586621679502681"><span id="local-6989586621679502682"><span id="local-6989586621679502683"><span id="local-6989586621679502684"><span id="local-6989586621679502685"><span id="local-6989586621679502686"><span id="local-6989586621679502687"><span id="local-6989586621679502688"><span id="local-6989586621679502689"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-comment">{- Language/Haskell/TH/Desugar/AST.hs

(c) Ryan Scott 2018

Defines the desugared Template Haskell AST. The desugared types and
constructors are prefixed with a D.
-}</span><span>
</span><span id="line-8"></span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE CPP, DeriveDataTypeable, DeriveFunctor, DeriveGeneric #-}</span><span>
</span><span id="line-10"></span><span>
</span><span id="line-11"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Desugar.AST</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-12"></span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Fixity</span></span><span class="hs-special">)</span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Fixity</span></span><span class="hs-special">)</span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 900
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Datatype.TyVarBndr</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Specificity</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- | Corresponds to TH's @Exp@ type. Note that @DLamE@ takes names, not patterns.</span><span>
</span><span id="line-21"></span><span id="local-6989586621679502575"><span id="local-6989586621679502576"></span></span><span class="hs-keyword">data</span><span> </span><span id="DExp"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-var">DExp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DVarE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarE"><span class="hs-identifier hs-var">DVarE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-22"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DConE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConE"><span class="hs-identifier hs-var">DConE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-23"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DLitE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLitE"><span class="hs-identifier hs-var">DLitE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Lit</span></span><span>
</span><span id="line-24"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DAppE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppE"><span class="hs-identifier hs-var">DAppE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-25"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DAppTypeE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppTypeE"><span class="hs-identifier hs-var">DAppTypeE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-26"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DLamE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLamE"><span class="hs-identifier hs-var">DLamE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-27"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DCaseE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCaseE"><span class="hs-identifier hs-var">DCaseE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier hs-type">DMatch</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-28"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DLetE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetE"><span class="hs-identifier hs-var">DLetE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-29"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DSigE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigE"><span class="hs-identifier hs-var">DSigE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-30"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DStaticE"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DStaticE"><span class="hs-identifier hs-var">DStaticE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-31"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679502540"><span id="local-6989586621679502563"><span class="annot"><span class="annottext">DExp -&gt; DExp -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DExp -&gt; DExp -&gt; Bool
$c/= :: DExp -&gt; DExp -&gt; Bool
== :: DExp -&gt; DExp -&gt; Bool
$c== :: DExp -&gt; DExp -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502501"><span id="local-6989586621679502503"><span id="local-6989586621679502537"><span class="annot"><span class="annottext">Int -&gt; DExp -&gt; ShowS
[DExp] -&gt; ShowS
DExp -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DExp] -&gt; ShowS
$cshowList :: [DExp] -&gt; ShowS
show :: DExp -&gt; String
$cshow :: DExp -&gt; String
showsPrec :: Int -&gt; DExp -&gt; ShowS
$cshowsPrec :: Int -&gt; DExp -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502431"><span id="local-6989586621679502433"><span id="local-6989586621679502435"><span id="local-6989586621679502437"><span id="local-6989586621679502439"><span id="local-6989586621679502441"><span id="local-6989586621679502443"><span id="local-6989586621679502445"><span id="local-6989586621679502447"><span id="local-6989586621679502449"><span id="local-6989586621679502451"><span id="local-6989586621679502453"><span id="local-6989586621679502473"><span id="local-6989586621679502496"><span class="annot"><span class="annottext">Typeable DExp
DExp -&gt; DataType
DExp -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DExp -&gt; DExp
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DExp)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DExp)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DExp -&gt; m DExp
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DExp -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DExp -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DExp -&gt; DExp
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DExp -&gt; DExp
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DExp)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DExp)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DExp)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DExp)
dataTypeOf :: DExp -&gt; DataType
$cdataTypeOf :: DExp -&gt; DataType
toConstr :: DExp -&gt; Constr
$ctoConstr :: DExp -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DExp
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DExp -&gt; c DExp
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DExp x -&gt; DExp
forall x. DExp -&gt; Rep DExp x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DExp x -&gt; DExp
$cfrom :: forall x. DExp -&gt; Rep DExp x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-32"></span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="hs-comment">-- | Corresponds to TH's @Pat@ type.</span><span>
</span><span id="line-35"></span><span id="local-6989586621679502424"><span id="local-6989586621679502425"></span></span><span class="hs-keyword">data</span><span> </span><span id="DPat"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-var">DPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DLitP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLitP"><span class="hs-identifier hs-var">DLitP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Lit</span></span><span>
</span><span id="line-36"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DVarP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-var">DVarP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-37"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DConP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConP"><span class="hs-identifier hs-var">DConP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-38"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DTildeP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTildeP"><span class="hs-identifier hs-var">DTildeP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span>
</span><span id="line-39"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DBangP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangP"><span class="hs-identifier hs-var">DBangP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span>
</span><span id="line-40"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DSigP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigP"><span class="hs-identifier hs-var">DSigP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-41"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DWildP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DWildP"><span class="hs-identifier hs-var">DWildP</span></a></span></span><span>
</span><span id="line-42"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679502402"><span id="local-6989586621679502415"><span class="annot"><span class="annottext">DPat -&gt; DPat -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DPat -&gt; DPat -&gt; Bool
$c/= :: DPat -&gt; DPat -&gt; Bool
== :: DPat -&gt; DPat -&gt; Bool
$c== :: DPat -&gt; DPat -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502379"><span id="local-6989586621679502381"><span id="local-6989586621679502400"><span class="annot"><span class="annottext">Int -&gt; DPat -&gt; ShowS
[DPat] -&gt; ShowS
DPat -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DPat] -&gt; ShowS
$cshowList :: [DPat] -&gt; ShowS
show :: DPat -&gt; String
$cshow :: DPat -&gt; String
showsPrec :: Int -&gt; DPat -&gt; ShowS
$cshowsPrec :: Int -&gt; DPat -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502327"><span id="local-6989586621679502329"><span id="local-6989586621679502331"><span id="local-6989586621679502333"><span id="local-6989586621679502335"><span id="local-6989586621679502337"><span id="local-6989586621679502339"><span id="local-6989586621679502341"><span id="local-6989586621679502343"><span id="local-6989586621679502345"><span id="local-6989586621679502347"><span id="local-6989586621679502349"><span id="local-6989586621679502362"><span id="local-6989586621679502375"><span class="annot"><span class="annottext">Typeable DPat
DPat -&gt; DataType
DPat -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DPat -&gt; DPat
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPat)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPat)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPat -&gt; m DPat
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPat -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPat -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPat -&gt; DPat
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPat -&gt; DPat
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPat)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPat)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPat)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPat)
dataTypeOf :: DPat -&gt; DataType
$cdataTypeOf :: DPat -&gt; DataType
toConstr :: DPat -&gt; Constr
$ctoConstr :: DPat -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPat
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPat -&gt; c DPat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DPat x -&gt; DPat
forall x. DPat -&gt; Rep DPat x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DPat x -&gt; DPat
$cfrom :: forall x. DPat -&gt; Rep DPat x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-comment">-- | Corresponds to TH's @Type@ type, used to represent</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- types and kinds.</span><span>
</span><span id="line-46"></span><span id="local-6989586621679502322"><span id="local-6989586621679502323"></span></span><span class="hs-keyword">data</span><span> </span><span id="DType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-var">DType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DForallT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForallT"><span class="hs-identifier hs-var">DForallT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForallTelescope"><span class="hs-identifier hs-type">DForallTelescope</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-47"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DConstrainedT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConstrainedT"><span class="hs-identifier hs-var">DConstrainedT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-48"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DAppT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppT"><span class="hs-identifier hs-var">DAppT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-49"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DAppKindT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAppKindT"><span class="hs-identifier hs-var">DAppKindT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-50"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DSigT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigT"><span class="hs-identifier hs-var">DSigT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-51"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DVarT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarT"><span class="hs-identifier hs-var">DVarT</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-52"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DConT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConT"><span class="hs-identifier hs-var">DConT</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-53"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DArrowT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DArrowT"><span class="hs-identifier hs-var">DArrowT</span></a></span></span><span>
</span><span id="line-54"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DLitT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLitT"><span class="hs-identifier hs-var">DLitT</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyLit</span></span><span>
</span><span id="line-55"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DWildCardT"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DWildCardT"><span class="hs-identifier hs-var">DWildCardT</span></a></span></span><span>
</span><span id="line-56"></span><span>           </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679502292"><span id="local-6989586621679502308"><span class="annot"><span class="annottext">DType -&gt; DType -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DType -&gt; DType -&gt; Bool
$c/= :: DType -&gt; DType -&gt; Bool
== :: DType -&gt; DType -&gt; Bool
$c== :: DType -&gt; DType -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502264"><span id="local-6989586621679502266"><span id="local-6989586621679502290"><span class="annot"><span class="annottext">Int -&gt; DType -&gt; ShowS
[DType] -&gt; ShowS
DType -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DType] -&gt; ShowS
$cshowList :: [DType] -&gt; ShowS
show :: DType -&gt; String
$cshow :: DType -&gt; String
showsPrec :: Int -&gt; DType -&gt; ShowS
$cshowsPrec :: Int -&gt; DType -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502207"><span id="local-6989586621679502209"><span id="local-6989586621679502211"><span id="local-6989586621679502213"><span id="local-6989586621679502215"><span id="local-6989586621679502217"><span id="local-6989586621679502219"><span id="local-6989586621679502221"><span id="local-6989586621679502223"><span id="local-6989586621679502225"><span id="local-6989586621679502227"><span id="local-6989586621679502229"><span id="local-6989586621679502244"><span id="local-6989586621679502260"><span class="annot"><span class="annottext">Typeable DType
DType -&gt; DataType
DType -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DType -&gt; DType
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DType)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DType)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DType -&gt; m DType
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DType -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DType -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DType -&gt; DType
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DType -&gt; DType
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DType)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DType)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DType)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DType)
dataTypeOf :: DType -&gt; DataType
$cdataTypeOf :: DType -&gt; DataType
toConstr :: DType -&gt; Constr
$ctoConstr :: DType -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DType
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DType -&gt; c DType
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DType x -&gt; DType
forall x. DType -&gt; Rep DType x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DType x -&gt; DType
$cfrom :: forall x. DType -&gt; Rep DType x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-comment">-- | The type variable binders in a @forall@.</span><span>
</span><span id="line-59"></span><span id="local-6989586621679502202"><span id="local-6989586621679502203"></span></span><span class="hs-keyword">data</span><span> </span><span id="DForallTelescope"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForallTelescope"><span class="hs-identifier hs-var">DForallTelescope</span></a></span></span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DForallVis"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForallVis"><span class="hs-identifier hs-var">DForallVis</span></a></span></span><span>   </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-61"></span><span>    </span><span class="hs-comment">-- ^ A visible @forall@ (e.g., @forall a -&gt; {...}@).</span><span>
</span><span id="line-62"></span><span>    </span><span class="hs-comment">--   These do not have any notion of specificity, so we use</span><span>
</span><span id="line-63"></span><span>    </span><span class="hs-comment">--   '()' as a placeholder value in the 'DTyVarBndr's.</span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DForallInvis"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForallInvis"><span class="hs-identifier hs-var">DForallInvis</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrSpec"><span class="hs-identifier hs-type">DTyVarBndrSpec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-comment">-- ^ An invisible @forall@ (e.g., @forall a {b} c -&gt; {...}@),</span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-comment">--   where each binder has a 'Specificity'.</span><span>
</span><span id="line-67"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679502192"><span id="local-6989586621679502198"><span class="annot"><span class="annottext">DForallTelescope -&gt; DForallTelescope -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DForallTelescope -&gt; DForallTelescope -&gt; Bool
$c/= :: DForallTelescope -&gt; DForallTelescope -&gt; Bool
== :: DForallTelescope -&gt; DForallTelescope -&gt; Bool
$c== :: DForallTelescope -&gt; DForallTelescope -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502176"><span id="local-6989586621679502178"><span id="local-6989586621679502186"><span class="annot"><span class="annottext">Int -&gt; DForallTelescope -&gt; ShowS
[DForallTelescope] -&gt; ShowS
DForallTelescope -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DForallTelescope] -&gt; ShowS
$cshowList :: [DForallTelescope] -&gt; ShowS
show :: DForallTelescope -&gt; String
$cshow :: DForallTelescope -&gt; String
showsPrec :: Int -&gt; DForallTelescope -&gt; ShowS
$cshowsPrec :: Int -&gt; DForallTelescope -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502134"><span id="local-6989586621679502136"><span id="local-6989586621679502138"><span id="local-6989586621679502140"><span id="local-6989586621679502142"><span id="local-6989586621679502144"><span id="local-6989586621679502146"><span id="local-6989586621679502148"><span id="local-6989586621679502150"><span id="local-6989586621679502152"><span id="local-6989586621679502154"><span id="local-6989586621679502156"><span id="local-6989586621679502162"><span id="local-6989586621679502168"><span class="annot"><span class="annottext">Typeable DForallTelescope
DForallTelescope -&gt; DataType
DForallTelescope -&gt; Constr
(forall b. Data b =&gt; b -&gt; b)
-&gt; DForallTelescope -&gt; DForallTelescope
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForallTelescope -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForallTelescope -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForallTelescope -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForallTelescope -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForallTelescope
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForallTelescope -&gt; c DForallTelescope
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForallTelescope)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DForallTelescope)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DForallTelescope -&gt; m DForallTelescope
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForallTelescope -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForallTelescope -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForallTelescope -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForallTelescope -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForallTelescope -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForallTelescope -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForallTelescope -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForallTelescope -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DForallTelescope -&gt; DForallTelescope
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DForallTelescope -&gt; DForallTelescope
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DForallTelescope)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DForallTelescope)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForallTelescope)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForallTelescope)
dataTypeOf :: DForallTelescope -&gt; DataType
$cdataTypeOf :: DForallTelescope -&gt; DataType
toConstr :: DForallTelescope -&gt; Constr
$ctoConstr :: DForallTelescope -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForallTelescope
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForallTelescope
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForallTelescope -&gt; c DForallTelescope
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForallTelescope -&gt; c DForallTelescope
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DForallTelescope x -&gt; DForallTelescope
forall x. DForallTelescope -&gt; Rep DForallTelescope x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DForallTelescope x -&gt; DForallTelescope
$cfrom :: forall x. DForallTelescope -&gt; Rep DForallTelescope x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span class="hs-comment">-- | Kinds are types. Corresponds to TH's @Kind@</span><span>
</span><span id="line-70"></span><span class="hs-keyword">type</span><span> </span><span id="DKind"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-var">DKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span class="hs-comment">-- | Predicates are types. Corresponds to TH's @Pred@</span><span>
</span><span id="line-73"></span><span class="hs-keyword">type</span><span> </span><span id="DPred"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPred"><span class="hs-identifier hs-var">DPred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span class="hs-comment">-- | Corresponds to TH's @Cxt@</span><span>
</span><span id="line-76"></span><span class="hs-keyword">type</span><span> </span><span id="DCxt"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-var">DCxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPred"><span class="hs-identifier hs-type">DPred</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="hs-comment">-- | Corresponds to TH's @TyVarBndr@</span><span>
</span><span id="line-79"></span><span id="local-6989586621679502122"><span id="local-6989586621679502123"></span></span><span class="hs-keyword">data</span><span> </span><span id="DTyVarBndr"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-var">DTyVarBndr</span></a></span></span><span> </span><span id="local-6989586621679503783"><span class="annot"><a href="#local-6989586621679503783"><span class="hs-identifier hs-type">flag</span></a></span></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DPlainTV"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPlainTV"><span class="hs-identifier hs-var">DPlainTV</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679503783"><span class="hs-identifier hs-type">flag</span></a></span><span>
</span><span id="line-81"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DKindedTV"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKindedTV"><span class="hs-identifier hs-var">DKindedTV</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679503783"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679502111"><span id="local-6989586621679502118"><span class="annot"><span class="annottext">DTyVarBndr flag -&gt; DTyVarBndr flag -&gt; Bool
forall flag. Eq flag =&gt; DTyVarBndr flag -&gt; DTyVarBndr flag -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DTyVarBndr flag -&gt; DTyVarBndr flag -&gt; Bool
$c/= :: forall flag. Eq flag =&gt; DTyVarBndr flag -&gt; DTyVarBndr flag -&gt; Bool
== :: DTyVarBndr flag -&gt; DTyVarBndr flag -&gt; Bool
$c== :: forall flag. Eq flag =&gt; DTyVarBndr flag -&gt; DTyVarBndr flag -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502098"><span id="local-6989586621679502100"><span id="local-6989586621679502109"><span class="annot"><span class="annottext">Int -&gt; DTyVarBndr flag -&gt; ShowS
forall flag. Show flag =&gt; Int -&gt; DTyVarBndr flag -&gt; ShowS
forall flag. Show flag =&gt; [DTyVarBndr flag] -&gt; ShowS
forall flag. Show flag =&gt; DTyVarBndr flag -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DTyVarBndr flag] -&gt; ShowS
$cshowList :: forall flag. Show flag =&gt; [DTyVarBndr flag] -&gt; ShowS
show :: DTyVarBndr flag -&gt; String
$cshow :: forall flag. Show flag =&gt; DTyVarBndr flag -&gt; String
showsPrec :: Int -&gt; DTyVarBndr flag -&gt; ShowS
$cshowsPrec :: forall flag. Show flag =&gt; Int -&gt; DTyVarBndr flag -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502053"><span id="local-6989586621679502055"><span id="local-6989586621679502057"><span id="local-6989586621679502059"><span id="local-6989586621679502061"><span id="local-6989586621679502063"><span id="local-6989586621679502065"><span id="local-6989586621679502067"><span id="local-6989586621679502069"><span id="local-6989586621679502075"><span id="local-6989586621679502077"><span id="local-6989586621679502079"><span id="local-6989586621679502086"><span id="local-6989586621679502093"><span class="annot"><span class="annottext">DTyVarBndr flag -&gt; DataType
DTyVarBndr flag -&gt; Constr
forall {flag}. Data flag =&gt; Typeable (DTyVarBndr flag)
forall flag. Data flag =&gt; DTyVarBndr flag -&gt; DataType
forall flag. Data flag =&gt; DTyVarBndr flag -&gt; Constr
forall flag.
Data flag =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DTyVarBndr flag -&gt; DTyVarBndr flag
forall flag u.
Data flag =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr flag -&gt; u
forall flag u.
Data flag =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr flag -&gt; [u]
forall flag r r'.
Data flag =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr flag -&gt; r
forall flag r r'.
Data flag =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr flag -&gt; r
forall flag (m :: * -&gt; *).
(Data flag, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
forall flag (m :: * -&gt; *).
(Data flag, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DTyVarBndr flag)
forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr flag -&gt; c (DTyVarBndr flag)
forall flag (t :: * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DTyVarBndr flag))
forall flag (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DTyVarBndr flag))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DTyVarBndr flag)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr flag -&gt; c (DTyVarBndr flag)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DTyVarBndr flag))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
$cgmapMo :: forall flag (m :: * -&gt; *).
(Data flag, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
$cgmapMp :: forall flag (m :: * -&gt; *).
(Data flag, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
$cgmapM :: forall flag (m :: * -&gt; *).
(Data flag, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTyVarBndr flag -&gt; m (DTyVarBndr flag)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr flag -&gt; u
$cgmapQi :: forall flag u.
Data flag =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr flag -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr flag -&gt; [u]
$cgmapQ :: forall flag u.
Data flag =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DTyVarBndr flag -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr flag -&gt; r
$cgmapQr :: forall flag r r'.
Data flag =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr flag -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr flag -&gt; r
$cgmapQl :: forall flag r r'.
Data flag =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTyVarBndr flag -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTyVarBndr flag -&gt; DTyVarBndr flag
$cgmapT :: forall flag.
Data flag =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DTyVarBndr flag -&gt; DTyVarBndr flag
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DTyVarBndr flag))
$cdataCast2 :: forall flag (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DTyVarBndr flag))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DTyVarBndr flag))
$cdataCast1 :: forall flag (t :: * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DTyVarBndr flag))
dataTypeOf :: DTyVarBndr flag -&gt; DataType
$cdataTypeOf :: forall flag. Data flag =&gt; DTyVarBndr flag -&gt; DataType
toConstr :: DTyVarBndr flag -&gt; Constr
$ctoConstr :: forall flag. Data flag =&gt; DTyVarBndr flag -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DTyVarBndr flag)
$cgunfold :: forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DTyVarBndr flag)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr flag -&gt; c (DTyVarBndr flag)
$cgfoldl :: forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTyVarBndr flag -&gt; c (DTyVarBndr flag)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall flag x. Rep (DTyVarBndr flag) x -&gt; DTyVarBndr flag
forall flag x. DTyVarBndr flag -&gt; Rep (DTyVarBndr flag) x
$cto :: forall flag x. Rep (DTyVarBndr flag) x -&gt; DTyVarBndr flag
$cfrom :: forall flag x. DTyVarBndr flag -&gt; Rep (DTyVarBndr flag) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502046"><span id="local-6989586621679502048"><span class="annot"><span class="annottext">forall a b. a -&gt; DTyVarBndr b -&gt; DTyVarBndr a
forall a b. (a -&gt; b) -&gt; DTyVarBndr a -&gt; DTyVarBndr b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; DTyVarBndr b -&gt; DTyVarBndr a
$c&lt;$ :: forall a b. a -&gt; DTyVarBndr b -&gt; DTyVarBndr a
fmap :: forall a b. (a -&gt; b) -&gt; DTyVarBndr a -&gt; DTyVarBndr b
$cfmap :: forall a b. (a -&gt; b) -&gt; DTyVarBndr a -&gt; DTyVarBndr b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>
</span><span id="line-84"></span><span class="hs-comment">-- | Corresponds to TH's @TyVarBndrSpec@</span><span>
</span><span id="line-85"></span><span class="hs-keyword">type</span><span> </span><span id="DTyVarBndrSpec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrSpec"><span class="hs-identifier hs-var">DTyVarBndrSpec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Specificity</span></span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="hs-comment">-- | Corresponds to TH's @TyVarBndrUnit@</span><span>
</span><span id="line-88"></span><span class="hs-keyword">type</span><span> </span><span id="DTyVarBndrUnit"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-var">DTyVarBndrUnit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span class="hs-comment">-- | Corresponds to TH's @Match@ type.</span><span>
</span><span id="line-91"></span><span id="local-6989586621679502042"><span id="local-6989586621679502043"></span></span><span class="hs-keyword">data</span><span> </span><span id="DMatch"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier hs-var">DMatch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DMatch"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier hs-var">DMatch</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679502035"><span id="local-6989586621679502039"><span class="annot"><span class="annottext">DMatch -&gt; DMatch -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DMatch -&gt; DMatch -&gt; Bool
$c/= :: DMatch -&gt; DMatch -&gt; Bool
== :: DMatch -&gt; DMatch -&gt; Bool
$c== :: DMatch -&gt; DMatch -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679502026"><span id="local-6989586621679502028"><span id="local-6989586621679502033"><span class="annot"><span class="annottext">Int -&gt; DMatch -&gt; ShowS
[DMatch] -&gt; ShowS
DMatch -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DMatch] -&gt; ShowS
$cshowList :: [DMatch] -&gt; ShowS
show :: DMatch -&gt; String
$cshow :: DMatch -&gt; String
showsPrec :: Int -&gt; DMatch -&gt; ShowS
$cshowsPrec :: Int -&gt; DMatch -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501992"><span id="local-6989586621679501994"><span id="local-6989586621679501996"><span id="local-6989586621679501998"><span id="local-6989586621679502000"><span id="local-6989586621679502002"><span id="local-6989586621679502004"><span id="local-6989586621679502006"><span id="local-6989586621679502008"><span id="local-6989586621679502010"><span id="local-6989586621679502012"><span id="local-6989586621679502014"><span id="local-6989586621679502018"><span id="local-6989586621679502022"><span class="annot"><span class="annottext">Typeable DMatch
DMatch -&gt; DataType
DMatch -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DMatch -&gt; DMatch
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DMatch)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DMatch)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DMatch -&gt; m DMatch
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DMatch -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DMatch -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DMatch -&gt; DMatch
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DMatch -&gt; DMatch
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DMatch)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DMatch)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DMatch)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DMatch)
dataTypeOf :: DMatch -&gt; DataType
$cdataTypeOf :: DMatch -&gt; DataType
toConstr :: DMatch -&gt; Constr
$ctoConstr :: DMatch -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DMatch
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DMatch -&gt; c DMatch
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DMatch x -&gt; DMatch
forall x. DMatch -&gt; Rep DMatch x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DMatch x -&gt; DMatch
$cfrom :: forall x. DMatch -&gt; Rep DMatch x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="hs-comment">-- | Corresponds to TH's @Clause@ type.</span><span>
</span><span id="line-95"></span><span id="local-6989586621679501987"><span id="local-6989586621679501988"></span></span><span class="hs-keyword">data</span><span> </span><span id="DClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-var">DClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-var">DClause</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-96"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501979"><span id="local-6989586621679501984"><span class="annot"><span class="annottext">DClause -&gt; DClause -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DClause -&gt; DClause -&gt; Bool
$c/= :: DClause -&gt; DClause -&gt; Bool
== :: DClause -&gt; DClause -&gt; Bool
$c== :: DClause -&gt; DClause -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501969"><span id="local-6989586621679501971"><span id="local-6989586621679501977"><span class="annot"><span class="annottext">Int -&gt; DClause -&gt; ShowS
[DClause] -&gt; ShowS
DClause -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DClause] -&gt; ShowS
$cshowList :: [DClause] -&gt; ShowS
show :: DClause -&gt; String
$cshow :: DClause -&gt; String
showsPrec :: Int -&gt; DClause -&gt; ShowS
$cshowsPrec :: Int -&gt; DClause -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501933"><span id="local-6989586621679501935"><span id="local-6989586621679501937"><span id="local-6989586621679501939"><span id="local-6989586621679501941"><span id="local-6989586621679501943"><span id="local-6989586621679501945"><span id="local-6989586621679501947"><span id="local-6989586621679501949"><span id="local-6989586621679501951"><span id="local-6989586621679501953"><span id="local-6989586621679501955"><span id="local-6989586621679501960"><span id="local-6989586621679501965"><span class="annot"><span class="annottext">Typeable DClause
DClause -&gt; DataType
DClause -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DClause -&gt; DClause
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DClause)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DClause)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DClause -&gt; m DClause
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DClause -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DClause -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DClause -&gt; DClause
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DClause -&gt; DClause
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DClause)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DClause)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DClause)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DClause)
dataTypeOf :: DClause -&gt; DataType
$cdataTypeOf :: DClause -&gt; DataType
toConstr :: DClause -&gt; Constr
$ctoConstr :: DClause -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DClause
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DClause -&gt; c DClause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DClause x -&gt; DClause
forall x. DClause -&gt; Rep DClause x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DClause x -&gt; DClause
$cfrom :: forall x. DClause -&gt; Rep DClause x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- | Declarations as used in a @let@ statement.</span><span>
</span><span id="line-99"></span><span id="local-6989586621679501928"><span id="local-6989586621679501929"></span></span><span class="hs-keyword">data</span><span> </span><span id="DLetDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-var">DLetDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DFunD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFunD"><span class="hs-identifier hs-var">DFunD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-type">DClause</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-100"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DValD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DValD"><span class="hs-identifier hs-var">DValD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-101"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigD"><span class="hs-identifier hs-var">DSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-102"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DInfixD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInfixD"><span class="hs-identifier hs-var">DInfixD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-103"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DPragmaD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPragmaD"><span class="hs-identifier hs-var">DPragmaD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPragma"><span class="hs-identifier hs-type">DPragma</span></a></span><span>
</span><span id="line-104"></span><span>             </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501908"><span id="local-6989586621679501921"><span class="annot"><span class="annottext">DLetDec -&gt; DLetDec -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DLetDec -&gt; DLetDec -&gt; Bool
$c/= :: DLetDec -&gt; DLetDec -&gt; Bool
== :: DLetDec -&gt; DLetDec -&gt; Bool
$c== :: DLetDec -&gt; DLetDec -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501886"><span id="local-6989586621679501888"><span id="local-6989586621679501906"><span class="annot"><span class="annottext">Int -&gt; DLetDec -&gt; ShowS
[DLetDec] -&gt; ShowS
DLetDec -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DLetDec] -&gt; ShowS
$cshowList :: [DLetDec] -&gt; ShowS
show :: DLetDec -&gt; String
$cshow :: DLetDec -&gt; String
showsPrec :: Int -&gt; DLetDec -&gt; ShowS
$cshowsPrec :: Int -&gt; DLetDec -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501835"><span id="local-6989586621679501837"><span id="local-6989586621679501839"><span id="local-6989586621679501841"><span id="local-6989586621679501843"><span id="local-6989586621679501845"><span id="local-6989586621679501847"><span id="local-6989586621679501849"><span id="local-6989586621679501851"><span id="local-6989586621679501853"><span id="local-6989586621679501855"><span id="local-6989586621679501857"><span id="local-6989586621679501869"><span id="local-6989586621679501882"><span class="annot"><span class="annottext">Typeable DLetDec
DLetDec -&gt; DataType
DLetDec -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DLetDec -&gt; DLetDec
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DLetDec)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DLetDec)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DLetDec -&gt; m DLetDec
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DLetDec -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DLetDec -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DLetDec -&gt; DLetDec
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DLetDec -&gt; DLetDec
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DLetDec)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DLetDec)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DLetDec)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DLetDec)
dataTypeOf :: DLetDec -&gt; DataType
$cdataTypeOf :: DLetDec -&gt; DataType
toConstr :: DLetDec -&gt; Constr
$ctoConstr :: DLetDec -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DLetDec
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DLetDec -&gt; c DLetDec
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DLetDec x -&gt; DLetDec
forall x. DLetDec -&gt; Rep DLetDec x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DLetDec x -&gt; DLetDec
$cfrom :: forall x. DLetDec -&gt; Rep DLetDec x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span class="hs-comment">-- | Is it a @newtype@ or a @data@ type?</span><span>
</span><span id="line-107"></span><span id="local-6989586621679501830"><span id="local-6989586621679501831"></span></span><span class="hs-keyword">data</span><span> </span><span id="NewOrData"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#NewOrData"><span class="hs-identifier hs-var">NewOrData</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Newtype"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a></span></span><span>
</span><span id="line-108"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="Data"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#Data"><span class="hs-identifier hs-var">Data</span></a></span></span><span>
</span><span id="line-109"></span><span>               </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501824"><span id="local-6989586621679501826"><span class="annot"><span class="annottext">NewOrData -&gt; NewOrData -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: NewOrData -&gt; NewOrData -&gt; Bool
$c/= :: NewOrData -&gt; NewOrData -&gt; Bool
== :: NewOrData -&gt; NewOrData -&gt; Bool
$c== :: NewOrData -&gt; NewOrData -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501818"><span id="local-6989586621679501820"><span id="local-6989586621679501822"><span class="annot"><span class="annottext">Int -&gt; NewOrData -&gt; ShowS
[NewOrData] -&gt; ShowS
NewOrData -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [NewOrData] -&gt; ShowS
$cshowList :: [NewOrData] -&gt; ShowS
show :: NewOrData -&gt; String
$cshow :: NewOrData -&gt; String
showsPrec :: Int -&gt; NewOrData -&gt; ShowS
$cshowsPrec :: Int -&gt; NewOrData -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501788"><span id="local-6989586621679501790"><span id="local-6989586621679501792"><span id="local-6989586621679501794"><span id="local-6989586621679501796"><span id="local-6989586621679501798"><span id="local-6989586621679501800"><span id="local-6989586621679501802"><span id="local-6989586621679501804"><span id="local-6989586621679501806"><span id="local-6989586621679501808"><span id="local-6989586621679501810"><span id="local-6989586621679501812"><span id="local-6989586621679501814"><span class="annot"><span class="annottext">Typeable NewOrData
NewOrData -&gt; DataType
NewOrData -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
dataTypeOf :: NewOrData -&gt; DataType
$cdataTypeOf :: NewOrData -&gt; DataType
toConstr :: NewOrData -&gt; Constr
$ctoConstr :: NewOrData -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep NewOrData x -&gt; NewOrData
forall x. NewOrData -&gt; Rep NewOrData x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep NewOrData x -&gt; NewOrData
$cfrom :: forall x. NewOrData -&gt; Rep NewOrData x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="hs-comment">-- | Corresponds to TH's @Dec@ type.</span><span>
</span><span id="line-112"></span><span id="local-6989586621679501783"><span id="local-6989586621679501784"></span></span><span class="hs-keyword">data</span><span> </span><span id="DDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-var">DDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DLetDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-var">DLetDec</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span>
</span><span id="line-113"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDataD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDataD"><span class="hs-identifier hs-var">DDataD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#NewOrData"><span class="hs-identifier hs-type">NewOrData</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-type">DDerivClause</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-114"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DTySynD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynD"><span class="hs-identifier hs-var">DTySynD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-115"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DClassD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClassD"><span class="hs-identifier hs-var">DClassD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">FunDep</span></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-116"></span><span>            </span><span class="hs-comment">-- | Note that the @Maybe [DTyVarBndrUnit]@ field is dropped</span><span>
</span><span id="line-117"></span><span>            </span><span class="hs-comment">-- entirely when sweetened, so it is only useful for functions</span><span>
</span><span id="line-118"></span><span>            </span><span class="hs-comment">-- that directly consume @DDec@s.</span><span>
</span><span id="line-119"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DInstanceD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInstanceD"><span class="hs-identifier hs-var">DInstanceD</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Overlap</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-120"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DForeignD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForeignD"><span class="hs-identifier hs-var">DForeignD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForeign"><span class="hs-identifier hs-type">DForeign</span></a></span><span>
</span><span id="line-121"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DOpenTypeFamilyD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DOpenTypeFamilyD"><span class="hs-identifier hs-var">DOpenTypeFamilyD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-type">DTypeFamilyHead</span></a></span><span>
</span><span id="line-122"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DClosedTypeFamilyD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClosedTypeFamilyD"><span class="hs-identifier hs-var">DClosedTypeFamilyD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-type">DTypeFamilyHead</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-type">DTySynEqn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-123"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDataFamilyD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDataFamilyD"><span class="hs-identifier hs-var">DDataFamilyD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDataInstD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDataInstD"><span class="hs-identifier hs-var">DDataInstD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#NewOrData"><span class="hs-identifier hs-type">NewOrData</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>                       </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-type">DDerivClause</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-126"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DTySynInstD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynInstD"><span class="hs-identifier hs-var">DTySynInstD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-type">DTySynEqn</span></a></span><span>
</span><span id="line-127"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DRoleAnnotD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRoleAnnotD"><span class="hs-identifier hs-var">DRoleAnnotD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Role</span></span><span class="hs-special">]</span><span>
</span><span id="line-128"></span><span>            </span><span class="hs-comment">-- | Note that the @Maybe [DTyVarBndrUnit]@ field is dropped</span><span>
</span><span id="line-129"></span><span>            </span><span class="hs-comment">-- entirely when sweetened, so it is only useful for functions</span><span>
</span><span id="line-130"></span><span>            </span><span class="hs-comment">-- that directly consume @DDec@s.</span><span>
</span><span id="line-131"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DStandaloneDerivD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DStandaloneDerivD"><span class="hs-identifier hs-var">DStandaloneDerivD</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivStrategy"><span class="hs-identifier hs-type">DDerivStrategy</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-132"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DDefaultSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDefaultSigD"><span class="hs-identifier hs-var">DDefaultSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-133"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DPatSynD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynD"><span class="hs-identifier hs-var">DPatSynD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">PatSynArgs</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynDir"><span class="hs-identifier hs-type">DPatSynDir</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span>
</span><span id="line-134"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DPatSynSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynSigD"><span class="hs-identifier hs-var">DPatSynSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynType"><span class="hs-identifier hs-type">DPatSynType</span></a></span><span>
</span><span id="line-135"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="DKiSigD"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKiSigD"><span class="hs-identifier hs-var">DKiSigD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-136"></span><span>              </span><span class="hs-comment">-- DKiSigD is part of DDec, not DLetDec, because standalone kind</span><span>
</span><span id="line-137"></span><span>              </span><span class="hs-comment">-- signatures can only appear on the top level.</span><span>
</span><span id="line-138"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501697"><span id="local-6989586621679501763"><span class="annot"><span class="annottext">DDec -&gt; DDec -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DDec -&gt; DDec -&gt; Bool
$c/= :: DDec -&gt; DDec -&gt; Bool
== :: DDec -&gt; DDec -&gt; Bool
$c== :: DDec -&gt; DDec -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501606"><span id="local-6989586621679501608"><span id="local-6989586621679501691"><span class="annot"><span class="annottext">Int -&gt; DDec -&gt; ShowS
[DDec] -&gt; ShowS
DDec -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DDec] -&gt; ShowS
$cshowList :: [DDec] -&gt; ShowS
show :: DDec -&gt; String
$cshow :: DDec -&gt; String
showsPrec :: Int -&gt; DDec -&gt; ShowS
$cshowsPrec :: Int -&gt; DDec -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501446"><span id="local-6989586621679501448"><span id="local-6989586621679501450"><span id="local-6989586621679501452"><span id="local-6989586621679501454"><span id="local-6989586621679501456"><span id="local-6989586621679501458"><span id="local-6989586621679501460"><span id="local-6989586621679501462"><span id="local-6989586621679501464"><span id="local-6989586621679501466"><span id="local-6989586621679501468"><span id="local-6989586621679501532"><span id="local-6989586621679501598"><span class="annot"><span class="annottext">Typeable DDec
DDec -&gt; DataType
DDec -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DDec -&gt; DDec
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDec)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DDec)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDec -&gt; m DDec
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDec -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDec -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDec -&gt; DDec
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDec -&gt; DDec
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DDec)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DDec)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDec)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDec)
dataTypeOf :: DDec -&gt; DataType
$cdataTypeOf :: DDec -&gt; DataType
toConstr :: DDec -&gt; Constr
$ctoConstr :: DDec -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDec
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDec -&gt; c DDec
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DDec x -&gt; DDec
forall x. DDec -&gt; Rep DDec x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DDec x -&gt; DDec
$cfrom :: forall x. DDec -&gt; Rep DDec x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt; 711
</span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">Overlap</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Overlappable</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">Overlapping</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">Overlaps</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">Incoherent</span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- | Corresponds to TH's 'PatSynDir' type</span><span>
</span><span id="line-146"></span><span id="local-6989586621679501436"><span id="local-6989586621679501437"></span></span><span class="hs-keyword">data</span><span> </span><span id="DPatSynDir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynDir"><span class="hs-identifier hs-var">DPatSynDir</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DUnidir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DUnidir"><span class="hs-identifier hs-var">DUnidir</span></a></span></span><span>              </span><span class="hs-comment">-- ^ @pattern P x {&lt;-} p@</span><span>
</span><span id="line-147"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="DImplBidir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DImplBidir"><span class="hs-identifier hs-var">DImplBidir</span></a></span></span><span>           </span><span class="hs-comment">-- ^ @pattern P x {=} p@</span><span>
</span><span id="line-148"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="DExplBidir"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExplBidir"><span class="hs-identifier hs-var">DExplBidir</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-type">DClause</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ @pattern P x {&lt;-} p where P x = e@</span><span>
</span><span id="line-149"></span><span>                </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501427"><span id="local-6989586621679501431"><span class="annot"><span class="annottext">DPatSynDir -&gt; DPatSynDir -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
$c/= :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
== :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
$c== :: DPatSynDir -&gt; DPatSynDir -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501418"><span id="local-6989586621679501420"><span id="local-6989586621679501425"><span class="annot"><span class="annottext">Int -&gt; DPatSynDir -&gt; ShowS
[DPatSynDir] -&gt; ShowS
DPatSynDir -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DPatSynDir] -&gt; ShowS
$cshowList :: [DPatSynDir] -&gt; ShowS
show :: DPatSynDir -&gt; String
$cshow :: DPatSynDir -&gt; String
showsPrec :: Int -&gt; DPatSynDir -&gt; ShowS
$cshowsPrec :: Int -&gt; DPatSynDir -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501384"><span id="local-6989586621679501386"><span id="local-6989586621679501388"><span id="local-6989586621679501390"><span id="local-6989586621679501392"><span id="local-6989586621679501394"><span id="local-6989586621679501396"><span id="local-6989586621679501398"><span id="local-6989586621679501400"><span id="local-6989586621679501402"><span id="local-6989586621679501404"><span id="local-6989586621679501406"><span id="local-6989586621679501410"><span id="local-6989586621679501414"><span class="annot"><span class="annottext">Typeable DPatSynDir
DPatSynDir -&gt; DataType
DPatSynDir -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DPatSynDir -&gt; DPatSynDir
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPatSynDir)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPatSynDir)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPatSynDir -&gt; m DPatSynDir
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPatSynDir -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPatSynDir -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPatSynDir -&gt; DPatSynDir
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPatSynDir -&gt; DPatSynDir
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPatSynDir)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPatSynDir)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPatSynDir)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPatSynDir)
dataTypeOf :: DPatSynDir -&gt; DataType
$cdataTypeOf :: DPatSynDir -&gt; DataType
toConstr :: DPatSynDir -&gt; Constr
$ctoConstr :: DPatSynDir -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPatSynDir
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPatSynDir -&gt; c DPatSynDir
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DPatSynDir x -&gt; DPatSynDir
forall x. DPatSynDir -&gt; Rep DPatSynDir x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DPatSynDir x -&gt; DPatSynDir
$cfrom :: forall x. DPatSynDir -&gt; Rep DPatSynDir x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span class="hs-comment">-- | Corresponds to TH's 'PatSynType' type</span><span>
</span><span id="line-152"></span><span class="hs-keyword">type</span><span> </span><span id="DPatSynType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynType"><span class="hs-identifier hs-var">DPatSynType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt; 801
</span><span class="hs-comment">-- | Same as @PatSynArgs@ from TH; defined here for backwards compatibility.</span><span>
</span><span id="line-156"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">PatSynArgs</span><span>
</span><span id="line-157"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">PrefixPatSyn</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Name</span><span class="hs-special">]</span><span>        </span><span class="hs-comment">-- ^ @pattern P {x y z} = p@</span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">InfixPatSyn</span><span> </span><span class="hs-identifier">Name</span><span> </span><span class="hs-identifier">Name</span><span>      </span><span class="hs-comment">-- ^ @pattern {x P y} = p@</span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">RecordPatSyn</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Name</span><span class="hs-special">]</span><span>        </span><span class="hs-comment">-- ^ @pattern P { {x,y,z} } = p@</span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- | Corresponds to TH's 'TypeFamilyHead' type</span><span>
</span><span id="line-164"></span><span id="local-6989586621679501379"><span id="local-6989586621679501380"></span></span><span class="hs-keyword">data</span><span> </span><span id="DTypeFamilyHead"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-var">DTypeFamilyHead</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DTypeFamilyHead"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier hs-var">DTypeFamilyHead</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFamilyResultSig"><span class="hs-identifier hs-type">DFamilyResultSig</span></a></span><span>
</span><span id="line-165"></span><span>                                       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InjectivityAnn</span></span><span class="hs-special">)</span><span>
</span><span id="line-166"></span><span>                     </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501368"><span id="local-6989586621679501376"><span class="annot"><span class="annottext">DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
$c/= :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
== :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
$c== :: DTypeFamilyHead -&gt; DTypeFamilyHead -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501353"><span id="local-6989586621679501355"><span id="local-6989586621679501364"><span class="annot"><span class="annottext">Int -&gt; DTypeFamilyHead -&gt; ShowS
[DTypeFamilyHead] -&gt; ShowS
DTypeFamilyHead -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DTypeFamilyHead] -&gt; ShowS
$cshowList :: [DTypeFamilyHead] -&gt; ShowS
show :: DTypeFamilyHead -&gt; String
$cshow :: DTypeFamilyHead -&gt; String
showsPrec :: Int -&gt; DTypeFamilyHead -&gt; ShowS
$cshowsPrec :: Int -&gt; DTypeFamilyHead -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501309"><span id="local-6989586621679501311"><span id="local-6989586621679501313"><span id="local-6989586621679501315"><span id="local-6989586621679501317"><span id="local-6989586621679501319"><span id="local-6989586621679501321"><span id="local-6989586621679501323"><span id="local-6989586621679501325"><span id="local-6989586621679501327"><span id="local-6989586621679501329"><span id="local-6989586621679501331"><span id="local-6989586621679501339"><span id="local-6989586621679501347"><span class="annot"><span class="annottext">Typeable DTypeFamilyHead
DTypeFamilyHead -&gt; DataType
DTypeFamilyHead -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DTypeFamilyHead -&gt; DTypeFamilyHead
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTypeFamilyHead)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DTypeFamilyHead)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DTypeFamilyHead -&gt; m DTypeFamilyHead
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTypeFamilyHead -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTypeFamilyHead -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTypeFamilyHead -&gt; DTypeFamilyHead
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTypeFamilyHead -&gt; DTypeFamilyHead
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DTypeFamilyHead)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DTypeFamilyHead)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTypeFamilyHead)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTypeFamilyHead)
dataTypeOf :: DTypeFamilyHead -&gt; DataType
$cdataTypeOf :: DTypeFamilyHead -&gt; DataType
toConstr :: DTypeFamilyHead -&gt; Constr
$ctoConstr :: DTypeFamilyHead -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTypeFamilyHead
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTypeFamilyHead -&gt; c DTypeFamilyHead
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DTypeFamilyHead x -&gt; DTypeFamilyHead
forall x. DTypeFamilyHead -&gt; Rep DTypeFamilyHead x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DTypeFamilyHead x -&gt; DTypeFamilyHead
$cfrom :: forall x. DTypeFamilyHead -&gt; Rep DTypeFamilyHead x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span>
</span><span id="line-168"></span><span class="hs-comment">-- | Corresponds to TH's 'FamilyResultSig' type</span><span>
</span><span id="line-169"></span><span id="local-6989586621679501301"><span id="local-6989586621679501302"></span></span><span class="hs-keyword">data</span><span> </span><span id="DFamilyResultSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFamilyResultSig"><span class="hs-identifier hs-var">DFamilyResultSig</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DNoSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DNoSig"><span class="hs-identifier hs-var">DNoSig</span></a></span></span><span>
</span><span id="line-170"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span id="DKindSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKindSig"><span class="hs-identifier hs-var">DKindSig</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-171"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span id="DTyVarSig"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarSig"><span class="hs-identifier hs-var">DTyVarSig</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span>
</span><span id="line-172"></span><span>                      </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501291"><span id="local-6989586621679501296"><span class="annot"><span class="annottext">DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
$c/= :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
== :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
$c== :: DFamilyResultSig -&gt; DFamilyResultSig -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501280"><span id="local-6989586621679501282"><span id="local-6989586621679501289"><span class="annot"><span class="annottext">Int -&gt; DFamilyResultSig -&gt; ShowS
[DFamilyResultSig] -&gt; ShowS
DFamilyResultSig -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DFamilyResultSig] -&gt; ShowS
$cshowList :: [DFamilyResultSig] -&gt; ShowS
show :: DFamilyResultSig -&gt; String
$cshow :: DFamilyResultSig -&gt; String
showsPrec :: Int -&gt; DFamilyResultSig -&gt; ShowS
$cshowsPrec :: Int -&gt; DFamilyResultSig -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501244"><span id="local-6989586621679501246"><span id="local-6989586621679501248"><span id="local-6989586621679501250"><span id="local-6989586621679501252"><span id="local-6989586621679501254"><span id="local-6989586621679501256"><span id="local-6989586621679501258"><span id="local-6989586621679501260"><span id="local-6989586621679501262"><span id="local-6989586621679501264"><span id="local-6989586621679501266"><span id="local-6989586621679501271"><span id="local-6989586621679501276"><span class="annot"><span class="annottext">Typeable DFamilyResultSig
DFamilyResultSig -&gt; DataType
DFamilyResultSig -&gt; Constr
(forall b. Data b =&gt; b -&gt; b)
-&gt; DFamilyResultSig -&gt; DFamilyResultSig
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DFamilyResultSig)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DFamilyResultSig)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DFamilyResultSig -&gt; m DFamilyResultSig
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DFamilyResultSig -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DFamilyResultSig -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DFamilyResultSig -&gt; DFamilyResultSig
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DFamilyResultSig -&gt; DFamilyResultSig
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DFamilyResultSig)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DFamilyResultSig)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DFamilyResultSig)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DFamilyResultSig)
dataTypeOf :: DFamilyResultSig -&gt; DataType
$cdataTypeOf :: DFamilyResultSig -&gt; DataType
toConstr :: DFamilyResultSig -&gt; Constr
$ctoConstr :: DFamilyResultSig -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DFamilyResultSig
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DFamilyResultSig -&gt; c DFamilyResultSig
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DFamilyResultSig x -&gt; DFamilyResultSig
forall x. DFamilyResultSig -&gt; Rep DFamilyResultSig x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DFamilyResultSig x -&gt; DFamilyResultSig
$cfrom :: forall x. DFamilyResultSig -&gt; Rep DFamilyResultSig x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt;= 710
</span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">InjectivityAnn</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">InjectivityAnn</span><span> </span><span class="hs-identifier">Name</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Name</span><span class="hs-special">]</span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- | Corresponds to TH's 'Con' type. Unlike 'Con', all 'DCon's reflect GADT</span><span>
</span><span id="line-180"></span><span class="hs-comment">-- syntax. This is beneficial for @th-desugar@'s since it means</span><span>
</span><span id="line-181"></span><span class="hs-comment">-- that all data type declarations can support explicit return kinds, so</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- one does not need to represent them with something like @'Maybe' 'DKind'@,</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- since Haskell98-style data declaration syntax isn't used. Accordingly,</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- there are some differences between 'DCon' and 'Con' to keep in mind:</span><span>
</span><span id="line-185"></span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- * Unlike 'ForallC', where the meaning of the 'TyVarBndr's changes depending</span><span>
</span><span id="line-187"></span><span class="hs-comment">--   on whether it's followed by 'GadtC'/'RecGadtC' or not, the meaning of the</span><span>
</span><span id="line-188"></span><span class="hs-comment">--   'DTyVarBndr's in a 'DCon' is always the same: it is the list of</span><span>
</span><span id="line-189"></span><span class="hs-comment">--   universally /and/ existentially quantified type variables. Note that it is</span><span>
</span><span id="line-190"></span><span class="hs-comment">--   not guaranteed that one set of type variables will appear before the</span><span>
</span><span id="line-191"></span><span class="hs-comment">--   other.</span><span>
</span><span id="line-192"></span><span class="hs-comment">--</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- * A 'DCon' always has an explicit return type.</span><span>
</span><span id="line-194"></span><span id="local-6989586621679501239"><span id="local-6989586621679501240"></span></span><span class="hs-keyword">data</span><span> </span><span id="DCon"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-var">DCon</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DCon"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-var">DCon</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrSpec"><span class="hs-identifier hs-type">DTyVarBndrSpec</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConFields"><span class="hs-identifier hs-type">DConFields</span></a></span><span>
</span><span id="line-195"></span><span>                 </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>  </span><span class="hs-comment">-- ^ The GADT result type</span><span>
</span><span id="line-196"></span><span>          </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501227"><span id="local-6989586621679501236"><span class="annot"><span class="annottext">DCon -&gt; DCon -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DCon -&gt; DCon -&gt; Bool
$c/= :: DCon -&gt; DCon -&gt; Bool
== :: DCon -&gt; DCon -&gt; Bool
$c== :: DCon -&gt; DCon -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501212"><span id="local-6989586621679501214"><span id="local-6989586621679501224"><span class="annot"><span class="annottext">Int -&gt; DCon -&gt; ShowS
[DCon] -&gt; ShowS
DCon -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DCon] -&gt; ShowS
$cshowList :: [DCon] -&gt; ShowS
show :: DCon -&gt; String
$cshow :: DCon -&gt; String
showsPrec :: Int -&gt; DCon -&gt; ShowS
$cshowsPrec :: Int -&gt; DCon -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501169"><span id="local-6989586621679501171"><span id="local-6989586621679501173"><span id="local-6989586621679501175"><span id="local-6989586621679501177"><span id="local-6989586621679501179"><span id="local-6989586621679501181"><span id="local-6989586621679501183"><span id="local-6989586621679501185"><span id="local-6989586621679501187"><span id="local-6989586621679501189"><span id="local-6989586621679501191"><span id="local-6989586621679501199"><span id="local-6989586621679501207"><span class="annot"><span class="annottext">Typeable DCon
DCon -&gt; DataType
DCon -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DCon -&gt; DCon
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DCon)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DCon)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DCon -&gt; m DCon
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DCon -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DCon -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DCon -&gt; DCon
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DCon -&gt; DCon
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DCon)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DCon)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DCon)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DCon)
dataTypeOf :: DCon -&gt; DataType
$cdataTypeOf :: DCon -&gt; DataType
toConstr :: DCon -&gt; Constr
$ctoConstr :: DCon -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DCon
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DCon -&gt; c DCon
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DCon x -&gt; DCon
forall x. DCon -&gt; Rep DCon x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DCon x -&gt; DCon
$cfrom :: forall x. DCon -&gt; Rep DCon x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-197"></span><span>
</span><span id="line-198"></span><span class="hs-comment">-- | A list of fields either for a standard data constructor or a record</span><span>
</span><span id="line-199"></span><span class="hs-comment">-- data constructor.</span><span>
</span><span id="line-200"></span><span id="local-6989586621679501162"><span id="local-6989586621679501163"></span></span><span class="hs-keyword">data</span><span> </span><span id="DConFields"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConFields"><span class="hs-identifier hs-var">DConFields</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DNormalC"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DNormalC"><span class="hs-identifier hs-var">DNormalC</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDeclaredInfix"><span class="hs-identifier hs-type">DDeclaredInfix</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangType"><span class="hs-identifier hs-type">DBangType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-201"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="DRecC"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRecC"><span class="hs-identifier hs-var">DRecC</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarBangType"><span class="hs-identifier hs-type">DVarBangType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-202"></span><span>                </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501149"><span id="local-6989586621679501157"><span class="annot"><span class="annottext">DConFields -&gt; DConFields -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DConFields -&gt; DConFields -&gt; Bool
$c/= :: DConFields -&gt; DConFields -&gt; Bool
== :: DConFields -&gt; DConFields -&gt; Bool
$c== :: DConFields -&gt; DConFields -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501129"><span id="local-6989586621679501131"><span id="local-6989586621679501141"><span class="annot"><span class="annottext">Int -&gt; DConFields -&gt; ShowS
[DConFields] -&gt; ShowS
DConFields -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DConFields] -&gt; ShowS
$cshowList :: [DConFields] -&gt; ShowS
show :: DConFields -&gt; String
$cshow :: DConFields -&gt; String
showsPrec :: Int -&gt; DConFields -&gt; ShowS
$cshowsPrec :: Int -&gt; DConFields -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501082"><span id="local-6989586621679501084"><span id="local-6989586621679501086"><span id="local-6989586621679501088"><span id="local-6989586621679501090"><span id="local-6989586621679501092"><span id="local-6989586621679501094"><span id="local-6989586621679501096"><span id="local-6989586621679501098"><span id="local-6989586621679501100"><span id="local-6989586621679501102"><span id="local-6989586621679501104"><span id="local-6989586621679501111"><span id="local-6989586621679501119"><span class="annot"><span class="annottext">Typeable DConFields
DConFields -&gt; DataType
DConFields -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DConFields -&gt; DConFields
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DConFields)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DConFields)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DConFields -&gt; m DConFields
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DConFields -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DConFields -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DConFields -&gt; DConFields
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DConFields -&gt; DConFields
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DConFields)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DConFields)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DConFields)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DConFields)
dataTypeOf :: DConFields -&gt; DataType
$cdataTypeOf :: DConFields -&gt; DataType
toConstr :: DConFields -&gt; Constr
$ctoConstr :: DConFields -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DConFields
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DConFields -&gt; c DConFields
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DConFields x -&gt; DConFields
forall x. DConFields -&gt; Rep DConFields x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DConFields x -&gt; DConFields
$cfrom :: forall x. DConFields -&gt; Rep DConFields x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-203"></span><span>
</span><span id="line-204"></span><span class="hs-comment">-- | 'True' if a constructor is declared infix. For normal ADTs, this means</span><span>
</span><span id="line-205"></span><span class="hs-comment">-- that is was written in infix style. For example, both of the constructors</span><span>
</span><span id="line-206"></span><span class="hs-comment">-- below are declared infix.</span><span>
</span><span id="line-207"></span><span class="hs-comment">--</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- data Infix = Int `Infix` Int | Int :*: Int</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-211"></span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- Whereas neither of these constructors are declared infix:</span><span>
</span><span id="line-213"></span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- data Prefix = Prefix Int Int | (:+:) Int Int</span><span>
</span><span id="line-216"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-217"></span><span class="hs-comment">--</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- For GADTs, detecting whether a constructor is declared infix is a bit</span><span>
</span><span id="line-219"></span><span class="hs-comment">-- trickier, as one cannot write a GADT constructor &quot;infix-style&quot; like one</span><span>
</span><span id="line-220"></span><span class="hs-comment">-- can for normal ADT constructors. GHC considers a GADT constructor to be</span><span>
</span><span id="line-221"></span><span class="hs-comment">-- declared infix if it meets the following three criteria:</span><span>
</span><span id="line-222"></span><span class="hs-comment">--</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- 1. Its name uses operator syntax (e.g., @(:*:)@).</span><span>
</span><span id="line-224"></span><span class="hs-comment">-- 2. It has exactly two fields (without record syntax).</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- 3. It has a programmer-specified fixity declaration.</span><span>
</span><span id="line-226"></span><span class="hs-comment">--</span><span>
</span><span id="line-227"></span><span class="hs-comment">-- For example, in the following GADT:</span><span>
</span><span id="line-228"></span><span class="hs-comment">--</span><span>
</span><span id="line-229"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-230"></span><span class="hs-comment">-- infixl 5 :**:, :&amp;&amp;:, :^^:, `ActuallyPrefix`</span><span>
</span><span id="line-231"></span><span class="hs-comment">-- data InfixGADT a where</span><span>
</span><span id="line-232"></span><span class="hs-comment">--   (:**:) :: Int -&gt; b -&gt; InfixGADT (Maybe b) -- Only this one is infix</span><span>
</span><span id="line-233"></span><span class="hs-comment">--   ActuallyPrefix :: Char -&gt; Bool -&gt; InfixGADT Double</span><span>
</span><span id="line-234"></span><span class="hs-comment">--   (:&amp;&amp;:) :: { infixGADT1 :: b, infixGADT2 :: Int } -&gt; InfixGADT [b]</span><span>
</span><span id="line-235"></span><span class="hs-comment">--   (:^^:) :: Int -&gt; Int -&gt; Int -&gt; InfixGADT Int</span><span>
</span><span id="line-236"></span><span class="hs-comment">--   (:!!:) :: Char -&gt; Char -&gt; InfixGADT Char</span><span>
</span><span id="line-237"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-238"></span><span class="hs-comment">--</span><span>
</span><span id="line-239"></span><span class="hs-comment">-- Only the @(:**:)@ constructor is declared infix. The other constructors</span><span>
</span><span id="line-240"></span><span class="hs-comment">-- are not declared infix, because:</span><span>
</span><span id="line-241"></span><span class="hs-comment">--</span><span>
</span><span id="line-242"></span><span class="hs-comment">-- * @ActuallyPrefix@ does not use operator syntax (criterion 1).</span><span>
</span><span id="line-243"></span><span class="hs-comment">-- * @(:&amp;&amp;:)@ uses record syntax (criterion 2).</span><span>
</span><span id="line-244"></span><span class="hs-comment">-- * @(:^^:)@ does not have exactly two fields (criterion 2).</span><span>
</span><span id="line-245"></span><span class="hs-comment">-- * @(:!!:)@ does not have a programmer-specified fixity declaration (criterion 3).</span><span>
</span><span id="line-246"></span><span class="hs-keyword">type</span><span> </span><span id="DDeclaredInfix"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDeclaredInfix"><span class="hs-identifier hs-var">DDeclaredInfix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span class="hs-comment">-- | Corresponds to TH's @BangType@ type.</span><span>
</span><span id="line-249"></span><span class="hs-keyword">type</span><span> </span><span id="DBangType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangType"><span class="hs-identifier hs-var">DBangType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span class="hs-comment">-- | Corresponds to TH's @VarBangType@ type.</span><span>
</span><span id="line-252"></span><span class="hs-keyword">type</span><span> </span><span id="DVarBangType"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarBangType"><span class="hs-identifier hs-var">DVarBangType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span class="hs-special">)</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt;= 710
</span><span class="hs-comment">-- | Corresponds to TH's definition</span><span>
</span><span id="line-256"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">SourceUnpackedness</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">NoSourceUnpackedness</span><span>
</span><span id="line-257"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceNoUnpack</span><span>
</span><span id="line-258"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceUnpack</span><span>
</span><span id="line-259"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>
</span><span id="line-261"></span><span class="hs-comment">-- | Corresponds to TH's definition</span><span>
</span><span id="line-262"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">SourceStrictness</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">NoSourceStrictness</span><span>
</span><span id="line-263"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceLazy</span><span>
</span><span id="line-264"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">SourceStrict</span><span>
</span><span id="line-265"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span class="hs-comment">-- | Corresponds to TH's definition</span><span>
</span><span id="line-268"></span><span class="hs-keyword">data</span><span> </span><span class="hs-identifier">Bang</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Bang</span><span> </span><span class="hs-identifier">SourceUnpackedness</span><span> </span><span class="hs-identifier">SourceStrictness</span><span>
</span><span id="line-269"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Data</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Generic</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-272"></span><span class="hs-comment">-- | Corresponds to TH's @Foreign@ type.</span><span>
</span><span id="line-273"></span><span id="local-6989586621679501068"><span id="local-6989586621679501069"></span></span><span class="hs-keyword">data</span><span> </span><span id="DForeign"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForeign"><span class="hs-identifier hs-var">DForeign</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DImportF"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DImportF"><span class="hs-identifier hs-var">DImportF</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Callconv</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Safety</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-274"></span><span>              </span><span class="hs-glyph">|</span><span> </span><span id="DExportF"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExportF"><span class="hs-identifier hs-var">DExportF</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Callconv</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-275"></span><span>              </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679501050"><span id="local-6989586621679501064"><span class="annot"><span class="annottext">DForeign -&gt; DForeign -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DForeign -&gt; DForeign -&gt; Bool
$c/= :: DForeign -&gt; DForeign -&gt; Bool
== :: DForeign -&gt; DForeign -&gt; Bool
$c== :: DForeign -&gt; DForeign -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679501029"><span id="local-6989586621679501031"><span id="local-6989586621679501047"><span class="annot"><span class="annottext">Int -&gt; DForeign -&gt; ShowS
[DForeign] -&gt; ShowS
DForeign -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DForeign] -&gt; ShowS
$cshowList :: [DForeign] -&gt; ShowS
show :: DForeign -&gt; String
$cshow :: DForeign -&gt; String
showsPrec :: Int -&gt; DForeign -&gt; ShowS
$cshowsPrec :: Int -&gt; DForeign -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500976"><span id="local-6989586621679500978"><span id="local-6989586621679500980"><span id="local-6989586621679500982"><span id="local-6989586621679500984"><span id="local-6989586621679500986"><span id="local-6989586621679500988"><span id="local-6989586621679500990"><span id="local-6989586621679500992"><span id="local-6989586621679500994"><span id="local-6989586621679500996"><span id="local-6989586621679500998"><span id="local-6989586621679501010"><span id="local-6989586621679501024"><span class="annot"><span class="annottext">Typeable DForeign
DForeign -&gt; DataType
DForeign -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DForeign -&gt; DForeign
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForeign)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DForeign)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DForeign -&gt; m DForeign
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DForeign -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DForeign -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DForeign -&gt; DForeign
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DForeign -&gt; DForeign
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DForeign)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DForeign)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForeign)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DForeign)
dataTypeOf :: DForeign -&gt; DataType
$cdataTypeOf :: DForeign -&gt; DataType
toConstr :: DForeign -&gt; Constr
$ctoConstr :: DForeign -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DForeign
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DForeign -&gt; c DForeign
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DForeign x -&gt; DForeign
forall x. DForeign -&gt; Rep DForeign x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DForeign x -&gt; DForeign
$cfrom :: forall x. DForeign -&gt; Rep DForeign x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-276"></span><span>
</span><span id="line-277"></span><span class="hs-comment">-- | Corresponds to TH's @Pragma@ type.</span><span>
</span><span id="line-278"></span><span id="local-6989586621679500970"><span id="local-6989586621679500971"></span></span><span class="hs-keyword">data</span><span> </span><span id="DPragma"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPragma"><span class="hs-identifier hs-var">DPragma</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DInlineP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInlineP"><span class="hs-identifier hs-var">DInlineP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Inline</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuleMatch</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Phases</span></span><span>
</span><span id="line-279"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DSpecialiseP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSpecialiseP"><span class="hs-identifier hs-var">DSpecialiseP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Inline</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Phases</span></span><span>
</span><span id="line-280"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DSpecialiseInstP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSpecialiseInstP"><span class="hs-identifier hs-var">DSpecialiseInstP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-281"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DRuleP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleP"><span class="hs-identifier hs-var">DRuleP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleBndr"><span class="hs-identifier hs-type">DRuleBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Phases</span></span><span>
</span><span id="line-282"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DAnnP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAnnP"><span class="hs-identifier hs-var">DAnnP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">AnnTarget</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span>
</span><span id="line-283"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DLineP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLineP"><span class="hs-identifier hs-var">DLineP</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-284"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DCompleteP"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCompleteP"><span class="hs-identifier hs-var">DCompleteP</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-285"></span><span>             </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679500930"><span id="local-6989586621679500961"><span class="annot"><span class="annottext">DPragma -&gt; DPragma -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DPragma -&gt; DPragma -&gt; Bool
$c/= :: DPragma -&gt; DPragma -&gt; Bool
== :: DPragma -&gt; DPragma -&gt; Bool
$c== :: DPragma -&gt; DPragma -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500886"><span id="local-6989586621679500888"><span id="local-6989586621679500926"><span class="annot"><span class="annottext">Int -&gt; DPragma -&gt; ShowS
[DPragma] -&gt; ShowS
DPragma -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DPragma] -&gt; ShowS
$cshowList :: [DPragma] -&gt; ShowS
show :: DPragma -&gt; String
$cshow :: DPragma -&gt; String
showsPrec :: Int -&gt; DPragma -&gt; ShowS
$cshowsPrec :: Int -&gt; DPragma -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500801"><span id="local-6989586621679500803"><span id="local-6989586621679500805"><span id="local-6989586621679500807"><span id="local-6989586621679500809"><span id="local-6989586621679500811"><span id="local-6989586621679500813"><span id="local-6989586621679500815"><span id="local-6989586621679500817"><span id="local-6989586621679500819"><span id="local-6989586621679500821"><span id="local-6989586621679500823"><span id="local-6989586621679500849"><span id="local-6989586621679500880"><span class="annot"><span class="annottext">Typeable DPragma
DPragma -&gt; DataType
DPragma -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DPragma -&gt; DPragma
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPragma)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPragma)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DPragma -&gt; m DPragma
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DPragma -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DPragma -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPragma -&gt; DPragma
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DPragma -&gt; DPragma
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPragma)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DPragma)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPragma)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DPragma)
dataTypeOf :: DPragma -&gt; DataType
$cdataTypeOf :: DPragma -&gt; DataType
toConstr :: DPragma -&gt; Constr
$ctoConstr :: DPragma -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DPragma
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DPragma -&gt; c DPragma
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DPragma x -&gt; DPragma
forall x. DPragma -&gt; Rep DPragma x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DPragma x -&gt; DPragma
$cfrom :: forall x. DPragma -&gt; Rep DPragma x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-286"></span><span>
</span><span id="line-287"></span><span class="hs-comment">-- | Corresponds to TH's @RuleBndr@ type.</span><span>
</span><span id="line-288"></span><span id="local-6989586621679500792"><span id="local-6989586621679500793"></span></span><span class="hs-keyword">data</span><span> </span><span id="DRuleBndr"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleBndr"><span class="hs-identifier hs-var">DRuleBndr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DRuleVar"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleVar"><span class="hs-identifier hs-var">DRuleVar</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-289"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="DTypedRuleVar"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypedRuleVar"><span class="hs-identifier hs-var">DTypedRuleVar</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-290"></span><span>               </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679500783"><span id="local-6989586621679500788"><span class="annot"><span class="annottext">DRuleBndr -&gt; DRuleBndr -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
$c/= :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
== :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
$c== :: DRuleBndr -&gt; DRuleBndr -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500772"><span id="local-6989586621679500774"><span id="local-6989586621679500781"><span class="annot"><span class="annottext">Int -&gt; DRuleBndr -&gt; ShowS
[DRuleBndr] -&gt; ShowS
DRuleBndr -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DRuleBndr] -&gt; ShowS
$cshowList :: [DRuleBndr] -&gt; ShowS
show :: DRuleBndr -&gt; String
$cshow :: DRuleBndr -&gt; String
showsPrec :: Int -&gt; DRuleBndr -&gt; ShowS
$cshowsPrec :: Int -&gt; DRuleBndr -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500736"><span id="local-6989586621679500738"><span id="local-6989586621679500740"><span id="local-6989586621679500742"><span id="local-6989586621679500744"><span id="local-6989586621679500746"><span id="local-6989586621679500748"><span id="local-6989586621679500750"><span id="local-6989586621679500752"><span id="local-6989586621679500754"><span id="local-6989586621679500756"><span id="local-6989586621679500758"><span id="local-6989586621679500763"><span id="local-6989586621679500768"><span class="annot"><span class="annottext">Typeable DRuleBndr
DRuleBndr -&gt; DataType
DRuleBndr -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DRuleBndr -&gt; DRuleBndr
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DRuleBndr)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DRuleBndr)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DRuleBndr -&gt; m DRuleBndr
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DRuleBndr -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DRuleBndr -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DRuleBndr -&gt; DRuleBndr
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DRuleBndr -&gt; DRuleBndr
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DRuleBndr)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DRuleBndr)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DRuleBndr)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DRuleBndr)
dataTypeOf :: DRuleBndr -&gt; DataType
$cdataTypeOf :: DRuleBndr -&gt; DataType
toConstr :: DRuleBndr -&gt; Constr
$ctoConstr :: DRuleBndr -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DRuleBndr
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DRuleBndr -&gt; c DRuleBndr
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DRuleBndr x -&gt; DRuleBndr
forall x. DRuleBndr -&gt; Rep DRuleBndr x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DRuleBndr x -&gt; DRuleBndr
$cfrom :: forall x. DRuleBndr -&gt; Rep DRuleBndr x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>
</span><span id="line-292"></span><span class="hs-comment">-- | Corresponds to TH's @TySynEqn@ type (to store type family equations).</span><span>
</span><span id="line-293"></span><span id="local-6989586621679500731"><span id="local-6989586621679500732"></span></span><span class="hs-keyword">data</span><span> </span><span id="DTySynEqn"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-var">DTySynEqn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DTySynEqn"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier hs-var">DTySynEqn</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndrUnit"><span class="hs-identifier hs-type">DTyVarBndrUnit</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>
</span><span id="line-294"></span><span>               </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679500722"><span id="local-6989586621679500728"><span class="annot"><span class="annottext">DTySynEqn -&gt; DTySynEqn -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
$c/= :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
== :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
$c== :: DTySynEqn -&gt; DTySynEqn -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500709"><span id="local-6989586621679500711"><span id="local-6989586621679500718"><span class="annot"><span class="annottext">Int -&gt; DTySynEqn -&gt; ShowS
[DTySynEqn] -&gt; ShowS
DTySynEqn -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DTySynEqn] -&gt; ShowS
$cshowList :: [DTySynEqn] -&gt; ShowS
show :: DTySynEqn -&gt; String
$cshow :: DTySynEqn -&gt; String
showsPrec :: Int -&gt; DTySynEqn -&gt; ShowS
$cshowsPrec :: Int -&gt; DTySynEqn -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500669"><span id="local-6989586621679500671"><span id="local-6989586621679500673"><span id="local-6989586621679500675"><span id="local-6989586621679500677"><span id="local-6989586621679500679"><span id="local-6989586621679500681"><span id="local-6989586621679500683"><span id="local-6989586621679500685"><span id="local-6989586621679500687"><span id="local-6989586621679500689"><span id="local-6989586621679500691"><span id="local-6989586621679500697"><span id="local-6989586621679500703"><span class="annot"><span class="annottext">Typeable DTySynEqn
DTySynEqn -&gt; DataType
DTySynEqn -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DTySynEqn -&gt; DTySynEqn
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTySynEqn)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTySynEqn)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DTySynEqn -&gt; m DTySynEqn
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DTySynEqn -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DTySynEqn -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTySynEqn -&gt; DTySynEqn
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DTySynEqn -&gt; DTySynEqn
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTySynEqn)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DTySynEqn)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTySynEqn)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DTySynEqn)
dataTypeOf :: DTySynEqn -&gt; DataType
$cdataTypeOf :: DTySynEqn -&gt; DataType
toConstr :: DTySynEqn -&gt; Constr
$ctoConstr :: DTySynEqn -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DTySynEqn
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DTySynEqn -&gt; c DTySynEqn
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DTySynEqn x -&gt; DTySynEqn
forall x. DTySynEqn -&gt; Rep DTySynEqn x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DTySynEqn x -&gt; DTySynEqn
$cfrom :: forall x. DTySynEqn -&gt; Rep DTySynEqn x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-295"></span><span>
</span><span id="line-296"></span><span class="hs-comment">-- | Corresponds to TH's @Info@ type.</span><span>
</span><span id="line-297"></span><span id="local-6989586621679500660"><span id="local-6989586621679500661"></span></span><span class="hs-keyword">data</span><span> </span><span id="DInfo"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInfo"><span class="hs-identifier hs-var">DInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DTyConI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyConI"><span class="hs-identifier hs-var">DTyConI</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInstanceDec"><span class="hs-identifier hs-type">DInstanceDec</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-298"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DVarI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarI"><span class="hs-identifier hs-var">DVarI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-299"></span><span>               </span><span class="hs-comment">-- ^ The @Maybe Name@ stores the name of the enclosing definition</span><span>
</span><span id="line-300"></span><span>               </span><span class="hs-comment">-- (datatype, for a data constructor; class, for a method),</span><span>
</span><span id="line-301"></span><span>               </span><span class="hs-comment">-- if any</span><span>
</span><span id="line-302"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DTyVarI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarI"><span class="hs-identifier hs-var">DTyVarI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span>
</span><span id="line-303"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DPrimTyConI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPrimTyConI"><span class="hs-identifier hs-var">DPrimTyConI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-304"></span><span>               </span><span class="hs-comment">-- ^ The @Int@ is the arity; the @Bool@ is whether this tycon</span><span>
</span><span id="line-305"></span><span>               </span><span class="hs-comment">-- is unlifted.</span><span>
</span><span id="line-306"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="DPatSynI"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynI"><span class="hs-identifier hs-var">DPatSynI</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynType"><span class="hs-identifier hs-type">DPatSynType</span></a></span><span>
</span><span id="line-307"></span><span>           </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679500637"><span id="local-6989586621679500652"><span class="annot"><span class="annottext">DInfo -&gt; DInfo -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DInfo -&gt; DInfo -&gt; Bool
$c/= :: DInfo -&gt; DInfo -&gt; Bool
== :: DInfo -&gt; DInfo -&gt; Bool
$c== :: DInfo -&gt; DInfo -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500613"><span id="local-6989586621679500615"><span id="local-6989586621679500635"><span class="annot"><span class="annottext">Int -&gt; DInfo -&gt; ShowS
[DInfo] -&gt; ShowS
DInfo -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DInfo] -&gt; ShowS
$cshowList :: [DInfo] -&gt; ShowS
show :: DInfo -&gt; String
$cshow :: DInfo -&gt; String
showsPrec :: Int -&gt; DInfo -&gt; ShowS
$cshowsPrec :: Int -&gt; DInfo -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500553"><span id="local-6989586621679500555"><span id="local-6989586621679500557"><span id="local-6989586621679500559"><span id="local-6989586621679500561"><span id="local-6989586621679500563"><span id="local-6989586621679500565"><span id="local-6989586621679500567"><span id="local-6989586621679500569"><span id="local-6989586621679500571"><span id="local-6989586621679500573"><span id="local-6989586621679500575"><span id="local-6989586621679500592"><span id="local-6989586621679500609"><span class="annot"><span class="annottext">Typeable DInfo
DInfo -&gt; DataType
DInfo -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DInfo -&gt; DInfo
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DInfo)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DInfo)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DInfo -&gt; m DInfo
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DInfo -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DInfo -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DInfo -&gt; DInfo
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DInfo -&gt; DInfo
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DInfo)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DInfo)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DInfo)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DInfo)
dataTypeOf :: DInfo -&gt; DataType
$cdataTypeOf :: DInfo -&gt; DataType
toConstr :: DInfo -&gt; Constr
$ctoConstr :: DInfo -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DInfo
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DInfo -&gt; c DInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DInfo x -&gt; DInfo
forall x. DInfo -&gt; Rep DInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DInfo x -&gt; DInfo
$cfrom :: forall x. DInfo -&gt; Rep DInfo x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span>
</span><span id="line-309"></span><span class="hs-keyword">type</span><span> </span><span id="DInstanceDec"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInstanceDec"><span class="hs-identifier hs-var">DInstanceDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span> </span><span class="hs-comment">-- ^ Guaranteed to be an instance declaration</span><span>
</span><span id="line-310"></span><span>
</span><span id="line-311"></span><span class="hs-comment">-- | Corresponds to TH's @DerivClause@ type.</span><span>
</span><span id="line-312"></span><span id="local-6989586621679500548"><span id="local-6989586621679500549"></span></span><span class="hs-keyword">data</span><span> </span><span id="DDerivClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-var">DDerivClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DDerivClause"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier hs-var">DDerivClause</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivStrategy"><span class="hs-identifier hs-type">DDerivStrategy</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span>
</span><span id="line-313"></span><span>                  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679500539"><span id="local-6989586621679500545"><span class="annot"><span class="annottext">DDerivClause -&gt; DDerivClause -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DDerivClause -&gt; DDerivClause -&gt; Bool
$c/= :: DDerivClause -&gt; DDerivClause -&gt; Bool
== :: DDerivClause -&gt; DDerivClause -&gt; Bool
$c== :: DDerivClause -&gt; DDerivClause -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500528"><span id="local-6989586621679500530"><span id="local-6989586621679500537"><span class="annot"><span class="annottext">Int -&gt; DDerivClause -&gt; ShowS
[DDerivClause] -&gt; ShowS
DDerivClause -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DDerivClause] -&gt; ShowS
$cshowList :: [DDerivClause] -&gt; ShowS
show :: DDerivClause -&gt; String
$cshow :: DDerivClause -&gt; String
showsPrec :: Int -&gt; DDerivClause -&gt; ShowS
$cshowsPrec :: Int -&gt; DDerivClause -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500490"><span id="local-6989586621679500492"><span id="local-6989586621679500494"><span id="local-6989586621679500496"><span id="local-6989586621679500498"><span id="local-6989586621679500500"><span id="local-6989586621679500502"><span id="local-6989586621679500504"><span id="local-6989586621679500506"><span id="local-6989586621679500508"><span id="local-6989586621679500510"><span id="local-6989586621679500512"><span id="local-6989586621679500518"><span id="local-6989586621679500524"><span class="annot"><span class="annottext">Typeable DDerivClause
DDerivClause -&gt; DataType
DDerivClause -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DDerivClause -&gt; DDerivClause
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivClause)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivClause)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DDerivClause -&gt; m DDerivClause
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivClause -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivClause -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivClause -&gt; DDerivClause
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivClause -&gt; DDerivClause
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivClause)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivClause)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivClause)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivClause)
dataTypeOf :: DDerivClause -&gt; DataType
$cdataTypeOf :: DDerivClause -&gt; DataType
toConstr :: DDerivClause -&gt; Constr
$ctoConstr :: DDerivClause -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivClause
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivClause -&gt; c DDerivClause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DDerivClause x -&gt; DDerivClause
forall x. DDerivClause -&gt; Rep DDerivClause x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DDerivClause x -&gt; DDerivClause
$cfrom :: forall x. DDerivClause -&gt; Rep DDerivClause x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-314"></span><span>
</span><span id="line-315"></span><span class="hs-comment">-- | Corresponds to TH's @DerivStrategy@ type.</span><span>
</span><span id="line-316"></span><span id="local-6989586621679500485"><span id="local-6989586621679500486"></span></span><span class="hs-keyword">data</span><span> </span><span id="DDerivStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivStrategy"><span class="hs-identifier hs-var">DDerivStrategy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DStockStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DStockStrategy"><span class="hs-identifier hs-var">DStockStrategy</span></a></span></span><span>     </span><span class="hs-comment">-- ^ A \&quot;standard\&quot; derived instance</span><span>
</span><span id="line-317"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="DAnyclassStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DAnyclassStrategy"><span class="hs-identifier hs-var">DAnyclassStrategy</span></a></span></span><span>  </span><span class="hs-comment">-- ^ @-XDeriveAnyClass@</span><span>
</span><span id="line-318"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="DNewtypeStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DNewtypeStrategy"><span class="hs-identifier hs-var">DNewtypeStrategy</span></a></span></span><span>   </span><span class="hs-comment">-- ^ @-XGeneralizedNewtypeDeriving@</span><span>
</span><span id="line-319"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="DViaStrategy"><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DViaStrategy"><span class="hs-identifier hs-var">DViaStrategy</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-comment">-- ^ @-XDerivingVia@</span><span>
</span><span id="line-320"></span><span>                    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679500476"><span id="local-6989586621679500479"><span class="annot"><span class="annottext">DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
$c/= :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
== :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
$c== :: DDerivStrategy -&gt; DDerivStrategy -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500468"><span id="local-6989586621679500470"><span id="local-6989586621679500474"><span class="annot"><span class="annottext">Int -&gt; DDerivStrategy -&gt; ShowS
[DDerivStrategy] -&gt; ShowS
DDerivStrategy -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DDerivStrategy] -&gt; ShowS
$cshowList :: [DDerivStrategy] -&gt; ShowS
show :: DDerivStrategy -&gt; String
$cshow :: DDerivStrategy -&gt; String
showsPrec :: Int -&gt; DDerivStrategy -&gt; ShowS
$cshowsPrec :: Int -&gt; DDerivStrategy -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679500436"><span id="local-6989586621679500438"><span id="local-6989586621679500440"><span id="local-6989586621679500442"><span id="local-6989586621679500444"><span id="local-6989586621679500446"><span id="local-6989586621679500448"><span id="local-6989586621679500450"><span id="local-6989586621679500452"><span id="local-6989586621679500454"><span id="local-6989586621679500456"><span id="local-6989586621679500458"><span id="local-6989586621679500461"><span id="local-6989586621679500464"><span class="annot"><span class="annottext">Typeable DDerivStrategy
DDerivStrategy -&gt; DataType
DDerivStrategy -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DDerivStrategy -&gt; DDerivStrategy
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivStrategy)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivStrategy)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DDerivStrategy -&gt; m DDerivStrategy
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DDerivStrategy -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DDerivStrategy -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivStrategy -&gt; DDerivStrategy
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DDerivStrategy -&gt; DDerivStrategy
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivStrategy)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DDerivStrategy)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivStrategy)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DDerivStrategy)
dataTypeOf :: DDerivStrategy -&gt; DataType
$cdataTypeOf :: DDerivStrategy -&gt; DataType
toConstr :: DDerivStrategy -&gt; Constr
$ctoConstr :: DDerivStrategy -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DDerivStrategy
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DDerivStrategy -&gt; c DDerivStrategy
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep DDerivStrategy x -&gt; DDerivStrategy
forall x. DDerivStrategy -&gt; Rep DDerivStrategy x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DDerivStrategy x -&gt; DDerivStrategy
$cfrom :: forall x. DDerivStrategy -&gt; Rep DDerivStrategy x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-321"></span></pre></body></html>