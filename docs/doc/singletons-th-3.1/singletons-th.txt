-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for generating singleton types
--   
--   <tt>singletons-th</tt> defines Template Haskell functionality that
--   allows <i>promotion</i> of term-level functions to type-level
--   equivalents and <i>singling</i> functions to dependently typed
--   equivalents. This library was originally presented in <i>Dependently
--   Typed Programming with Singletons</i>, published at the Haskell
--   Symposium, 2012.
--   (<a>https://richarde.dev/papers/2012/singletons/paper.pdf</a>) See
--   also the paper published at Haskell Symposium, 2014, which describes
--   how promotion works in greater detail:
--   <a>https://richarde.dev/papers/2014/promotion/promotion.pdf</a>.
--   
--   <tt>singletons-th</tt> generates code that relies on bleeding-edge GHC
--   language extensions. As such, <tt>singletons-th</tt> only supports the
--   latest major version of GHC (currently GHC 9.2). For more information,
--   consult the <tt>singletons</tt> <tt><a>README</a></tt>.
--   
--   You may also be interested in the following related libraries:
--   
--   <ul>
--   <li>The <tt>singletons</tt> library is a small, foundational library
--   that defines basic singleton-related types and definitions.</li>
--   <li>The <tt>singletons-base</tt> library uses <tt>singletons-th</tt>
--   to define promoted and singled functions from the <tt>base</tt>
--   library, including the <a>Prelude</a>.</li>
--   </ul>
@package singletons-th
@version 3.1

module Data.Singletons.TH.SuppressUnusedWarnings

-- | This class (which users should never see) is to be instantiated in
--   order to use an otherwise-unused data constructor, such as the
--   "kind-inference" data constructor for defunctionalization symbols.
class SuppressUnusedWarnings (t :: k)
suppressUnusedWarnings :: SuppressUnusedWarnings t => ()


-- | This module defines <a>Options</a> that control finer details of how
--   the Template Haskell machinery works, as well as an <tt>mtl</tt>-like
--   <a>OptionsMonad</a> class and an <a>OptionsM</a> monad transformer.
module Data.Singletons.TH.Options

-- | Options that control the finer details of how <tt>singletons-th</tt>'s
--   Template Haskell machinery works.
data Options

-- | Sensible default <a>Options</a>.
--   
--   <a>genQuotedDecs</a> defaults to <a>True</a>. That is, quoted
--   declarations are generated alongside their promoted and singled
--   counterparts.
--   
--   <a>genSingKindInsts</a> defaults to <a>True</a>. That is,
--   <tt>SingKind</tt> instances are generated.
--   
--   The default behaviors for <a>promotedClassName</a>,
--   <tt>promotedValueNamePrefix</tt>, <a>singledDataTypeName</a>,
--   <a>singledClassName</a>, <a>singledDataConName</a>,
--   <a>singledValueName</a>, and <a>defunctionalizedName</a> are described
--   in the "On names" section of the <tt>singletons</tt>
--   <tt><a>README</a></tt>.
defaultOptions :: Options

-- | If <a>True</a>, then quoted declarations will be generated alongside
--   their promoted and singled counterparts. If <a>False</a>, then quoted
--   declarations will be discarded.
genQuotedDecs :: Options -> Bool

-- | If <a>True</a>, then <tt>SingKind</tt> instances will be generated. If
--   <a>False</a>, they will be omitted entirely. This can be useful in
--   scenarios where TH-generated <tt>SingKind</tt> instances do not
--   typecheck (for instance, when generating singletons for GADTs).
genSingKindInsts :: Options -> Bool

-- | Given the name of the original data type or data constructor, produces
--   the name of the promoted equivalent. Unlike the singling-related
--   options, in which there are separate <a>singledDataTypeName</a> and
--   <a>singledDataConName</a> functions, we combine the handling of
--   promoted data types and data constructors into a single option. This
--   is because the names of promoted data types and data constructors can
--   be difficult to distinguish in certain contexts without expensive
--   compile-time checks.
--   
--   Because of the <tt>DataKinds</tt> extension, most data type and data
--   constructor names can be used in promoted contexts without any
--   changes. As a result, this option will act like the identity function
--   99% of the time. There are some situations where it can be useful to
--   override this option, however, as it can be used to promote primitive
--   data types that do not have proper type-level equivalents, such as
--   <tt>Natural</tt> and <tt>Text</tt>. See the "Arrows, <tt>Nat</tt>,
--   <tt>Symbol</tt>, and literals" section of the <tt>singletons</tt>
--   <tt><a>README</a></tt> for more details.
promotedDataTypeOrConName :: Options -> Name -> Name

-- | Given the name of the original, unrefined class, produces the name of
--   the promoted equivalent of the class.
promotedClassName :: Options -> Name -> Name

-- | Given the name of the original, unrefined value, produces the name of
--   the promoted equivalent of the value. This is used for both top-level
--   and <tt>let</tt>-bound names, and the difference is encoded in the
--   <tt><a>Maybe</a> <a>Uniq</a></tt> argument. If promoting a top-level
--   name, the argument is <a>Nothing</a>. If promoting a
--   <tt>let</tt>-bound name, the argument is <tt>Just uniq</tt>, where
--   <tt>uniq</tt> is a globally unique number that can be used to
--   distinguish the name from other local definitions of the same name
--   (e.g., if two functions both use <tt>let x = ... in x</tt>).
promotedValueName :: Options -> Name -> Maybe Uniq -> Name

-- | Given the name of the original, unrefined data type, produces the name
--   of the corresponding singleton type.
singledDataTypeName :: Options -> Name -> Name

-- | Given the name of the original, unrefined class, produces the name of
--   the singled equivalent of the class.
singledClassName :: Options -> Name -> Name

-- | Given the name of the original, unrefined data constructor, produces
--   the name of the corresponding singleton data constructor.
singledDataConName :: Options -> Name -> Name

-- | Given the name of the original, unrefined value, produces the name of
--   the singled equivalent of the value.
singledValueName :: Options -> Name -> Name

-- | Given the original name and the number of parameters it is applied to
--   (the <a>Int</a> argument), produces a type-level function name that
--   can be partially applied when given the same number of parameters.
--   
--   Note that defunctionalization works over both term-level names
--   (producing symbols for the promoted name) and type-level names
--   (producing symbols directly for the name itself). As a result, this
--   callback is used for names in both the term and type namespaces.
defunctionalizedName :: Options -> Name -> Int -> Name

-- | Given the name of the original, unrefined, top-level value, produces
--   the name of the promoted equivalent of the value.
promotedTopLevelValueName :: Options -> Name -> Name

-- | Given the name of the original, unrefined, <tt>let</tt>-bound value
--   and its globally unique number, produces the name of the promoted
--   equivalent of the value.
promotedLetBoundValueName :: Options -> Name -> Uniq -> Name

-- | Given the original name of a function (term- or type-level), produces
--   a type-level function name that can be partially applied even without
--   being given any arguments (i.e., <tt>0</tt> arguments).
defunctionalizedName0 :: Options -> Name -> Name

-- | Class that describes monads that contain <a>Options</a>.
class DsMonad m => OptionsMonad m
getOptions :: OptionsMonad m => m Options

-- | A convenient implementation of the <a>OptionsMonad</a> class. Use by
--   calling <a>withOptions</a>.
data OptionsM m a

-- | Declare the <a>Options</a> that a TH computation should use.
withOptions :: Options -> OptionsM m a -> m a
instance Language.Haskell.TH.Desugar.Reify.DsMonad m => Language.Haskell.TH.Desugar.Reify.DsMonad (Data.Singletons.TH.Options.OptionsM m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.Singletons.TH.Options.OptionsM m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Data.Singletons.TH.Options.OptionsM m)
instance Language.Haskell.TH.Syntax.Quasi m => Language.Haskell.TH.Syntax.Quasi (Data.Singletons.TH.Options.OptionsM m)
instance Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Quote (Data.Singletons.TH.Options.OptionsM m)
instance Control.Monad.Trans.Class.MonadTrans Data.Singletons.TH.Options.OptionsM
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Singletons.TH.Options.OptionsM m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Singletons.TH.Options.OptionsM m)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Singletons.TH.Options.OptionsM m)
instance Language.Haskell.TH.Desugar.Reify.DsMonad m => Data.Singletons.TH.Options.OptionsMonad (Data.Singletons.TH.Options.OptionsM m)
instance Data.Singletons.TH.Options.OptionsMonad Language.Haskell.TH.Syntax.Q
instance Data.Singletons.TH.Options.OptionsMonad m => Data.Singletons.TH.Options.OptionsMonad (Language.Haskell.TH.Desugar.Reify.DsM m)
instance (Data.Singletons.TH.Options.OptionsMonad q, GHC.Base.Monoid m) => Data.Singletons.TH.Options.OptionsMonad (Data.Singletons.TH.Util.QWithAux m q)
instance Data.Singletons.TH.Options.OptionsMonad m => Data.Singletons.TH.Options.OptionsMonad (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Singletons.TH.Options.OptionsMonad m => Data.Singletons.TH.Options.OptionsMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Data.Singletons.TH.Options.OptionsMonad m, GHC.Base.Monoid w) => Data.Singletons.TH.Options.OptionsMonad (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Data.Singletons.TH.Options.OptionsMonad m, GHC.Base.Monoid w) => Data.Singletons.TH.Options.OptionsMonad (Control.Monad.Trans.RWS.Lazy.RWST r w s m)


-- | This module contains basic functionality for deriving your own
--   singletons via Template Haskell. Note that this module does not define
--   any singled definitions on its own. For a version of this module that
--   comes pre-equipped with several singled definitions based on the
--   <a>Prelude</a>, see <tt>Data.Singletons.Base.TH</tt> from the
--   <tt>singletons-base</tt> library.
module Data.Singletons.TH

-- | Make promoted and singled versions of all declarations given,
--   retaining the original declarations. See the <tt><a>README</a></tt>
--   for further explanation.
singletons :: OptionsMonad q => q [Dec] -> q [Dec]

-- | Make promoted and singled versions of all declarations given,
--   discarding the original declarations. Note that a singleton based on a
--   datatype needs the original datatype, so this will fail if it sees any
--   datatype declarations. Classes, instances, and functions are all fine.
singletonsOnly :: OptionsMonad q => q [Dec] -> q [Dec]

-- | Generate singled definitions for each of the provided type-level
--   declaration <a>Name</a>s. For example, the singletons-th package
--   itself uses
--   
--   <pre>
--   $(genSingletons [''Bool, ''Maybe, ''Either, ''[]])
--   </pre>
--   
--   to generate singletons for Prelude types.
genSingletons :: OptionsMonad q => [Name] -> q [Dec]

-- | Promote every declaration given to the type level, retaining the
--   originals. See the <tt><a>README</a></tt> for further explanation.
promote :: OptionsMonad q => q [Dec] -> q [Dec]

-- | Promote each declaration, discarding the originals. Note that a
--   promoted datatype uses the same definition as an original datatype, so
--   this will not work with datatypes. Classes, instances, and functions
--   are all fine.
promoteOnly :: OptionsMonad q => q [Dec] -> q [Dec]

-- | Generate defunctionalization symbols for each of the provided
--   type-level declaration <a>Name</a>s. See the "Promotion and partial
--   application" section of the <tt>singletons</tt> <tt><a>README</a></tt>
--   for further explanation.
genDefunSymbols :: OptionsMonad q => [Name] -> q [Dec]

-- | Generate promoted definitions for each of the provided type-level
--   declaration <a>Name</a>s. This is generally only useful with classes.
genPromotions :: OptionsMonad q => [Name] -> q [Dec]

-- | Produce instances for <tt>PEq</tt> from the given types
promoteEqInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Produce an instance for <tt>PEq</tt> from the given type
promoteEqInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create instances of <tt>SEq</tt> for the given types
singEqInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Create instance of <tt>SEq</tt> for the given type
singEqInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create instances of <tt>SDecide</tt>, <a>TestEquality</a>, and
--   <a>TestCoercion</a> for each type in the list.
singDecideInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Create instances of <tt>SDecide</tt>, <a>TestEquality</a>, and
--   <a>TestCoercion</a> for the given type.
singDecideInstance :: OptionsMonad q => Name -> q [Dec]

-- | Produce instances for <tt>POrd</tt> from the given types
promoteOrdInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Produce an instance for <tt>POrd</tt> from the given type
promoteOrdInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create instances of <tt>SOrd</tt> for the given types
singOrdInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Create instance of <tt>SOrd</tt> for the given type
singOrdInstance :: OptionsMonad q => Name -> q [Dec]

-- | Produce instances for <tt>PBounded</tt> from the given types
promoteBoundedInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Produce an instance for <tt>PBounded</tt> from the given type
promoteBoundedInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create instances of <tt>SBounded</tt> for the given types
singBoundedInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Create instance of <tt>SBounded</tt> for the given type
singBoundedInstance :: OptionsMonad q => Name -> q [Dec]

-- | Produce instances for <tt>PEnum</tt> from the given types
promoteEnumInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Produce an instance for <tt>PEnum</tt> from the given type
promoteEnumInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create instances of <tt>SEnum</tt> for the given types
singEnumInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Create instance of <tt>SEnum</tt> for the given type
singEnumInstance :: OptionsMonad q => Name -> q [Dec]

-- | Produce instances for <tt>PShow</tt> from the given types
promoteShowInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Produce an instance for <tt>PShow</tt> from the given type
promoteShowInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create instances of <tt>SShow</tt> for the given types
--   
--   (Not to be confused with <a>showSingInstances</a>.)
singShowInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Create instance of <tt>SShow</tt> for the given type
--   
--   (Not to be confused with <tt>showShowInstance</tt>.)
singShowInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create instances of <a>Show</a> for the given singleton types
--   
--   (Not to be confused with <a>singShowInstances</a>.)
showSingInstances :: OptionsMonad q => [Name] -> q [Dec]

-- | Create instance of <a>Show</a> for the given singleton type
--   
--   (Not to be confused with <a>singShowInstance</a>.)
showSingInstance :: OptionsMonad q => Name -> q [Dec]

-- | Create an instance for <tt><tt>SingI</tt> TyCon{N}</tt>, where
--   <tt>N</tt> is the positive number provided as an argument.
--   
--   Note that the generated code requires the use of the
--   <tt>QuantifiedConstraints</tt> language extension.
singITyConInstances :: DsMonad q => [Int] -> q [Dec]

-- | Create an instance for <tt><tt>SingI</tt> TyCon{N}</tt>, where
--   <tt>N</tt> is the positive number provided as an argument.
--   
--   Note that the generated code requires the use of the
--   <tt>QuantifiedConstraints</tt> language extension.
singITyConInstance :: DsMonad q => Int -> q Dec

-- | The function <a>cases</a> generates a case expression where each
--   right-hand side is identical. This may be useful if the type-checker
--   requires knowledge of which constructor is used to satisfy equality or
--   type-class constraints, but where each constructor is treated the
--   same.
cases :: DsMonad q => Name -> q Exp -> q Exp -> q Exp

-- | The function <a>sCases</a> generates a case expression where each
--   right-hand side is identical. This may be useful if the type-checker
--   requires knowledge of which constructor is used to satisfy equality or
--   type-class constraints, but where each constructor is treated the
--   same. For <a>sCases</a>, unlike <a>cases</a>, the scrutinee is a
--   singleton. But make sure to pass in the name of the <i>original</i>
--   datatype, preferring <tt>''Maybe</tt> over <tt>''SMaybe</tt>.
sCases :: OptionsMonad q => Name -> q Exp -> q Exp -> q Exp

-- | Members of the <a>SDecide</a> "kind" class support decidable equality.
--   Instances of this class are generated alongside singleton definitions
--   for datatypes that derive an <a>Eq</a> instance.
class SDecide k

-- | Compute a proof or disproof of equality, given two singletons.
(%~) :: forall (a :: k) (b :: k). SDecide k => Sing a -> Sing b -> Decision (a :~: b)
infix 4 %~

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | Uninhabited data type
data Void

-- | Because we can never create a value of type <a>Void</a>, a function
--   that type-checks at <tt>a -&gt; Void</tt> shows that objects of type
--   <tt>a</tt> can never exist. Thus, we say that <tt>a</tt> is
--   <a>Refuted</a>
type Refuted a = a -> Void

-- | A <a>Decision</a> about a type <tt>a</tt> is either a proof of
--   existence or a proof that <tt>a</tt> cannot exist.
data Decision a

-- | Witness for <tt>a</tt>
Proved :: a -> Decision a

-- | Proof that no <tt>a</tt> exists
Disproved :: Refuted a -> Decision a

-- | This class (which users should never see) is to be instantiated in
--   order to use an otherwise-unused data constructor, such as the
--   "kind-inference" data constructor for defunctionalization symbols.
class SuppressUnusedWarnings (t :: k)
suppressUnusedWarnings :: SuppressUnusedWarnings t => ()


-- | This file implements <a>singletonStar</a>, which generates a datatype
--   <tt>Rep</tt> and associated singleton from a list of types. The
--   promoted version of <tt>Rep</tt> is kind <tt>*</tt> and the Haskell
--   types themselves. This is still very experimental, so expect unusual
--   results!
--   
--   See also <tt>Data.Singletons.Base.CustomStar</tt> from
--   <tt>singletons-base</tt>, a variant of this module that also
--   re-exports related definitions from <tt>Prelude.Singletons</tt>.
module Data.Singletons.TH.CustomStar

-- | Produce a representation and singleton for the collection of types
--   given.
--   
--   A datatype <tt>Rep</tt> is created, with one constructor per type in
--   the declared universe. When this type is promoted by the
--   <tt>singletons-th</tt> library, the constructors become full types in
--   <tt>*</tt>, not just promoted data constructors.
--   
--   For example,
--   
--   <pre>
--   $(singletonStar [''Nat, ''Bool, ''Maybe])
--   </pre>
--   
--   generates the following:
--   
--   <pre>
--   data Rep = Nat | Bool | Maybe Rep deriving (Eq, Ord, Read, Show)
--   </pre>
--   
--   and its singleton. However, because <tt>Rep</tt> is promoted to
--   <tt>*</tt>, the singleton is perhaps slightly unexpected:
--   
--   <pre>
--   data SRep (a :: *) where
--     SNat :: Sing Nat
--     SBool :: Sing Bool
--     SMaybe :: Sing a -&gt; Sing (Maybe a)
--   type instance Sing = SRep
--   </pre>
--   
--   The unexpected part is that <tt>Nat</tt>, <tt>Bool</tt>, and
--   <tt>Maybe</tt> above are the real <tt>Nat</tt>, <tt>Bool</tt>, and
--   <tt>Maybe</tt>, not just promoted data constructors.
--   
--   Please note that this function is <i>very</i> experimental. Use at
--   your own risk.
singletonStar :: OptionsMonad q => [Name] -> q [Dec]
