<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-2"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Module      :  Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Copyright   :  (C) Frank Staals</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- License     :  see the LICENSE file</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Maintainer  :  Frank Staals</span><span>
</span><span id="line-8"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-9"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer</span><span>
</span><span id="line-10"></span><span>  </span><span class="hs-special">(</span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Divide &amp; Conqueror Delaunay Triangulation</span></span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation"><span class="hs-identifier">delaunayTriangulation</span></a></span><span>
</span><span id="line-13"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-14"></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Algorithms.Geometry.ConvexHull.GrahamScan.html"><span class="hs-identifier">Algorithms.Geometry.ConvexHull.GrahamScan</span></a></span><span>       </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">GS</span></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html"><span class="hs-identifier">Algorithms.Geometry.DelaunayTriangulation.Types</span></a></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Lens</span></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.Reader</span></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.State</span></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.BinaryTree</span></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.CircularList</span></span><span>                               </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">CL</span></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.CircularList.Util</span></span><span>                          </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">CU</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Ext</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>                                   </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">F</span></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Function</span></span><span>                                   </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">on</span></span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Geometry.Point.html"><span class="hs-identifier">Geometry.Point</span></a></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Geometry.LineSegment.html"><span class="hs-identifier">Geometry.LineSegment</span></a></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Geometry.Polygon.html"><span class="hs-identifier">Geometry.Polygon</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Geometry.Ball.html"><span class="hs-identifier">Geometry.Ball</span></a></span><span>                              </span><span class="hs-special">(</span><span class="annot"><a href="Geometry.Ball.html#disk"><span class="hs-identifier">disk</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Geometry.Ball.html#insideBall"><span class="hs-identifier">insideBall</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Geometry.Polygon.Convex.html"><span class="hs-identifier">Geometry.Polygon.Convex</span></a></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Geometry.Polygon.Convex.html#simplePolygon"><span class="hs-identifier">simplePolygon</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Geometry.Polygon.Convex.html"><span class="hs-identifier">Geometry.Polygon.Convex</span></a></span><span>                    </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Convex</span></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap.Strict</span></span><span>                              </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">IM</span></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span>                                       </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">L</span></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span>                              </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NonEmpty</span></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span>                                        </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>                                      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromJust</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">fromMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Measured.Size</span></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector</span></span><span>                                     </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">V</span></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector.Circular.Util</span></span><span>                       </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">CV</span></span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- * Divide &amp; Conqueror Delaunay Triangulation</span><span>
</span><span id="line-43"></span><span class="hs-comment">--</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- Implementation of the Divide &amp; Conqueror algorithm as described in:</span><span>
</span><span id="line-45"></span><span class="hs-comment">--</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- Two Algorithms for Constructing a Delaunay Triangulation</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- Lee and Schachter</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- International Journal of Computer and Information Sciences, Vol 9, No. 3, 1980</span><span>
</span><span id="line-49"></span><span class="hs-comment">--</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- We store all adjacency lists in clockwise order</span><span>
</span><span id="line-51"></span><span class="hs-comment">--</span><span>
</span><span id="line-52"></span><span class="hs-comment">-- : If v on the convex hull, then its first entry in the adj. lists is its CCW</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- successor (i.e. its predecessor) on the convex hull</span><span>
</span><span id="line-54"></span><span class="hs-comment">--</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- Rotating Right &lt;-&gt; rotate clockwise</span><span>
</span><span id="line-56"></span><span>
</span><span id="line-57"></span><span class="hs-comment">-- | Computes the delaunay triangulation of a set of points.</span><span>
</span><span id="line-58"></span><span class="hs-comment">--</span><span>
</span><span id="line-59"></span><span class="hs-comment">-- Running time: \(O(n \log n)\)</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- (note: We use an IntMap in the implementation. So maybe actually \(O(n \log^2 n)\))</span><span>
</span><span id="line-61"></span><span class="hs-comment">--</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- pre: the input is a *SET*, i.e. contains no duplicate points. (If the</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- input does contain duplicate points, the implementation throws them away)</span><span>
</span><span id="line-64"></span><span id="local-6989586621680176504"><span id="local-6989586621680176506"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation"><span class="hs-identifier hs-type">delaunayTriangulation</span></a></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176506"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680176506"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span>                           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Geometry.Point.Internal.html#Point"><span class="hs-identifier hs-type">Point</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="annot"><a href="#local-6989586621680176506"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621680176504"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Triangulation"><span class="hs-identifier hs-type">Triangulation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176504"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176506"><span class="hs-identifier hs-type">r</span></a></span></span></span><span>
</span><span id="line-66"></span><span id="delaunayTriangulation"><span class="annot"><span class="annottext">delaunayTriangulation :: forall r p.
(Ord r, Fractional r) =&gt;
NonEmpty (Point 2 r :+ p) -&gt; Triangulation p r
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation"><span class="hs-identifier hs-var hs-var">delaunayTriangulation</span></a></span></span><span> </span><span id="local-6989586621680176112"><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621680176112"><span class="hs-identifier hs-var">pts'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p r.
Map (Point 2 r) VertexID
-&gt; Vector (Point 2 r :+ p)
-&gt; Vector (CList VertexID)
-&gt; Triangulation p r
</span><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Triangulation"><span class="hs-identifier hs-var">Triangulation</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680176110"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680176109"><span class="hs-identifier hs-var">ptsV</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (CList VertexID)
</span><a href="#local-6989586621680176108"><span class="hs-identifier hs-var">adjV</span></a></span><span>
</span><span id="line-67"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-68"></span><span>    </span><span id="local-6989586621680176107"><span class="annot"><span class="annottext">pts :: NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621680176107"><span class="hs-identifier hs-var hs-var">pts</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. Eq a =&gt; NonEmpty (a :+ b) -&gt; NonEmpty (a :+ b)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#nub%27"><span class="hs-identifier hs-var">nub'</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a -&gt; Ordering) -&gt; NonEmpty a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">NonEmpty.sortBy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><span class="hs-identifier hs-var">compare</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621680176112"><span class="hs-identifier hs-var">pts'</span></a></span><span>
</span><span id="line-69"></span><span>    </span><span id="local-6989586621680176109"><span class="annot"><span class="annottext">ptsV :: Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680176109"><span class="hs-identifier hs-var hs-var">ptsV</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; Vector a
</span><span class="hs-identifier hs-var">V.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621680176107"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-70"></span><span>    </span><span id="local-6989586621680176110"><span class="annot"><span class="annottext">vtxMap :: Map (Point 2 r) VertexID
</span><a href="#local-6989586621680176110"><span class="hs-identifier hs-var hs-var">vtxMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; [a]
</span><span class="hs-identifier hs-var">V.toList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680176109"><span class="hs-identifier hs-var">ptsV</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">VertexID
</span><span class="hs-number">0</span></span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span>    </span><span id="local-6989586621680176096"><span class="annot"><span class="annottext">tr :: BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176096"><span class="hs-identifier hs-var hs-var">tr</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Elem a -&gt; a
</span><span class="hs-identifier hs-var">_unElem</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. NonEmpty a -&gt; BinLeafTree Size (Elem a)
</span><span class="hs-identifier hs-var">asBalancedBinLeafTree</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621680176107"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621680176092"><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680176092"><span class="hs-identifier hs-var">adj</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var">delaunayTriangulation'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176096"><span class="hs-identifier hs-var">tr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680176110"><span class="hs-identifier hs-var">vtxMap</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680176109"><span class="hs-identifier hs-var">ptsV</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-75"></span><span>    </span><span id="local-6989586621680176108"><span class="annot"><span class="annottext">adjV :: Vector (CList VertexID)
</span><a href="#local-6989586621680176108"><span class="hs-identifier hs-var hs-var">adjV</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; Vector a
</span><span class="hs-identifier hs-var">V.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. IntMap a -&gt; [a]
</span><span class="hs-identifier hs-var">IM.elems</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680176092"><span class="hs-identifier hs-var">adj</span></a></span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span class="hs-comment">-- : pre: - Input points are sorted lexicographically</span><span>
</span><span id="line-80"></span><span id="local-6989586621680176431"><span id="local-6989586621680176432"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-type">delaunayTriangulation'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176432"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680176432"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-81"></span><span>                       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">BinLeafTree</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Size</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Geometry.Point.Internal.html#Point"><span class="hs-identifier hs-type">Point</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="annot"><a href="#local-6989586621680176432"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621680176431"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-82"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176431"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176432"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-83"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-type">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176431"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680176432"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-84"></span><span id="delaunayTriangulation%27"><span class="annot"><span class="annottext">delaunayTriangulation' :: forall r p.
(Ord r, Fractional r) =&gt;
BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var hs-var">delaunayTriangulation'</span></a></span></span><span> </span><span id="local-6989586621680176047"><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176047"><span class="hs-identifier hs-var">pts</span></a></span></span><span> </span><span id="local-6989586621680176046"><span class="annot"><span class="annottext">mapping' :: Mapping p r
</span><a href="#local-6989586621680176046"><span class="hs-identifier hs-var">mapping'</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621680176045"><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680176045"><span class="hs-identifier hs-var">vtxMap</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-85"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall a. BinLeafTree Size a -&gt; Size
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var">size'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176047"><span class="hs-identifier hs-var">pts</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Size
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Leaf</span></span><span> </span><span id="local-6989586621680176042"><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680176042"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176047"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-86"></span><span>                         </span><span id="local-6989586621680176041"><span class="annot"><span class="annottext">i :: VertexID
</span><a href="#local-6989586621680176041"><span class="hs-identifier hs-var hs-var">i</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680176045"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680176042"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-87"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. VertexID -&gt; a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.singleton</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680176041"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. CList a
</span><span class="hs-identifier hs-var">CL.empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall p r. SimplePolygon p r -&gt; ConvexPolygon p r
</span><a href="Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-var">ConvexPolygon</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall r p. [Point 2 r :+ p] -&gt; SimplePolygon p r
</span><a href="Geometry.Polygon.Core.html#unsafeFromPoints"><span class="hs-identifier hs-var">unsafeFromPoints</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall c e e'. (c :+ e) -&gt; e' -&gt; c :+ (e :+ e')
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-var">withID</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680176042"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680176041"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall a. BinLeafTree Size a -&gt; Size
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var">size'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176047"><span class="hs-identifier hs-var">pts</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="annottext">Size
</span><span class="hs-number">3</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680176033"><span class="annot"><span class="annottext">pts' :: NonEmpty (Point 2 r :+ (p :+ VertexID))
</span><a href="#local-6989586621680176033"><span class="hs-identifier hs-var hs-var">pts'</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">NonEmpty.fromList</span></span><span>
</span><span id="line-89"></span><span>                               </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680176031"><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680176031"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall c e e'. (c :+ e) -&gt; e' -&gt; c :+ (e :+ e')
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-var">withID</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680176031"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680176045"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680176031"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>                               </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176047"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-91"></span><span>                         </span><span id="local-6989586621680176030"><span class="annot"><span class="annottext">ch :: ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176030"><span class="hs-identifier hs-var hs-var">ch</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Num r) =&gt;
NonEmpty (Point 2 r :+ p) -&gt; ConvexPolygon p r
</span><a href="Algorithms.Geometry.ConvexHull.GrahamScan.html#convexHull"><span class="hs-identifier hs-var">GS.convexHull</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ (p :+ VertexID))
</span><a href="#local-6989586621680176033"><span class="hs-identifier hs-var">pts'</span></a></span><span>
</span><span id="line-92"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall r p q.
Ord r =&gt;
Mapping p r -&gt; ConvexPolygon (p :+ q) r -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#fromHull"><span class="hs-identifier hs-var">fromHull</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621680176046"><span class="hs-identifier hs-var">mapping'</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176030"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176030"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span id="local-6989586621680176026"><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176026"><span class="hs-identifier hs-var">lt</span></a></span></span><span> </span><span class="annot"><span class="annottext">Size
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680176025"><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176025"><span class="hs-identifier hs-var">rt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176047"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-94"></span><span>                         </span><span class="hs-special">(</span><span id="local-6989586621680176024"><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680176024"><span class="hs-identifier hs-var">ld</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680176023"><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176023"><span class="hs-identifier hs-var">lch</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var">delaunayTriangulation'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176026"><span class="hs-identifier hs-var">lt</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621680176046"><span class="hs-identifier hs-var">mapping'</span></a></span><span>
</span><span id="line-95"></span><span>                         </span><span class="hs-special">(</span><span id="local-6989586621680176022"><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680176022"><span class="hs-identifier hs-var">rd</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680176021"><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176021"><span class="hs-identifier hs-var">rch</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var">delaunayTriangulation'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621680176025"><span class="hs-identifier hs-var">rt</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621680176046"><span class="hs-identifier hs-var">mapping'</span></a></span><span>
</span><span id="line-96"></span><span>                         </span><span class="hs-special">(</span><span id="local-6989586621680176020"><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176020"><span class="hs-identifier hs-var">ch</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680176019"><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680176019"><span class="hs-identifier hs-var">bt</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621680176018"><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680176018"><span class="hs-identifier hs-var">ut</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Num r, Ord r) =&gt;
ConvexPolygon p r
-&gt; ConvexPolygon p r
-&gt; (ConvexPolygon p r, LineSegment 2 p r, LineSegment 2 p r)
</span><a href="Geometry.Polygon.Convex.html#merge"><span class="hs-identifier hs-var">Convex.merge</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176023"><span class="hs-identifier hs-var">lch</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176021"><span class="hs-identifier hs-var">rch</span></a></span><span>
</span><span id="line-97"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
Adj
-&gt; Adj
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Mapping p r
-&gt; Firsts
-&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#merge"><span class="hs-identifier hs-var">merge</span></a></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680176024"><span class="hs-identifier hs-var">ld</span></a></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680176022"><span class="hs-identifier hs-var">rd</span></a></span><span> </span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680176019"><span class="hs-identifier hs-var">bt</span></a></span><span> </span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680176018"><span class="hs-identifier hs-var">ut</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621680176046"><span class="hs-identifier hs-var">mapping'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p r. ConvexPolygon (p :+ VertexID) r -&gt; Firsts
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#firsts"><span class="hs-identifier hs-var">firsts</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176020"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621680176020"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- * Implementation</span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span class="hs-comment">-- | Mapping that says for each vtx in the convex hull what the first entry in</span><span>
</span><span id="line-103"></span><span class="hs-comment">-- the adj. list should be. The input polygon is given in Clockwise order</span><span>
</span><span id="line-104"></span><span id="local-6989586621680176396"><span id="local-6989586621680176397"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#firsts"><span class="hs-identifier hs-type">firsts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-type">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176397"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680176396"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IM.IntMap</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span></span></span><span>
</span><span id="line-105"></span><span id="firsts"><span class="annot"><span class="annottext">firsts :: forall p r. ConvexPolygon (p :+ VertexID) r -&gt; Firsts
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#firsts"><span class="hs-identifier hs-var hs-var">firsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [(VertexID, a)] -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621680176001"><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680176001"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680176001"><span class="hs-identifier hs-var">s</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall t. HasEnd t =&gt; Lens' t (EndCore t :+ EndExtra t)
</span><a href="Geometry.Interval.html#end"><span class="hs-identifier hs-var">end</span></a></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680176001"><span class="hs-identifier hs-var">s</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall t. HasStart t =&gt; Lens' t (StartCore t :+ StartExtra t)
</span><a href="Geometry.Interval.html#start"><span class="hs-identifier hs-var">start</span></a></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span>       </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: PolygonType) p r.
Polygon t p r -&gt; CircularVector (LineSegment 2 p r)
</span><a href="Geometry.Polygon.Core.html#outerBoundaryEdges"><span class="hs-identifier hs-var">outerBoundaryEdges</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall p r. ConvexPolygon p r -&gt; SimplePolygon p r
</span><a href="Geometry.Polygon.Convex.html#_simplePolygon"><span class="hs-identifier hs-var">_simplePolygon</span></a></span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span class="hs-comment">-- | Given a polygon; construct the adjacency list representation</span><span>
</span><span id="line-110"></span><span class="hs-comment">-- pre: at least two elements</span><span>
</span><span id="line-111"></span><span id="local-6989586621680176404"><span id="local-6989586621680176405"><span id="local-6989586621680176406"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#fromHull"><span class="hs-identifier hs-type">fromHull</span></a></span><span>              </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176406"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176405"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176406"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-type">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176405"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621680176404"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680176406"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span></span></span></span><span>
</span><span id="line-112"></span><span id="fromHull"><span class="annot"><span class="annottext">fromHull :: forall r p q.
Ord r =&gt;
Mapping p r -&gt; ConvexPolygon (p :+ q) r -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#fromHull"><span class="hs-identifier hs-var hs-var">fromHull</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680175969"><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680175969"><span class="hs-identifier hs-var">vtxMap</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621680175968"><span class="annot"><span class="annottext">ConvexPolygon (p :+ q) r
</span><a href="#local-6989586621680175968"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680175967"><span class="annot"><span class="annottext">vs :: [VertexID]
</span><a href="#local-6989586621680175967"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621680175966"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175966"><span class="hs-identifier hs-var">u</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621680175965"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175965"><span class="hs-identifier hs-var">v</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621680175964"><span class="annot"><span class="annottext">[VertexID]
</span><a href="#local-6989586621680175964"><span class="hs-identifier hs-var">vs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680175969"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span>                                         </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. CircularVector a -&gt; NonEmptyVector a
</span><span class="hs-identifier hs-var">CV.rightElements</span></span><span>
</span><span id="line-114"></span><span>                                         </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ q) r
</span><a href="#local-6989586621680175968"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall p1 r1 p2 r2.
Iso
  (ConvexPolygon p1 r1)
  (ConvexPolygon p2 r2)
  (SimplePolygon p1 r1)
  (SimplePolygon p2 r2)
</span><a href="Geometry.Polygon.Convex.html#simplePolygon"><span class="hs-identifier hs-var">simplePolygon</span></a></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall (t :: PolygonType) p r.
Getter (Polygon t p r) (CircularVector (Point 2 r :+ p))
</span><a href="Geometry.Polygon.Core.html#outerBoundaryVector"><span class="hs-identifier hs-var">outerBoundaryVector</span></a></span><span>
</span><span id="line-115"></span><span>                            </span><span id="local-6989586621680175961"><span class="annot"><span class="annottext">es :: [(VertexID, CList VertexID)]
</span><a href="#local-6989586621680175961"><span class="hs-identifier hs-var hs-var">es</span></a></span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]
</span><span class="hs-identifier hs-var">zipWith3</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {a}. Eq a =&gt; a -&gt; a -&gt; a -&gt; (a, CList a)
</span><a href="#local-6989586621680175959"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[VertexID]
</span><a href="#local-6989586621680175967"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">tail</span></span><span> </span><span class="annot"><span class="annottext">[VertexID]
</span><a href="#local-6989586621680175967"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175966"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VertexID]
</span><a href="#local-6989586621680175964"><span class="hs-identifier hs-var">vs'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175966"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175965"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span>                            </span><span id="local-6989586621680175959"><span class="annot"><span class="annottext">f :: a -&gt; a -&gt; a -&gt; (a, CList a)
</span><a href="#local-6989586621680175959"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span id="local-6989586621680175955"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175955"><span class="hs-identifier hs-var">prv</span></a></span></span><span> </span><span id="local-6989586621680175954"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175954"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621680175953"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175953"><span class="hs-identifier hs-var">nxt</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175954"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a. [a] -&gt; CList a
</span><span class="hs-identifier hs-var">CL.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">L.nub</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175955"><span class="hs-identifier hs-var">prv</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175953"><span class="hs-identifier hs-var">nxt</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>                        </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">forall a. [(VertexID, a)] -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.fromList</span></span><span> </span><span class="annot"><span class="annottext">[(VertexID, CList VertexID)]
</span><a href="#local-6989586621680175961"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-118"></span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span class="hs-comment">-- | Merge the two delaunay triangulations.</span><span>
</span><span id="line-121"></span><span class="hs-comment">--</span><span>
</span><span id="line-122"></span><span class="hs-comment">-- running time: \(O(n)\) (although we cheat a bit by using a IntMap)</span><span>
</span><span id="line-123"></span><span id="local-6989586621680176399"><span id="local-6989586621680176400"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#merge"><span class="hs-identifier hs-type">merge</span></a></span><span>                            </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176400"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680176400"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>                                 </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span>
</span><span id="line-125"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span>
</span><span id="line-126"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Geometry.LineSegment.Internal.html#LineSegment"><span class="hs-identifier hs-type">LineSegment</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176399"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680176400"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-comment">-- ^ lower tangent</span><span>
</span><span id="line-127"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Geometry.LineSegment.Internal.html#LineSegment"><span class="hs-identifier hs-type">LineSegment</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176399"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621680176400"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-comment">-- ^ upper tangent</span><span>
</span><span id="line-128"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176399"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176400"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-129"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-type">Firsts</span></a></span><span>
</span><span id="line-130"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span></span></span><span>
</span><span id="line-131"></span><span id="merge"><span class="annot"><span class="annottext">merge :: forall r p.
(Ord r, Fractional r) =&gt;
Adj
-&gt; Adj
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Mapping p r
-&gt; Firsts
-&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#merge"><span class="hs-identifier hs-var hs-var">merge</span></a></span></span><span> </span><span id="local-6989586621680175912"><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680175912"><span class="hs-identifier hs-var">ld</span></a></span></span><span> </span><span id="local-6989586621680175911"><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680175911"><span class="hs-identifier hs-var">rd</span></a></span></span><span> </span><span id="local-6989586621680175910"><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680175910"><span class="hs-identifier hs-var">bt</span></a></span></span><span> </span><span id="local-6989586621680175909"><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680175909"><span class="hs-identifier hs-var">ut</span></a></span></span><span> </span><span id="local-6989586621680175908"><span class="annot"><span class="annottext">mapping' :: Mapping p r
</span><a href="#local-6989586621680175908"><span class="hs-identifier hs-var">mapping'</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621680175907"><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680175907"><span class="hs-identifier hs-var">vtxMap</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621680175906"><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621680175906"><span class="hs-identifier hs-var">fsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-132"></span><span>    </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">forall r a. Reader r a -&gt; r -&gt; a
</span><span class="hs-identifier hs-var">runReader</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621680175908"><span class="hs-identifier hs-var">mapping'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621680175906"><span class="hs-identifier hs-var">fsts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m s
</span><span class="hs-identifier hs-var">execStateT</span></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680175902"><span class="hs-identifier hs-var">adj</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
(VertexID, VertexID) -&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-var">moveUp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175900"><span class="hs-identifier hs-var">tl</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175899"><span class="hs-identifier hs-var">tr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175898"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175897"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-133"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-134"></span><span>    </span><span id="local-6989586621680175898"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621680175898"><span class="hs-identifier hs-var hs-var">l</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680175907"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680175910"><span class="hs-identifier hs-var">bt</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall t. HasStart t =&gt; Lens' t (StartCore t :+ StartExtra t)
</span><a href="Geometry.Interval.html#start"><span class="hs-identifier hs-var">start</span></a></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-135"></span><span>    </span><span id="local-6989586621680175897"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621680175897"><span class="hs-identifier hs-var hs-var">r</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680175907"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680175910"><span class="hs-identifier hs-var">bt</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall t. HasEnd t =&gt; Lens' t (EndCore t :+ EndExtra t)
</span><a href="Geometry.Interval.html#end"><span class="hs-identifier hs-var">end</span></a></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-136"></span><span>    </span><span id="local-6989586621680175900"><span class="annot"><span class="annottext">tl :: VertexID
</span><a href="#local-6989586621680175900"><span class="hs-identifier hs-var hs-var">tl</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680175907"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680175909"><span class="hs-identifier hs-var">ut</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall t. HasStart t =&gt; Lens' t (StartCore t :+ StartExtra t)
</span><a href="Geometry.Interval.html#start"><span class="hs-identifier hs-var">start</span></a></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-137"></span><span>    </span><span id="local-6989586621680175899"><span class="annot"><span class="annottext">tr :: VertexID
</span><a href="#local-6989586621680175899"><span class="hs-identifier hs-var hs-var">tr</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621680175907"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621680175909"><span class="hs-identifier hs-var">ut</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall t. HasEnd t =&gt; Lens' t (EndCore t :+ EndExtra t)
</span><a href="Geometry.Interval.html#end"><span class="hs-identifier hs-var">end</span></a></span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span>    </span><span id="local-6989586621680175902"><span class="annot"><span class="annottext">adj :: Adj
</span><a href="#local-6989586621680175902"><span class="hs-identifier hs-var hs-var">adj</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680175912"><span class="hs-identifier hs-var">ld</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. IntMap a -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-operator hs-var">`IM.union`</span></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621680175911"><span class="hs-identifier hs-var">rd</span></a></span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-keyword">type</span><span> </span><span id="Merge"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-var">Merge</span></a></span></span><span> </span><span id="local-6989586621680175895"><span class="annot"><a href="#local-6989586621680175895"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621680175894"><span class="annot"><a href="#local-6989586621680175894"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Reader</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175895"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175894"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-type">Firsts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-keyword">type</span><span> </span><span id="Firsts"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-var">Firsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IM.IntMap</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span>
</span><span id="line-143"></span><span>
</span><span id="line-144"></span><span class="hs-comment">-- | Merges the two delaunay traingulations.</span><span>
</span><span id="line-145"></span><span id="local-6989586621680176324"><span id="local-6989586621680176325"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-type">moveUp</span></a></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176325"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680176325"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-146"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176324"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176325"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-147"></span><span id="moveUp"><span class="annot"><span class="annottext">moveUp :: forall r p.
(Ord r, Fractional r) =&gt;
(VertexID, VertexID) -&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-var hs-var">moveUp</span></a></span></span><span> </span><span id="local-6989586621680175862"><span class="annot"><span class="annottext">(VertexID, VertexID)
</span><a href="#local-6989586621680175862"><span class="hs-identifier hs-var">ut</span></a></span></span><span> </span><span id="local-6989586621680175861"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621680175860"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span></span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">(VertexID, VertexID)
</span><a href="#local-6989586621680175862"><span class="hs-identifier hs-var">ut</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p. (Num r, Ord r) =&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-150"></span><span>                     </span><span class="annot"><span class="annottext">forall r p. (Num r, Ord r) =&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-151"></span><span>                     </span><span class="hs-comment">-- Get the neighbours of r and l along the convex hull</span><span>
</span><span id="line-152"></span><span>                     </span><span id="local-6989586621680175858"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175858"><span class="hs-identifier hs-var">r1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s (m :: * -&gt; *) a. MonadState s m =&gt; (s -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">gets</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var">pred'</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-var">rotateTo</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. VertexID -&gt; IntMap a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-var">lookup''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-153"></span><span>                     </span><span id="local-6989586621680175853"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175853"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s (m :: * -&gt; *) a. MonadState s m =&gt; (s -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">gets</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var">succ'</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-var">rotateTo</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. VertexID -&gt; IntMap a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-var">lookup''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span>                     </span><span class="hs-special">(</span><span id="local-6989586621680175851"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175851"><span class="hs-identifier hs-var">r1'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175850"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680175850"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR"><span class="hs-identifier hs-var">rotateR</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175858"><span class="hs-identifier hs-var">r1</span></a></span><span>
</span><span id="line-156"></span><span>                     </span><span class="hs-special">(</span><span id="local-6989586621680175848"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175848"><span class="hs-identifier hs-var">l1'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175847"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680175847"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL"><span class="hs-identifier hs-var">rotateL</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175853"><span class="hs-identifier hs-var">l1</span></a></span><span>
</span><span id="line-157"></span><span>                     </span><span id="local-6989586621680175845"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680175845"><span class="hs-identifier hs-var">c</span></a></span></span><span>       </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var">qTest</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175851"><span class="hs-identifier hs-var">r1'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175848"><span class="hs-identifier hs-var">l1'</span></a></span><span>
</span><span id="line-158"></span><span>                     </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621680175843"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175843"><span class="hs-identifier hs-var">l'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175842"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175842"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680175850"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680175847"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621680175845"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-159"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175848"><span class="hs-identifier hs-var">l1'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span>          </span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175851"><span class="hs-identifier hs-var">r1'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175861"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span>          </span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175851"><span class="hs-identifier hs-var">r1'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-162"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175848"><span class="hs-identifier hs-var">l1'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175860"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-163"></span><span>                     </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
(VertexID, VertexID) -&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-var">moveUp</span></a></span><span> </span><span class="annot"><span class="annottext">(VertexID, VertexID)
</span><a href="#local-6989586621680175862"><span class="hs-identifier hs-var">ut</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175843"><span class="hs-identifier hs-var">l'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175842"><span class="hs-identifier hs-var">r'</span></a></span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span class="hs-comment">-- | \'rotates\' around r and removes all neighbours of r that violate the</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- delaunay condition. Returns the first vertex (as a Neighbour of r) that</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- should remain in the Delaunay Triangulation, as well as a boolean A that</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- helps deciding if we merge up by rotating left or rotating right (See</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- description in the paper for more info)</span><span>
</span><span id="line-171"></span><span id="local-6989586621680176303"><span id="local-6989586621680176304"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR"><span class="hs-identifier hs-type">rotateR</span></a></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176304"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680176304"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-172"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176303"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176304"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-173"></span><span id="rotateR"><span class="annot"><span class="annottext">rotateR :: forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR"><span class="hs-identifier hs-var hs-var">rotateR</span></a></span></span><span> </span><span id="local-6989586621680175821"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175821"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621680175820"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175820"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621680175819"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175819"><span class="hs-identifier hs-var">r1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175819"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Num r) =&gt;
VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isLeftOf"><span class="hs-operator hs-var">`isLeftOf`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175821"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175820"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-174"></span><span>                   </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR%27"><span class="hs-identifier hs-var">rotateR'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175821"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175820"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175819"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var">pred'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175819"><span class="hs-identifier hs-var">r1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-175"></span><span>                   </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175819"><span class="hs-identifier hs-var">r1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="hs-comment">-- | The code that does the actual rotating</span><span>
</span><span id="line-179"></span><span id="local-6989586621680176285"><span id="local-6989586621680176286"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR%27"><span class="hs-identifier hs-type">rotateR'</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176286"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680176286"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-180"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176285"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176286"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span></span></span><span>
</span><span id="line-181"></span><span id="rotateR%27"><span class="annot"><span class="annottext">rotateR' :: forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR%27"><span class="hs-identifier hs-var hs-var">rotateR'</span></a></span></span><span> </span><span id="local-6989586621680175804"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175804"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621680175803"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175803"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
</span><a href="#local-6989586621680175802"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-182"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-183"></span><span>    </span><span id="local-6989586621680175802"><span class="annot"><span class="annottext">go :: CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
</span><a href="#local-6989586621680175802"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621680175801"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175801"><span class="hs-identifier hs-var">r1</span></a></span></span><span> </span><span id="local-6989586621680175800"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175800"><span class="hs-identifier hs-var">r2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var">qTest</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175804"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175803"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175801"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175800"><span class="hs-identifier hs-var">r2</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-184"></span><span>                 </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175801"><span class="hs-identifier hs-var">r1</span></a></span><span>
</span><span id="line-185"></span><span>                 </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-var">delete</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175803"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175801"><span class="hs-identifier hs-var">r1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-186"></span><span>                             </span><span class="annot"><span class="annottext">CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
</span><a href="#local-6989586621680175802"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175800"><span class="hs-identifier hs-var">r2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var">pred'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175800"><span class="hs-identifier hs-var">r2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-187"></span><span>
</span><span id="line-188"></span><span>
</span><span id="line-189"></span><span class="hs-comment">-- | Symmetric to rotateR</span><span>
</span><span id="line-190"></span><span id="local-6989586621680175796"><span id="local-6989586621680175797"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL"><span class="hs-identifier hs-type">rotateL</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680175797"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680175797"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-191"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175796"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175797"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-192"></span><span id="rotateL"><span class="annot"><span class="annottext">rotateL :: forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL"><span class="hs-identifier hs-var hs-var">rotateL</span></a></span></span><span> </span><span id="local-6989586621680175781"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175781"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621680175780"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175780"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621680175779"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175779"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175779"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Num r) =&gt;
VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isRightOf"><span class="hs-operator hs-var">`isRightOf`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175780"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175781"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-193"></span><span>                   </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL%27"><span class="hs-identifier hs-var">rotateL'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175781"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175780"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175779"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var">succ'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175779"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>                   </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175779"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span class="hs-comment">-- | The code that does the actual rotating. Symmetric to rotateR'</span><span>
</span><span id="line-197"></span><span id="local-6989586621680175775"><span id="local-6989586621680175776"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL%27"><span class="hs-identifier hs-type">rotateL'</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680175776"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680175776"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175775"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175776"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span></span></span><span>
</span><span id="line-199"></span><span id="rotateL%27"><span class="annot"><span class="annottext">rotateL' :: forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL%27"><span class="hs-identifier hs-var hs-var">rotateL'</span></a></span></span><span> </span><span id="local-6989586621680175762"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175762"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621680175761"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175761"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
</span><a href="#local-6989586621680175760"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-200"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-201"></span><span>    </span><span id="local-6989586621680175760"><span class="annot"><span class="annottext">go :: CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
</span><a href="#local-6989586621680175760"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621680175759"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175759"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span id="local-6989586621680175758"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175758"><span class="hs-identifier hs-var">l2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var">qTest</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175762"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175761"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175759"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175758"><span class="hs-identifier hs-var">l2</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-202"></span><span>                 </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175759"><span class="hs-identifier hs-var">l1</span></a></span><span>
</span><span id="line-203"></span><span>                 </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-var">delete</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175762"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175759"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-204"></span><span>                             </span><span class="annot"><span class="annottext">CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
</span><a href="#local-6989586621680175760"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175758"><span class="hs-identifier hs-var">l2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var">succ'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175758"><span class="hs-identifier hs-var">l2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-207"></span><span class="hs-comment">-- * Primitives used by the Algorithm</span><span>
</span><span id="line-208"></span><span>
</span><span id="line-209"></span><span class="hs-comment">-- | returns True if the forth point (vertex) does not lie in the disk defined</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- by the first three points.</span><span>
</span><span id="line-211"></span><span id="local-6989586621680176301"><span id="local-6989586621680176302"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-type">qTest</span></a></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176302"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621680176302"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-212"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176301"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176302"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-213"></span><span id="qTest"><span class="annot"><span class="annottext">qTest :: forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var hs-var">qTest</span></a></span></span><span> </span><span id="local-6989586621680175730"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175730"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span id="local-6989586621680175729"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175729"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621680175728"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175728"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span id="local-6989586621680175727"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175727"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621680175725"><span class="hs-identifier hs-var">withPtMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span>
</span><span id="line-214"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-215"></span><span>    </span><span id="local-6989586621680175725"><span class="annot"><span class="annottext">withPtMap :: Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621680175725"><span class="hs-identifier hs-var hs-var">withPtMap</span></a></span></span><span> </span><span id="local-6989586621680175724"><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175724"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621680175723"><span class="annot"><span class="annottext">h' :: Point 2 r :+ p
</span><a href="#local-6989586621680175723"><span class="hs-identifier hs-var hs-var">h'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175724"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175730"><span class="hs-identifier hs-var">h</span></a></span><span>
</span><span id="line-216"></span><span>                          </span><span id="local-6989586621680175721"><span class="annot"><span class="annottext">i' :: Point 2 r :+ p
</span><a href="#local-6989586621680175721"><span class="hs-identifier hs-var hs-var">i'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175724"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175729"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-217"></span><span>                          </span><span id="local-6989586621680175720"><span class="annot"><span class="annottext">j' :: Point 2 r :+ p
</span><a href="#local-6989586621680175720"><span class="hs-identifier hs-var hs-var">j'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175724"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175728"><span class="hs-identifier hs-var">j</span></a></span><span>
</span><span id="line-218"></span><span>                          </span><span id="local-6989586621680175719"><span class="annot"><span class="annottext">k' :: Point 2 r :+ p
</span><a href="#local-6989586621680175719"><span class="hs-identifier hs-var hs-var">k'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175724"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175727"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-219"></span><span>                      </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680175719"><span class="hs-identifier hs-var">k'</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (d :: Nat) r p.
(Arity d, Ord r, Num r) =&gt;
Point d r -&gt; Ball d p r -&gt; Bool
</span><a href="Geometry.Ball.html#insideBall"><span class="hs-operator hs-var">`insideBall`</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {r} {extra} {extra} {extra}.
(Ord r, Fractional r) =&gt;
(Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; Maybe (Disk () r)
</span><a href="#local-6989586621680175716"><span class="hs-identifier hs-var">disk'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680175723"><span class="hs-identifier hs-var">h'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680175721"><span class="hs-identifier hs-var">i'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680175720"><span class="hs-identifier hs-var">j'</span></a></span><span>
</span><span id="line-220"></span><span>    </span><span id="local-6989586621680175716"><span class="annot"><span class="annottext">disk' :: (Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; Maybe (Disk () r)
</span><a href="#local-6989586621680175716"><span class="hs-identifier hs-var hs-var">disk'</span></a></span></span><span> </span><span id="local-6989586621680175708"><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621680175708"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621680175707"><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621680175707"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621680175706"><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621680175706"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r.
(Ord r, Fractional r) =&gt;
Point 2 r -&gt; Point 2 r -&gt; Point 2 r -&gt; Maybe (Disk () r)
</span><a href="Geometry.Ball.html#disk"><span class="hs-identifier hs-var">disk</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621680175708"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621680175707"><span class="hs-identifier hs-var">q</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621680175706"><span class="hs-identifier hs-var">r</span></a></span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span class="hs-comment">-- | Inserts an edge into the right position.</span><span>
</span><span id="line-223"></span><span id="local-6989586621680176311"><span id="local-6989586621680176312"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-type">insert</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621680176312"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176312"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176311"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176312"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-224"></span><span id="insert"><span class="annot"><span class="annottext">insert :: forall r p. (Num r, Ord r) =&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-var hs-var">insert</span></a></span></span><span> </span><span id="local-6989586621680175693"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175693"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span id="local-6989586621680175692"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175692"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-225"></span><span>               </span><span class="hs-special">(</span><span id="local-6989586621680175691"><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621680175691"><span class="hs-identifier hs-var">mapping'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175690"><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621680175690"><span class="hs-identifier hs-var">fsts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall r (m :: * -&gt; *). MonadReader r m =&gt; m r
</span><span class="hs-identifier hs-var">ask</span></span><span>
</span><span id="line-226"></span><span>               </span><span class="annot"><span class="annottext">forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall r p.
(Num r, Ord r) =&gt;
VertexID -&gt; VertexID -&gt; Mapping p r -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert%27"><span class="hs-identifier hs-var">insert'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175693"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175692"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621680175691"><span class="hs-identifier hs-var">mapping'</span></a></span><span>
</span><span id="line-227"></span><span>               </span><span class="annot"><span class="annottext">forall p r. VertexID -&gt; Firsts -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-var">rotateToFirst</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175693"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621680175690"><span class="hs-identifier hs-var">fsts</span></a></span><span>
</span><span id="line-228"></span><span>               </span><span class="annot"><span class="annottext">forall p r. VertexID -&gt; Firsts -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-var">rotateToFirst</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175692"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621680175690"><span class="hs-identifier hs-var">fsts</span></a></span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="hs-comment">-- | make sure that the first vtx in the adj list of v is its predecessor on the CH</span><span>
</span><span id="line-232"></span><span id="local-6989586621680176239"><span id="local-6989586621680176240"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-type">rotateToFirst</span></a></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-type">Firsts</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176240"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176239"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-233"></span><span id="rotateToFirst"><span class="annot"><span class="annottext">rotateToFirst :: forall p r. VertexID -&gt; Firsts -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-var hs-var">rotateToFirst</span></a></span></span><span> </span><span id="local-6989586621680175680"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175680"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621680175679"><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621680175679"><span class="hs-identifier hs-var">fsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjust</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621680175677"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175680"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-235"></span><span>    </span><span id="local-6989586621680175676"><span class="annot"><span class="annottext">mfst :: Maybe VertexID
</span><a href="#local-6989586621680175676"><span class="hs-identifier hs-var hs-var">mfst</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. VertexID -&gt; IntMap a -&gt; Maybe a
</span><span class="hs-identifier hs-var">IM.lookup</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175680"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621680175679"><span class="hs-identifier hs-var">fsts</span></a></span><span>
</span><span id="line-236"></span><span>    </span><span id="local-6989586621680175677"><span class="annot"><span class="annottext">f :: CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621680175677"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span>  </span><span id="local-6989586621680175674"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175674"><span class="hs-identifier hs-var">cl</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175674"><span class="hs-identifier hs-var">cl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Maybe VertexID
</span><a href="#local-6989586621680175676"><span class="hs-identifier hs-var">mfst</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CList a -&gt; Maybe (CList a)
</span><span class="hs-identifier hs-var">CL.rotateTo</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621680175674"><span class="hs-identifier hs-var">cl</span></a></span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span>
</span><span id="line-239"></span><span class="hs-comment">-- | Inserts an edge (and makes sure that the vertex is inserted in the</span><span>
</span><span id="line-240"></span><span class="hs-comment">-- correct. pos in the adjacency lists)</span><span>
</span><span id="line-241"></span><span id="local-6989586621680176241"><span id="local-6989586621680176242"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert%27"><span class="hs-identifier hs-type">insert'</span></a></span><span>               </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621680176242"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176242"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>                      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176241"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176242"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span></span></span><span>
</span><span id="line-243"></span><span id="insert%27"><span class="annot"><span class="annottext">insert' :: forall r p.
(Num r, Ord r) =&gt;
VertexID -&gt; VertexID -&gt; Mapping p r -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert%27"><span class="hs-identifier hs-var hs-var">insert'</span></a></span></span><span> </span><span id="local-6989586621680175668"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175668"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span id="local-6989586621680175667"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175667"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span id="local-6989586621680175666"><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175666"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (VertexID -&gt; a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjustWithKey</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621680175664"><span class="hs-identifier hs-var">insert''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175667"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175668"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-244"></span><span>                      </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. (VertexID -&gt; a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjustWithKey</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621680175664"><span class="hs-identifier hs-var">insert''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175668"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175667"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-245"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-246"></span><span>    </span><span class="hs-comment">-- inserts b into the adjacency list of a</span><span>
</span><span id="line-247"></span><span>    </span><span id="local-6989586621680175664"><span class="annot"><span class="annottext">insert'' :: VertexID -&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621680175664"><span class="hs-identifier hs-var hs-var">insert''</span></a></span></span><span> </span><span id="local-6989586621680175663"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175663"><span class="hs-identifier hs-var">bi</span></a></span></span><span> </span><span id="local-6989586621680175662"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175662"><span class="hs-identifier hs-var">ai</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a -&gt; Ordering) -&gt; a -&gt; CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CU.insertOrdBy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {r} {c} {p} {q}.
(Num r, Ord r) =&gt;
(Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
</span><a href="#local-6989586621680175660"><span class="hs-identifier hs-var">cmp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175666"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175662"><span class="hs-identifier hs-var">ai</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175666"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175663"><span class="hs-identifier hs-var">bi</span></a></span><span>
</span><span id="line-248"></span><span>    </span><span id="local-6989586621680175660"><span class="annot"><span class="annottext">cmp :: (Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
</span><a href="#local-6989586621680175660"><span class="hs-identifier hs-var hs-var">cmp</span></a></span></span><span> </span><span id="local-6989586621680175637"><span class="annot"><span class="annottext">Point 2 r :+ c
</span><a href="#local-6989586621680175637"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621680175636"><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680175636"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621680175635"><span class="annot"><span class="annottext">Point 2 r :+ q
</span><a href="#local-6989586621680175635"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {r} {c} {p} {q}.
(Num r, Ord r) =&gt;
(Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
</span><a href="Geometry.Point.Orientation.Degenerate.html#cwCmpAround%27"><span class="hs-identifier hs-var">cwCmpAround'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ c
</span><a href="#local-6989586621680175637"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680175636"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ q
</span><a href="#local-6989586621680175635"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall r (d :: Nat) c p q.
(Ord r, Num r, Arity d) =&gt;
(Point d r :+ c)
-&gt; (Point d r :+ p) -&gt; (Point d r :+ q) -&gt; Ordering
</span><a href="Geometry.Point.Internal.html#cmpByDistanceTo%27"><span class="hs-identifier hs-var">cmpByDistanceTo'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ c
</span><a href="#local-6989586621680175637"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621680175636"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ q
</span><a href="#local-6989586621680175635"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-249"></span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span class="hs-comment">-- | Deletes an edge</span><span>
</span><span id="line-252"></span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-type">delete</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span>
</span><span id="line-253"></span><span id="delete"><span class="annot"><span class="annottext">delete :: VertexID -&gt; VertexID -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-var hs-var">delete</span></a></span></span><span> </span><span id="local-6989586621680175632"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175632"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span id="local-6989586621680175631"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175631"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjust</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="#local-6989586621680175630"><span class="hs-identifier hs-var">delete'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175631"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175632"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjust</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="#local-6989586621680175630"><span class="hs-identifier hs-var">delete'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175632"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175631"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-254"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-255"></span><span>    </span><span id="local-6989586621680175630"><span class="annot"><span class="annottext">delete' :: a -&gt; CList a -&gt; CList a
</span><a href="#local-6989586621680175630"><span class="hs-identifier hs-var hs-var">delete'</span></a></span></span><span> </span><span id="local-6989586621680175627"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175627"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CL.filterL</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175627"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- should we rotate left or right if it is the focus?</span><span>
</span><span id="line-256"></span><span>
</span><span id="line-257"></span><span>
</span><span id="line-258"></span><span class="hs-comment">-- | Lifted version of Convex.IsLeftOf</span><span>
</span><span id="line-259"></span><span id="local-6989586621680176290"><span id="local-6989586621680176291"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isLeftOf"><span class="hs-identifier hs-type">isLeftOf</span></a></span><span>           </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176291"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621680176291"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>                   </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176290"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176291"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-261"></span><span id="local-6989586621680175613"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175613"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="isLeftOf"><span class="annot"><span class="annottext">isLeftOf :: forall r p.
(Ord r, Num r) =&gt;
VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isLeftOf"><span class="hs-operator hs-var hs-var">`isLeftOf`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680175612"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175612"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175611"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175611"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621680175610"><span class="hs-identifier hs-var">withPtMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span>
</span><span id="line-262"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-263"></span><span>    </span><span id="local-6989586621680175610"><span class="annot"><span class="annottext">withPtMap :: Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621680175610"><span class="hs-identifier hs-var hs-var">withPtMap</span></a></span></span><span> </span><span id="local-6989586621680175609"><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175609"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175609"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175613"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall {r} {pointP} {pointQ} {pointR}.
(Ord r, Num r, ToAPoint pointP 2 r, ToAPoint pointQ 2 r,
 ToAPoint pointR 2 r) =&gt;
pointR -&gt; (pointP, pointQ) -&gt; Bool
</span><a href="#local-6989586621680175608"><span class="hs-operator hs-var">`isLeftOf'`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175609"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175612"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175609"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175611"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-264"></span><span>    </span><span id="local-6989586621680175595"><span class="annot"><span class="annottext">pointR
</span><a href="#local-6989586621680175595"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621680175608"><span class="annot"><span class="annottext">isLeftOf' :: pointR -&gt; (pointP, pointQ) -&gt; Bool
</span><a href="#local-6989586621680175608"><span class="hs-operator hs-var hs-var">`isLeftOf'`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680175594"><span class="annot"><span class="annottext">pointP
</span><a href="#local-6989586621680175594"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175593"><span class="annot"><span class="annottext">pointQ
</span><a href="#local-6989586621680175593"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r pointP pointQ pointR.
(Ord r, Num r, ToAPoint pointP 2 r, ToAPoint pointQ 2 r,
 ToAPoint pointR 2 r) =&gt;
pointP -&gt; pointQ -&gt; pointR -&gt; CCW
</span><a href="Geometry.Point.Orientation.Degenerate.html#ccw"><span class="hs-identifier hs-var">ccw</span></a></span><span> </span><span class="annot"><span class="annottext">pointP
</span><a href="#local-6989586621680175594"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">pointQ
</span><a href="#local-6989586621680175593"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">pointR
</span><a href="#local-6989586621680175595"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">CCW
</span><a href="Geometry.Point.Orientation.Degenerate.html#CCW"><span class="hs-identifier hs-var">CCW</span></a></span><span>
</span><span id="line-265"></span><span>
</span><span id="line-266"></span><span class="hs-comment">-- | Lifted version of Convex.IsRightOf</span><span>
</span><span id="line-267"></span><span id="local-6989586621680175589"><span id="local-6989586621680175590"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isRightOf"><span class="hs-identifier hs-type">isRightOf</span></a></span><span>           </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680175590"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621680175590"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-268"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175589"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680175590"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-269"></span><span id="local-6989586621680175578"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175578"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="isRightOf"><span class="annot"><span class="annottext">isRightOf :: forall r p.
(Ord r, Num r) =&gt;
VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isRightOf"><span class="hs-operator hs-var hs-var">`isRightOf`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680175577"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175577"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175576"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175576"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621680175575"><span class="hs-identifier hs-var">withPtMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span>
</span><span id="line-270"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-271"></span><span>    </span><span id="local-6989586621680175575"><span class="annot"><span class="annottext">withPtMap :: Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621680175575"><span class="hs-identifier hs-var hs-var">withPtMap</span></a></span></span><span> </span><span id="local-6989586621680175574"><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175574"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175574"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175578"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall {r} {pointP} {pointQ} {pointR}.
(Ord r, Num r, ToAPoint pointP 2 r, ToAPoint pointQ 2 r,
 ToAPoint pointR 2 r) =&gt;
pointR -&gt; (pointP, pointQ) -&gt; Bool
</span><a href="#local-6989586621680175573"><span class="hs-operator hs-var">`isRightOf'`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175574"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175577"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621680175574"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175576"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-272"></span><span>    </span><span id="local-6989586621680175561"><span class="annot"><span class="annottext">pointR
</span><a href="#local-6989586621680175561"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621680175573"><span class="annot"><span class="annottext">isRightOf' :: pointR -&gt; (pointP, pointQ) -&gt; Bool
</span><a href="#local-6989586621680175573"><span class="hs-operator hs-var hs-var">`isRightOf'`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621680175560"><span class="annot"><span class="annottext">pointP
</span><a href="#local-6989586621680175560"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621680175559"><span class="annot"><span class="annottext">pointQ
</span><a href="#local-6989586621680175559"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r pointP pointQ pointR.
(Ord r, Num r, ToAPoint pointP 2 r, ToAPoint pointQ 2 r,
 ToAPoint pointR 2 r) =&gt;
pointP -&gt; pointQ -&gt; pointR -&gt; CCW
</span><a href="Geometry.Point.Orientation.Degenerate.html#ccw"><span class="hs-identifier hs-var">ccw</span></a></span><span> </span><span class="annot"><span class="annottext">pointP
</span><a href="#local-6989586621680175560"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">pointQ
</span><a href="#local-6989586621680175559"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">pointR
</span><a href="#local-6989586621680175561"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">CCW
</span><a href="Geometry.Point.Orientation.Degenerate.html#CW"><span class="hs-identifier hs-var">CW</span></a></span><span>
</span><span id="line-273"></span><span>
</span><span id="line-274"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-275"></span><span class="hs-comment">-- * Some Helper functions</span><span>
</span><span id="line-276"></span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span id="local-6989586621680176420"><span id="local-6989586621680176421"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-type">lookup'</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621680176421"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="#local-6989586621680176421"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><a href="#local-6989586621680176420"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680176421"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680176420"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-279"></span><span id="lookup%27"><span class="annot"><span class="annottext">lookup' :: forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var hs-var">lookup'</span></a></span></span><span> </span><span id="local-6989586621680175553"><span class="annot"><span class="annottext">Map k a
</span><a href="#local-6989586621680175553"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621680175552"><span class="annot"><span class="annottext">k
</span><a href="#local-6989586621680175552"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">M.lookup</span></span><span> </span><span class="annot"><span class="annottext">k
</span><a href="#local-6989586621680175552"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Map k a
</span><a href="#local-6989586621680175553"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span id="local-6989586621680176423"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-type">size'</span></a></span><span>              </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">BinLeafTree</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Size</span></span><span> </span><span class="annot"><a href="#local-6989586621680176423"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Size</span></span></span><span>
</span><span id="line-282"></span><span id="size%27"><span class="annot"><span class="annottext">size' :: forall a. BinLeafTree Size a -&gt; Size
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var hs-var">size'</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Leaf</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Size
</span><span class="hs-number">1</span></span><span>
</span><span id="line-283"></span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var">size'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size a
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621680175549"><span class="annot"><span class="annottext">Size
</span><a href="#local-6989586621680175549"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Size
</span><a href="#local-6989586621680175549"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-284"></span><span>
</span><span id="line-285"></span><span class="hs-comment">-- | an \'unsafe\' version of rotateTo that assumes the element to rotate to</span><span>
</span><span id="line-286"></span><span class="hs-comment">-- occurs in the list.</span><span>
</span><span id="line-287"></span><span id="local-6989586621680176306"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-type">rotateTo</span></a></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621680176306"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680176306"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621680176306"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621680176306"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-288"></span><span id="rotateTo"><span class="annot"><span class="annottext">rotateTo :: forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-var hs-var">rotateTo</span></a></span></span><span> </span><span id="local-6989586621680175544"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175544"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CList a -&gt; Maybe (CList a)
</span><span class="hs-identifier hs-var">CL.rotateTo</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621680175544"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-289"></span><span>
</span><span id="line-290"></span><span class="hs-comment">-- | Adjacency lists are stored in clockwise order, so pred means rotate right</span><span>
</span><span id="line-291"></span><span id="local-6989586621680176307"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-type">pred'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621680176307"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621680176307"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-292"></span><span id="pred%27"><span class="annot"><span class="annottext">pred' :: forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var hs-var">pred'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CL.rotR</span></span><span>
</span><span id="line-293"></span><span>
</span><span id="line-294"></span><span class="hs-comment">-- | Adjacency lists are stored in clockwise order, so pred and succ rotate left</span><span>
</span><span id="line-295"></span><span id="local-6989586621680175542"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-type">succ'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621680175542"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621680175542"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-296"></span><span id="succ%27"><span class="annot"><span class="annottext">succ' :: forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var hs-var">succ'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CL.rotL</span></span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span class="hs-comment">-- | Return the focus of the CList, throwing an exception if the list is empty.</span><span>
</span><span id="line-299"></span><span id="local-6989586621680176300"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-type">focus'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621680176300"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680176300"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-300"></span><span id="focus%27"><span class="annot"><span class="annottext">focus' :: forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var hs-var">focus'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. CList a -&gt; Maybe a
</span><span class="hs-identifier hs-var">CL.focus</span></span><span>
</span><span id="line-301"></span><span>
</span><span id="line-302"></span><span class="hs-comment">-- | Removes duplicates from a sorted list</span><span>
</span><span id="line-303"></span><span id="local-6989586621680176468"><span id="local-6989586621680176469"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#nub%27"><span class="hs-identifier hs-type">nub'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621680176469"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176469"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621680176468"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176469"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621680176468"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-304"></span><span id="nub%27"><span class="annot"><span class="annottext">nub' :: forall a b. Eq a =&gt; NonEmpty (a :+ b) -&gt; NonEmpty (a :+ b)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#nub%27"><span class="hs-identifier hs-var hs-var">nub'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">forall a. NonEmpty a -&gt; a
</span><span class="hs-identifier hs-var">NonEmpty.head</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a -&gt; Bool) -&gt; NonEmpty a -&gt; NonEmpty (NonEmpty a)
</span><span class="hs-identifier hs-var">NonEmpty.groupBy1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">(==)</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-305"></span><span>
</span><span id="line-306"></span><span>
</span><span id="line-307"></span><span id="local-6989586621680176410"><span id="local-6989586621680176411"><span id="local-6989586621680176412"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-type">withID</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621680176412"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621680176411"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680176410"><span class="hs-identifier hs-type">e'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680176412"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621680176411"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621680176410"><span class="hs-identifier hs-type">e'</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-308"></span><span id="withID"><span class="annot"><span class="annottext">withID :: forall c e e'. (c :+ e) -&gt; e' -&gt; c :+ (e :+ e')
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-var hs-var">withID</span></a></span></span><span> </span><span id="local-6989586621680175529"><span class="annot"><span class="annottext">c :+ e
</span><a href="#local-6989586621680175529"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621680175528"><span class="annot"><span class="annottext">e'
</span><a href="#local-6989586621680175528"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">c :+ e
</span><a href="#local-6989586621680175529"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span class="annot"><span class="annottext">forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span> </span><span class="annot"><span class="annottext">forall s t a b. ASetter s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-operator hs-var">%~</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall core extra. core -&gt; extra -&gt; core :+ extra
</span><span class="hs-operator hs-var">:+</span></span><span class="annot"><span class="annottext">e'
</span><a href="#local-6989586621680175528"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-309"></span><span>
</span><span id="line-310"></span><span id="local-6989586621680176305"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-type">lookup''</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IM.IntMap</span></span><span> </span><span class="annot"><a href="#local-6989586621680176305"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621680176305"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-311"></span><span id="lookup%27%27"><span class="annot"><span class="annottext">lookup'' :: forall a. VertexID -&gt; IntMap a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-var hs-var">lookup''</span></a></span></span><span> </span><span id="local-6989586621680175524"><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175524"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621680175523"><span class="annot"><span class="annottext">IntMap a
</span><a href="#local-6989586621680175523"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IntMap a
</span><a href="#local-6989586621680175523"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. IntMap a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">IM.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621680175524"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-312"></span></pre></body></html>