-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reading and Writing ipe7 files.
--   
--   Reading and Writing ipe7 files and converting them to and from
--   HGeometry types.
@package hgeometry-ipe
@version 0.14


-- | Use <tt>iperender</tt> to generate png, pdf, or svg files.
--   
--   Note that all functions in this module require that <tt>iperender</tt>
--   is installed (it is bundled with ipe) and available on the path.
module Ipe.IpeRender

-- | Call <tt>iperender</tt> to produce an image of the specified type.
--   
--   note that pdf files produces with iperender cannot be opened with ipe.
ipeRenderWith :: Options -> FileType -> FilePath -> FilePath -> IO ()

-- | Call <tt>iperender</tt> with the default options.
--   
--   note that pdf files produces with iperender cannot be opened with ipe.
ipeRender :: FileType -> FilePath -> FilePath -> IO ()

-- | Output filetypes supported by iperender
data FileType
PNG :: FileType
EPS :: FileType
PDF :: FileType
SVG :: FileType

-- | Options for iperender
data Options
Options :: Int -> Int -> Int -> Background -> Crop -> Options
[pageNumber] :: Options -> Int
[viewNumber] :: Options -> Int
[resolution] :: Options -> Int
[transparent] :: Options -> Background
[crop] :: Options -> Crop

-- | The default options in Ipe
defaultOptions :: Options

-- | Whether or not to render a transparent background in output png
--   images.
data Background
OpaqueBackground :: Background
TransparentBackground :: Background

-- | Whether or not to crop the output image.
data Crop
NoCrop :: Crop
Crop :: Crop
instance GHC.Classes.Ord Ipe.IpeRender.Options
instance GHC.Classes.Eq Ipe.IpeRender.Options
instance GHC.Show.Show Ipe.IpeRender.Options
instance GHC.Enum.Enum Ipe.IpeRender.Crop
instance GHC.Classes.Ord Ipe.IpeRender.Crop
instance GHC.Classes.Eq Ipe.IpeRender.Crop
instance GHC.Read.Read Ipe.IpeRender.Crop
instance GHC.Show.Show Ipe.IpeRender.Crop
instance GHC.Enum.Enum Ipe.IpeRender.Background
instance GHC.Classes.Ord Ipe.IpeRender.Background
instance GHC.Classes.Eq Ipe.IpeRender.Background
instance GHC.Read.Read Ipe.IpeRender.Background
instance GHC.Show.Show Ipe.IpeRender.Background
instance GHC.Enum.Enum Ipe.IpeRender.FileType
instance GHC.Classes.Ord Ipe.IpeRender.FileType
instance GHC.Classes.Eq Ipe.IpeRender.FileType
instance GHC.Show.Show Ipe.IpeRender.FileType


-- | Layers in Ipe documents.
module Ipe.Layer

-- | Defines an Layer in Ipe.
newtype LayerName
LayerName :: Text -> LayerName
layerName :: Iso' LayerName Text
instance Data.String.IsString Ipe.Layer.LayerName
instance GHC.Classes.Ord Ipe.Layer.LayerName
instance GHC.Classes.Eq Ipe.Layer.LayerName
instance GHC.Read.Read Ipe.Layer.LayerName
instance GHC.Show.Show Ipe.Layer.LayerName


-- | Including xml literals
module Ipe.Literal

-- | Include a literal expression
literally :: String -> Q Exp

-- | Literal quoter.
lit :: QuasiQuoter

-- | Include a file as a literal.
litFile :: QuasiQuoter

-- | Parse a string into a Node.
xmlLiteral :: String -> Node Text Text


-- | Defines an Ipe Path.
module Ipe.Path

-- | A path is a non-empty sequence of PathSegments.
newtype Path r
Path :: LSeq 1 (PathSegment r) -> Path r
pathSegments :: forall r_asuV r_aDBP. Iso (Path r_asuV) (Path r_aDBP) (LSeq 1 (PathSegment r_asuV)) (LSeq 1 (PathSegment r_aDBP))

-- | Paths
--   
--   Paths consist of Path Segments. PathSegments come in the following
--   forms:
data PathSegment r
PolyLineSegment :: PolyLine 2 () r -> PathSegment r
PolygonPath :: SimplePolygon () r -> PathSegment r
CubicBezierSegment :: BezierSpline 3 2 r -> PathSegment r
QuadraticBezierSegment :: BezierSpline 2 2 r -> PathSegment r
EllipseSegment :: Ellipse r -> PathSegment r
ArcSegment :: PathSegment r
SplineSegment :: PathSegment r
ClosedSplineSegment :: PathSegment r
_PolyLineSegment :: forall r_aqqa. Prism' (PathSegment r_aqqa) (PolyLine 2 () r_aqqa)
_PolygonPath :: forall r_aqqa. Prism' (PathSegment r_aqqa) (SimplePolygon () r_aqqa)
_CubicBezierSegment :: forall r_aqqa. Prism' (PathSegment r_aqqa) (BezierSpline 3 2 r_aqqa)
_QuadraticBezierSegment :: forall r_aqqa. Prism' (PathSegment r_aqqa) (BezierSpline 2 2 r_aqqa)
_EllipseSegment :: forall r_aqqa. Prism' (PathSegment r_aqqa) (Ellipse r_aqqa)
_ArcSegment :: forall r_aqqa. Prism' (PathSegment r_aqqa) ()
_SplineSegment :: forall r_aqqa. Prism' (PathSegment r_aqqa) ()
_ClosedSplineSegment :: forall r_aqqa. Prism' (PathSegment r_aqqa) ()

-- | type that represents a path in ipe.
data Operation r
MoveTo :: Point 2 r -> Operation r
LineTo :: Point 2 r -> Operation r
Ellipse :: Matrix 3 3 r -> Operation r
ArcTo :: Matrix 3 3 r -> Point 2 r -> Operation r
Spline :: [Point 2 r] -> Operation r
ClosedSpline :: [Point 2 r] -> Operation r
ClosePath :: Operation r
CurveTo :: Point 2 r -> Point 2 r -> Point 2 r -> Operation r
QCurveTo :: Point 2 r -> Point 2 r -> Operation r
_MoveTo :: forall r_aDC2. Prism' (Operation r_aDC2) (Point 2 r_aDC2)
_LineTo :: forall r_aDC2. Prism' (Operation r_aDC2) (Point 2 r_aDC2)
_CurveTo :: forall r_aDC2. Prism' (Operation r_aDC2) (Point 2 r_aDC2, Point 2 r_aDC2, Point 2 r_aDC2)
_QCurveTo :: forall r_aDC2. Prism' (Operation r_aDC2) (Point 2 r_aDC2, Point 2 r_aDC2)
_Ellipse :: forall r_aDC2. Prism' (Operation r_aDC2) (Matrix 3 3 r_aDC2)
_ArcTo :: forall r_aDC2. Prism' (Operation r_aDC2) (Matrix 3 3 r_aDC2, Point 2 r_aDC2)
_Spline :: forall r_aDC2. Prism' (Operation r_aDC2) [Point 2 r_aDC2]
_ClosedSpline :: forall r_aDC2. Prism' (Operation r_aDC2) [Point 2 r_aDC2]
_ClosePath :: forall r_aDC2. Prism' (Operation r_aDC2) ()
instance Data.Traversable.Traversable Ipe.Path.Operation
instance Data.Foldable.Foldable Ipe.Path.Operation
instance GHC.Base.Functor Ipe.Path.Operation
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Path.Operation r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Path.Operation r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Path.Path r)
instance Data.Traversable.Traversable Ipe.Path.Path
instance Data.Foldable.Foldable Ipe.Path.Path
instance GHC.Base.Functor Ipe.Path.Path
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Path.Path r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Path.Path r)
instance GHC.Base.Functor Ipe.Path.PathSegment
instance Data.Foldable.Foldable Ipe.Path.PathSegment
instance Data.Traversable.Traversable Ipe.Path.PathSegment
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Path.PathSegment r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Path.PathSegment r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Path.PathSegment r)


-- | Parser for a <tt>Path</tt> in Ipe.
module Ipe.PathParser

-- | Represent stuff that can be used as a coordinate in ipe. (similar to
--   show/read)
class Fractional r => Coordinate r
fromSeq :: Coordinate r => Integer -> Maybe (Int, Integer) -> r
fromSeq :: (Coordinate r, Ord r, Fractional r) => Integer -> Maybe (Int, Integer) -> r

-- | Running the parsers
--   
--   Read/parse a single coordinate value.
readCoordinate :: Coordinate r => Text -> Either Text r

-- | Read/parse a single point
readPoint :: Coordinate r => Text -> Either Text (Point 2 r)

-- | Try to read/parse a matrix.
readMatrix :: Coordinate r => Text -> Either Text (Matrix 3 3 r)

-- | Try to read/parse a Rectangle
readRectangle :: Coordinate r => Text -> Either Text (Rectangle () r)

-- | Run a parser
runParser :: Parser a -> Text -> Either Text a

-- | Parse a sequence of path operations.
readPathOperations :: Coordinate r => Text -> Either Text [Operation r]

-- | Parse an operation
pOperation :: forall r. Coordinate r => Parser (Operation r)
pPoint :: Coordinate r => Parser (Point 2 r)
pCoordinate :: Coordinate r => Parser r
instance (GHC.Classes.Eq l, GHC.Classes.Eq r) => GHC.Classes.Eq (Ipe.PathParser.Either' l r)
instance (GHC.Show.Show l, GHC.Show.Show r) => GHC.Show.Show (Ipe.PathParser.Either' l r)
instance (GHC.Base.Semigroup l, GHC.Base.Semigroup r) => GHC.Base.Semigroup (Ipe.PathParser.Either' l r)
instance (GHC.Base.Semigroup l, GHC.Base.Semigroup r, GHC.Base.Monoid r) => GHC.Base.Monoid (Ipe.PathParser.Either' l r)
instance Data.Fixed.HasResolution p => Ipe.PathParser.Coordinate (Data.Fixed.Fixed p)
instance Ipe.PathParser.Coordinate GHC.Types.Double
instance Ipe.PathParser.Coordinate GHC.Types.Float
instance Ipe.PathParser.Coordinate (GHC.Real.Ratio GHC.Integer.Type.Integer)
instance Ipe.PathParser.Coordinate (Data.RealNumber.Rational.RealNumber p)


-- | Data type for representing values in ipe.
module Ipe.Value

-- | Many types either consist of a symbolc value, or a value of type v
data IpeValue v
Named :: Text -> IpeValue v
Valued :: v -> IpeValue v
instance Data.Traversable.Traversable Ipe.Value.IpeValue
instance Data.Foldable.Foldable Ipe.Value.IpeValue
instance GHC.Base.Functor Ipe.Value.IpeValue
instance GHC.Classes.Ord v => GHC.Classes.Ord (Ipe.Value.IpeValue v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Ipe.Value.IpeValue v)
instance GHC.Read.Read v => GHC.Read.Read (Ipe.Value.IpeValue v)
instance GHC.Show.Show v => GHC.Show.Show (Ipe.Value.IpeValue v)
instance Data.String.IsString (Ipe.Value.IpeValue v)


-- | Data type for representing colors in ipe as well as the colors
--   available in the standard ipe stylesheet.
module Ipe.Color

-- | Defines a color in Ipe. Colors are either RGB Values or Named values.
newtype IpeColor r
IpeColor :: IpeValue (RGB r) -> IpeColor r

-- | Creates a named color
named :: Text -> IpeColor r
black :: IpeColor r
white :: IpeColor r
red :: IpeColor r
green :: IpeColor r
blue :: IpeColor r
yellow :: IpeColor r
orange :: IpeColor r
gold :: IpeColor r
purple :: IpeColor r
gray :: IpeColor r
brown :: IpeColor r
navy :: IpeColor r
pink :: IpeColor r
seagreen :: IpeColor r
turquoise :: IpeColor r
violet :: IpeColor r
darkblue :: IpeColor r
darkcyan :: IpeColor r
darkgray :: IpeColor r
darkgreen :: IpeColor r
darkmagenta :: IpeColor r
darkorange :: IpeColor r
darkred :: IpeColor r
lightblue :: IpeColor r
lightcyan :: IpeColor r
lightgray :: IpeColor r
lightgreen :: IpeColor r
lightyellow :: IpeColor r
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Color.IpeColor r)
instance GHC.Read.Read r => GHC.Read.Read (Ipe.Color.IpeColor r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Color.IpeColor r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (Ipe.Color.IpeColor r)
instance GHC.Base.Functor Ipe.Color.IpeColor
instance Data.Foldable.Foldable Ipe.Color.IpeColor
instance Data.Traversable.Traversable Ipe.Color.IpeColor


-- | Possible Attributes we can assign to items in an Ipe file
module Ipe.Attributes

-- | The possible Attributes supported in Ipe. To use these attributes,
--   you'll likely need their Singletons's version which is Prefixed by an
--   <a>S</a>. E.g. the <a>Fill</a> attribute is represented by a singleton
--   'SFill :: Sing Fill'.
data AttributeUniverse
Layer :: AttributeUniverse
Matrix :: AttributeUniverse
Pin :: AttributeUniverse
Transformations :: AttributeUniverse
Stroke :: AttributeUniverse
Fill :: AttributeUniverse
Pen :: AttributeUniverse
Size :: AttributeUniverse
Dash :: AttributeUniverse
LineCap :: AttributeUniverse
LineJoin :: AttributeUniverse
FillRule :: AttributeUniverse
Arrow :: AttributeUniverse
RArrow :: AttributeUniverse
StrokeOpacity :: AttributeUniverse
Opacity :: AttributeUniverse
Tiling :: AttributeUniverse
Gradient :: AttributeUniverse
Clip :: AttributeUniverse
type LayerSym0 = 'Layer
type MatrixSym0 = 'Matrix
type PinSym0 = 'Pin
type TransformationsSym0 = 'Transformations
type StrokeSym0 = 'Stroke
type FillSym0 = 'Fill
type PenSym0 = 'Pen
type SizeSym0 = 'Size
type DashSym0 = 'Dash
type LineCapSym0 = 'LineCap
type LineJoinSym0 = 'LineJoin
type FillRuleSym0 = 'FillRule
type ArrowSym0 = 'Arrow
type RArrowSym0 = 'RArrow
type StrokeOpacitySym0 = 'StrokeOpacity
type OpacitySym0 = 'Opacity
type TilingSym0 = 'Tiling
type GradientSym0 = 'Gradient
type ClipSym0 = 'Clip
data SAttributeUniverse :: AttributeUniverse -> Type
[SLayer] :: SAttributeUniverse 'Layer
[SMatrix] :: SAttributeUniverse 'Matrix
[SPin] :: SAttributeUniverse 'Pin
[STransformations] :: SAttributeUniverse 'Transformations
[SStroke] :: SAttributeUniverse 'Stroke
[SFill] :: SAttributeUniverse 'Fill
[SPen] :: SAttributeUniverse 'Pen
[SSize] :: SAttributeUniverse 'Size
[SDash] :: SAttributeUniverse 'Dash
[SLineCap] :: SAttributeUniverse 'LineCap
[SLineJoin] :: SAttributeUniverse 'LineJoin
[SFillRule] :: SAttributeUniverse 'FillRule
[SArrow] :: SAttributeUniverse 'Arrow
[SRArrow] :: SAttributeUniverse 'RArrow
[SStrokeOpacity] :: SAttributeUniverse 'StrokeOpacity
[SOpacity] :: SAttributeUniverse 'Opacity
[STiling] :: SAttributeUniverse 'Tiling
[SGradient] :: SAttributeUniverse 'Gradient
[SClip] :: SAttributeUniverse 'Clip

-- | IpeObjects may have attributes. Essentially attributes are (key,value)
--   pairs. The key is some name. Which attributes an object can have
--   depends on the type of the object. However, all ipe objects support
--   the Common Attributes
type CommonAttributes = [Layer, Matrix, Pin, Transformations]

-- | All attributes applicable to TextLabels
type TextLabelAttributes = CommonAttributes

-- | All attributes applicable to Minipages
type MiniPageAttributes = CommonAttributes

-- | All attributes applicable to Images
type ImageAttributes = CommonAttributes

-- | All attributes applicable to Symbols/Marks
type SymbolAttributes = CommonAttributes ++ [Stroke, Fill, Pen, Size]

-- | All attributes applicable to Paths
type PathAttributes = CommonAttributes ++ [Stroke, Fill, Dash, Pen, LineCap, LineJoin, FillRule, Arrow, RArrow, StrokeOpacity, Opacity, Tiling, Gradient]

-- | All attributes applicable to Groups
type GroupAttributes = CommonAttributes ++ '[ 'Clip]

-- | Attr implements the mapping from labels to types as specified by the
--   (symbol representing) the type family <tt>f</tt>
newtype Attr (f :: TyFun u * -> *) (label :: u)
GAttr :: Maybe (Apply f label) -> Attr (f :: TyFun u * -> *) (label :: u)
[_getAttr] :: Attr (f :: TyFun u * -> *) (label :: u) -> Maybe (Apply f label)
getAttr :: forall f_a1aDy label_a1aDz f_a1bQT label_a1bQU. Iso (Attr f_a1aDy label_a1aDz) (Attr f_a1bQT label_a1bQU) (Maybe (Apply f_a1aDy label_a1aDz)) (Maybe (Apply f_a1bQT label_a1bQU))

-- | Constructor for constructing an Attr given an actual value.
pattern Attr :: Apply f label -> Attr f label

-- | An Attribute that is not set
pattern NoAttr :: Attr f label

-- | Traverse an attribute.
traverseAttr :: Applicative h => (Apply f label -> h (Apply g label)) -> Attr f label -> h (Attr g label)

-- | Traverse for the situation where the type is not actually
--   parameterized.
pureAttr :: (Applicative h, Apply f a ~ Apply g a) => Attr f a -> h (Attr g a)

-- | A collection of Attributes.
newtype Attributes (f :: TyFun u * -> *) (ats :: [u])
Attrs :: Rec (Attr f) ats -> Attributes (f :: TyFun u * -> *) (ats :: [u])

-- | Get a vinyl Record with Attrs
unAttrs :: Lens (Attributes f ats) (Attributes f' ats') (Rec (Attr f) ats) (Rec (Attr f') ats')

-- | Traverse implementation for Attrs
traverseAttrs :: Applicative h => (forall label. Attr f label -> h (Attr g label)) -> Attributes f ats -> h (Attributes g ats)

-- | Zip two Recs with the given function.
zipRecsWith :: (forall a. f a -> g a -> h a) -> Rec f as -> Rec g as -> Rec h as

-- | Lens into a specific attribute, if it is set.
ixAttr :: forall at ats proxy f. at ∈ ats => proxy at -> Lens' (Attributes f ats) (Maybe (Apply f at))

-- | Prism into a particular attribute.
_Attr :: forall at ats proxy f. (at ∈ ats, RecApplicative ats) => proxy at -> Prism' (Attributes f ats) (Apply f at)

-- | Looks up a particular attribute.
lookupAttr :: at ∈ ats => proxy at -> Attributes f ats -> Maybe (Apply f at)

-- | Sets a particular attribute
setAttr :: forall proxy at ats f. at ∈ ats => proxy at -> Apply f at -> Attributes f ats -> Attributes f ats

-- | gets and removes the attribute from Attributes
takeAttr :: forall proxy at ats f. at ∈ ats => proxy at -> Attributes f ats -> (Maybe (Apply f at), Attributes f ats)

-- | unsets/Removes an attribute
unSetAttr :: forall proxy at ats f. at ∈ ats => proxy at -> Attributes f ats -> Attributes f ats

-- | Creates a singleton attribute
attr :: (at ∈ ats, RecApplicative ats) => proxy at -> Apply f at -> Attributes f ats

-- | Possible values for Pin
data PinType
No :: PinType
Yes :: PinType
Horizontal :: PinType
Vertical :: PinType

-- | Possible values for Transformation
data TransformationTypes
Affine :: TransformationTypes
Rigid :: TransformationTypes
Translations :: TransformationTypes

-- | The optional Attributes for a symbol data SymbolAttributeUniverse =
--   SymbolStroke | SymbolFill | SymbolPen | Size deriving (Show,Eq)
--   
--   Size
newtype IpeSize r
IpeSize :: IpeValue r -> IpeSize r

-- | Pen/Thickness
newtype IpePen r
IpePen :: IpeValue r -> IpePen r

-- | Possible values for Dash
data IpeDash r
DashNamed :: Text -> IpeDash r
DashPattern :: [r] -> r -> IpeDash r

-- | Allowed Fill types
data FillType
Wind :: FillType
EOFill :: FillType

-- | IpeOpacity, IpeTyling, and IpeGradient are all symbolic values
type IpeOpacity = Text
type IpeTiling = Text
type IpeGradient = Text

-- | Possible values for an ipe arrow
data IpeArrow r
IpeArrow :: Text -> IpeSize r -> IpeArrow r
[_arrowName] :: IpeArrow r -> Text
[_arrowSize] :: IpeArrow r -> IpeSize r
arrowSize :: forall r_a1bRD r_a1efE. Lens (IpeArrow r_a1bRD) (IpeArrow r_a1efE) (IpeSize r_a1bRD) (IpeSize r_a1efE)
arrowName :: forall r_a1bRD. Lens' (IpeArrow r_a1bRD) Text

-- | A normal arrow
normalArrow :: IpeArrow r

-- | For the types representing attribute values we can get the name/key to
--   use when serializing to ipe.
class IpeAttrName (a :: AttributeUniverse)
attrName :: IpeAttrName a => proxy a -> Text

-- | Writing Attribute names
writeAttrNames :: AllConstrained IpeAttrName rs => Rec f rs -> Rec (Const Text) rs
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Layer
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Matrix
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Pin
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Transformations
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Stroke
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Fill
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Pen
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Size
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Dash
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.LineCap
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.LineJoin
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.FillRule
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Arrow
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.RArrow
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.StrokeOpacity
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Opacity
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Tiling
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Gradient
instance Ipe.Attributes.IpeAttrName 'Ipe.Attributes.Clip
instance Data.Traversable.Traversable Ipe.Attributes.IpeArrow
instance Data.Foldable.Foldable Ipe.Attributes.IpeArrow
instance GHC.Base.Functor Ipe.Attributes.IpeArrow
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Attributes.IpeArrow r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Attributes.IpeArrow r)
instance GHC.Classes.Eq Ipe.Attributes.FillType
instance GHC.Read.Read Ipe.Attributes.FillType
instance GHC.Show.Show Ipe.Attributes.FillType
instance Data.Traversable.Traversable Ipe.Attributes.IpeDash
instance Data.Foldable.Foldable Ipe.Attributes.IpeDash
instance GHC.Base.Functor Ipe.Attributes.IpeDash
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Attributes.IpeDash r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Attributes.IpeDash r)
instance Data.Traversable.Traversable Ipe.Attributes.IpePen
instance Data.Foldable.Foldable Ipe.Attributes.IpePen
instance GHC.Base.Functor Ipe.Attributes.IpePen
instance GHC.Classes.Ord r => GHC.Classes.Ord (Ipe.Attributes.IpePen r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Attributes.IpePen r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Attributes.IpePen r)
instance Data.Traversable.Traversable Ipe.Attributes.IpeSize
instance Data.Foldable.Foldable Ipe.Attributes.IpeSize
instance GHC.Base.Functor Ipe.Attributes.IpeSize
instance GHC.Classes.Ord r => GHC.Classes.Ord (Ipe.Attributes.IpeSize r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Attributes.IpeSize r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Attributes.IpeSize r)
instance GHC.Classes.Eq Ipe.Attributes.TransformationTypes
instance GHC.Read.Read Ipe.Attributes.TransformationTypes
instance GHC.Show.Show Ipe.Attributes.TransformationTypes
instance GHC.Read.Read Ipe.Attributes.PinType
instance GHC.Show.Show Ipe.Attributes.PinType
instance GHC.Classes.Eq Ipe.Attributes.PinType
instance forall u (ats :: [u]) (f :: Data.Singletons.Internal.TyFun u * -> *). (Data.Vinyl.Core.RMap ats, Data.Vinyl.Core.ReifyConstraint GHC.Show.Show (Ipe.Attributes.Attr f) ats, Data.Vinyl.Core.RecordToList ats, Data.Vinyl.TypeLevel.RecAll (Ipe.Attributes.Attr f) ats GHC.Show.Show) => GHC.Show.Show (Ipe.Attributes.Attributes f ats)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (ats :: [u]). (Data.Vinyl.Core.ReifyConstraint GHC.Classes.Eq (Ipe.Attributes.Attr f) ats, Data.Vinyl.Core.RecordToList ats, Data.Vinyl.TypeLevel.RecAll (Ipe.Attributes.Attr f) ats GHC.Classes.Eq) => GHC.Classes.Eq (Ipe.Attributes.Attributes f ats)
instance forall u (ats :: [u]) (f :: Data.Singletons.Internal.TyFun u * -> *). Data.Vinyl.Core.RecApplicative ats => GHC.Base.Monoid (Ipe.Attributes.Attributes f ats)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (ats :: [u]). GHC.Base.Semigroup (Ipe.Attributes.Attributes f ats)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Show.Show (Data.Singletons.Internal.Apply f label) => GHC.Show.Show (Ipe.Attributes.Attr f label)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Read.Read (Data.Singletons.Internal.Apply f label) => GHC.Read.Read (Ipe.Attributes.Attr f label)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (l :: u). GHC.Base.Semigroup (Ipe.Attributes.Attr f l)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (l :: u). GHC.Base.Monoid (Ipe.Attributes.Attr f l)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Classes.Eq (Data.Singletons.Internal.Apply f label) => GHC.Classes.Eq (Ipe.Attributes.Attr f label)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Classes.Ord (Data.Singletons.Internal.Apply f label) => GHC.Classes.Ord (Ipe.Attributes.Attr f label)
instance Data.Singletons.Internal.SingKind Ipe.Attributes.AttributeUniverse
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Layer
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Matrix
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Pin
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Transformations
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Stroke
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Fill
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Pen
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Size
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Dash
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.LineCap
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.LineJoin
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.FillRule
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Arrow
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.RArrow
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.StrokeOpacity
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Opacity
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Tiling
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Gradient
instance Data.Singletons.Internal.SingI 'Ipe.Attributes.Clip
instance GHC.Classes.Eq Ipe.Attributes.AttributeUniverse
instance GHC.Read.Read Ipe.Attributes.AttributeUniverse
instance GHC.Show.Show Ipe.Attributes.AttributeUniverse

module Ipe.Content

-- | Image Objects
data Image r
Image :: () -> Rectangle () r -> Image r
imageData :: forall r_a1l8Y. Lens' (Image r_a1l8Y) ()
rect :: forall r_a1l8Y r_a1lj0. Lens (Image r_a1l8Y) (Image r_a1lj0) (Rectangle () r_a1l8Y) (Rectangle () r_a1lj0)

-- | Text Objects
data TextLabel r
Label :: Text -> Point 2 r -> TextLabel r
data MiniPage r
MiniPage :: Text -> Point 2 r -> r -> MiniPage r
width :: MiniPage t -> t

-- | Ipe Symbols, i.e. Points
--   
--   A symbol (point) in ipe
data IpeSymbol r
Symbol :: Point 2 r -> Text -> IpeSymbol r
symbolPoint :: forall r_a1ljk r_a1m5q. Lens (IpeSymbol r_a1ljk) (IpeSymbol r_a1m5q) (Point 2 r_a1ljk) (Point 2 r_a1m5q)
symbolName :: forall r_a1ljk. Lens' (IpeSymbol r_a1ljk) Text

-- | A path is a non-empty sequence of PathSegments.
newtype Path r
Path :: LSeq 1 (PathSegment r) -> Path r
pathSegments :: forall r_asuV r_aDBP. Iso (Path r_asuV) (Path r_aDBP) (LSeq 1 (PathSegment r_asuV)) (LSeq 1 (PathSegment r_aDBP))

-- | Paths
--   
--   Paths consist of Path Segments. PathSegments come in the following
--   forms:
data PathSegment r
PolyLineSegment :: PolyLine 2 () r -> PathSegment r
PolygonPath :: SimplePolygon () r -> PathSegment r
CubicBezierSegment :: BezierSpline 3 2 r -> PathSegment r
QuadraticBezierSegment :: BezierSpline 2 2 r -> PathSegment r
EllipseSegment :: Ellipse r -> PathSegment r
ArcSegment :: PathSegment r
SplineSegment :: PathSegment r
ClosedSplineSegment :: PathSegment r

-- | Groups and Objects
--   
--   Group Attributes
--   
--   A group is essentially a list of IpeObjects.
newtype Group r
Group :: [IpeObject r] -> Group r
groupItems :: Lens (Group r) (Group s) [IpeObject r] [IpeObject s]
data IpeObject r
IpeGroup :: IpeObject' Group r -> IpeObject r
IpeImage :: IpeObject' Image r -> IpeObject r
IpeTextLabel :: IpeObject' TextLabel r -> IpeObject r
IpeMiniPage :: IpeObject' MiniPage r -> IpeObject r
IpeUse :: IpeObject' IpeSymbol r -> IpeObject r
IpePath :: IpeObject' Path r -> IpeObject r
_IpeGroup :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Group r_a1mcO)
_IpeImage :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Image r_a1mcO)
_IpeTextLabel :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' TextLabel r_a1mcO)
_IpeMiniPage :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' MiniPage r_a1mcO)
_IpeUse :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' IpeSymbol r_a1mcO)
_IpePath :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Path r_a1mcO)

-- | An IpeObject' is essentially the oject ogether with its attributes
type IpeObject' g r = g r :+ IpeAttributes g r

-- | Shorthand for constructing ipeObjects
ipeObject' :: ToObject i => i r -> IpeAttributes i r -> IpeObject r
class ToObject i
mkIpeObject :: ToObject i => IpeObject' i r -> IpeObject r
type IpeAttributes g r = Attributes' r (AttributesOf g)

-- | Attributes' :: * -&gt; [AttributeUniverse] -&gt; *
type Attributes' r = Attributes (AttrMapSym1 r)
type family AttributesOf (t :: * -> *) :: [AttributeUniverse]

-- | The mapping between the labels of the the attributes and the types of
--   the attributes with these labels. For example, the <a>Matrix</a>
--   label/attribute should have a value of type 'Matrix 3 3 r'.
type family AttrMap (r :: *) (l :: AttributeUniverse) :: *
data AttrMapSym1 (r6989586621679333036 :: Type) :: (~>) AttributeUniverse Type
attributes :: Lens' (IpeObject' g r) (IpeAttributes g r)

-- | traverse for ipe attributes
traverseIpeAttrs :: (Applicative f, AllConstrained TraverseIpeAttr (AttributesOf g)) => proxy g -> (r -> f s) -> IpeAttributes g r -> f (IpeAttributes g s)
commonAttributes :: Lens' (IpeObject r) (Attributes (AttrMapSym1 r) CommonAttributes)

-- | collect all non-group objects
flattenGroups :: [IpeObject r] -> [IpeObject r]
instance Ipe.Content.ToObject Ipe.Content.Group
instance Ipe.Content.ToObject Ipe.Content.Image
instance Ipe.Content.ToObject Ipe.Content.TextLabel
instance Ipe.Content.ToObject Ipe.Content.MiniPage
instance Ipe.Content.ToObject Ipe.Content.IpeSymbol
instance Ipe.Content.ToObject Ipe.Path.Path
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Content.IpeObject r)
instance Data.Traversable.Traversable Ipe.Content.Group
instance Data.Foldable.Foldable Ipe.Content.Group
instance GHC.Base.Functor Ipe.Content.Group
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Content.Group r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Content.Group r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Content.IpeObject r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Content.IpeObject r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Content.Group r)
instance GHC.Base.Functor Ipe.Content.IpeObject
instance Data.Foldable.Foldable Ipe.Content.IpeObject
instance Data.Traversable.Traversable Ipe.Content.IpeObject
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Layer
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Matrix
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Pin
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Transformations
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Stroke
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Fill
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Pen
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Size
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Dash
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.LineCap
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.LineJoin
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.FillRule
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Arrow
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.RArrow
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.StrokeOpacity
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Opacity
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Tiling
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Gradient
instance Ipe.Content.TraverseIpeAttr 'Ipe.Attributes.Clip
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Ipe.Content.AttrMapSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Ipe.Content.AttrMapSym1 r6989586621679333036)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Content.IpeSymbol r)
instance Data.Traversable.Traversable Ipe.Content.IpeSymbol
instance Data.Foldable.Foldable Ipe.Content.IpeSymbol
instance GHC.Base.Functor Ipe.Content.IpeSymbol
instance GHC.Classes.Ord r => GHC.Classes.Ord (Ipe.Content.IpeSymbol r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Content.IpeSymbol r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Content.IpeSymbol r)
instance Data.Traversable.Traversable Ipe.Content.MiniPage
instance Data.Foldable.Foldable Ipe.Content.MiniPage
instance GHC.Base.Functor Ipe.Content.MiniPage
instance GHC.Classes.Ord r => GHC.Classes.Ord (Ipe.Content.MiniPage r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Content.MiniPage r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Content.MiniPage r)
instance Data.Traversable.Traversable Ipe.Content.TextLabel
instance Data.Foldable.Foldable Ipe.Content.TextLabel
instance GHC.Base.Functor Ipe.Content.TextLabel
instance GHC.Classes.Ord r => GHC.Classes.Ord (Ipe.Content.TextLabel r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Content.TextLabel r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Content.TextLabel r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Content.MiniPage r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Content.TextLabel r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.Internal.IsTransformable (Ipe.Content.Image r)
instance GHC.Base.Functor Ipe.Content.Image
instance Data.Foldable.Foldable Ipe.Content.Image
instance Data.Traversable.Traversable Ipe.Content.Image
instance GHC.Classes.Ord r => GHC.Classes.Ord (Ipe.Content.Image r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Content.Image r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Content.Image r)


-- | Data type modeling the various elements in Ipe files.
module Ipe.Types

-- | A complete ipe file
data IpeFile r
IpeFile :: Maybe IpePreamble -> [IpeStyle] -> NonEmpty (IpePage r) -> IpeFile r
preamble :: forall r_a1yDb. Lens' (IpeFile r_a1yDb) (Maybe IpePreamble)
styles :: forall r_a1yDb. Lens' (IpeFile r_a1yDb) [IpeStyle]
pages :: forall r_a1yDb r_a1yXq. Lens (IpeFile r_a1yDb) (IpeFile r_a1yXq) (NonEmpty (IpePage r_a1yDb)) (NonEmpty (IpePage r_a1yXq))

-- | Convenience constructor for creating an ipe file without preamble and
--   with the default stylesheet.
ipeFile :: NonEmpty (IpePage r) -> IpeFile r

-- | Convenience function to construct an ipe file consisting of a single
--   page.
singlePageFile :: IpePage r -> IpeFile r

-- | Create a single page ipe file from a list of IpeObjects
singlePageFromContent :: [IpeObject r] -> IpeFile r

-- | An IpePage is essentially a Group, together with a list of layers and
--   a list of views.
data IpePage r
IpePage :: [LayerName] -> [View] -> [IpeObject r] -> IpePage r
layers :: forall r_a1yyZ. Lens' (IpePage r_a1yyZ) [LayerName]
views :: forall r_a1yyZ. Lens' (IpePage r_a1yyZ) [View]
content :: forall r_a1yyZ r_a1yCI. Lens (IpePage r_a1yyZ) (IpePage r_a1yCI) [IpeObject r_a1yyZ] [IpeObject r_a1yCI]

-- | Creates an empty page with one layer and view.
emptyPage :: IpePage r

-- | Creates a simple page with a single view.
fromContent :: [IpeObject r] -> IpePage r

-- | This allows you to filter the objects on some layer.
--   
--   <pre>
--   &gt;&gt;&gt; let page = IpePage [] [] []
--   
--   &gt;&gt;&gt; page^..content.onLayer "myLayer"
--   []
--   </pre>
onLayer :: LayerName -> Getting (Endo [IpeObject r]) [IpeObject r] (IpeObject r)

-- | Gets all objects that are visible in the given view.
--   
--   Note that views are indexed starting from 0. If the page does not have
--   any explicit view definitions, this function returns an empty list.
--   
--   <pre>
--   &gt;&gt;&gt; let page = IpePage [] [] []
--   
--   &gt;&gt;&gt; page^.contentInView 0
--   []
--   </pre>
contentInView :: Word -> Getter (IpePage r) [IpeObject r]

-- | Makes sure that the page has at least one layer and at least one view,
--   essentially matching the behaviour of ipe. In particular,
--   
--   <ul>
--   <li>if the page does not have any layers, it creates a layer named
--   "alpha", and</li>
--   <li>if the page does not have any views, it creates a view in which
--   all layers are visible.</li>
--   </ul>
withDefaults :: IpePage r -> IpePage r
data IpeObject r
IpeGroup :: IpeObject' Group r -> IpeObject r
IpeImage :: IpeObject' Image r -> IpeObject r
IpeTextLabel :: IpeObject' TextLabel r -> IpeObject r
IpeMiniPage :: IpeObject' MiniPage r -> IpeObject r
IpeUse :: IpeObject' IpeSymbol r -> IpeObject r
IpePath :: IpeObject' Path r -> IpeObject r
_IpeGroup :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Group r_a1mcO)
_IpeImage :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Image r_a1mcO)
_IpeTextLabel :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' TextLabel r_a1mcO)
_IpeMiniPage :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' MiniPage r_a1mcO)
_IpeUse :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' IpeSymbol r_a1mcO)
_IpePath :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Path r_a1mcO)

-- | An IpeObject' is essentially the oject ogether with its attributes
type IpeObject' g r = g r :+ IpeAttributes g r

-- | Shorthand for constructing ipeObjects
ipeObject' :: ToObject i => i r -> IpeAttributes i r -> IpeObject r
class ToObject i
mkIpeObject :: ToObject i => IpeObject' i r -> IpeObject r

-- | A path is a non-empty sequence of PathSegments.
newtype Path r
Path :: LSeq 1 (PathSegment r) -> Path r
pathSegments :: forall r_asuV r_aDBP. Iso (Path r_asuV) (Path r_aDBP) (LSeq 1 (PathSegment r_asuV)) (LSeq 1 (PathSegment r_aDBP))

-- | Paths
--   
--   Paths consist of Path Segments. PathSegments come in the following
--   forms:
data PathSegment r
PolyLineSegment :: PolyLine 2 () r -> PathSegment r
PolygonPath :: SimplePolygon () r -> PathSegment r
CubicBezierSegment :: BezierSpline 3 2 r -> PathSegment r
QuadraticBezierSegment :: BezierSpline 2 2 r -> PathSegment r
EllipseSegment :: Ellipse r -> PathSegment r
ArcSegment :: PathSegment r
SplineSegment :: PathSegment r
ClosedSplineSegment :: PathSegment r

-- | Ipe Symbols, i.e. Points
--   
--   A symbol (point) in ipe
data IpeSymbol r
Symbol :: Point 2 r -> Text -> IpeSymbol r
symbolPoint :: forall r_a1ljk r_a1m5q. Lens (IpeSymbol r_a1ljk) (IpeSymbol r_a1m5q) (Point 2 r_a1ljk) (Point 2 r_a1m5q)
symbolName :: forall r_a1ljk. Lens' (IpeSymbol r_a1ljk) Text

-- | Groups and Objects
--   
--   Group Attributes
--   
--   A group is essentially a list of IpeObjects.
newtype Group r
Group :: [IpeObject r] -> Group r
groupItems :: Lens (Group r) (Group s) [IpeObject r] [IpeObject s]

-- | Text Objects
data TextLabel r
Label :: Text -> Point 2 r -> TextLabel r
data MiniPage r
MiniPage :: Text -> Point 2 r -> r -> MiniPage r
width :: MiniPage t -> t

-- | Image Objects
data Image r
Image :: () -> Rectangle () r -> Image r
imageData :: forall r_a1l8Y. Lens' (Image r_a1l8Y) ()
rect :: forall r_a1l8Y r_a1lj0. Lens (Image r_a1l8Y) (Image r_a1lj0) (Rectangle () r_a1l8Y) (Rectangle () r_a1lj0)
type IpeBitmap = Text
type IpeAttributes g r = Attributes' r (AttributesOf g)

-- | Attributes' :: * -&gt; [AttributeUniverse] -&gt; *
type Attributes' r = Attributes (AttrMapSym1 r)
type family AttributesOf (t :: * -> *) :: [AttributeUniverse]

-- | The mapping between the labels of the the attributes and the types of
--   the attributes with these labels. For example, the <a>Matrix</a>
--   label/attribute should have a value of type 'Matrix 3 3 r'.
type family AttrMap (r :: *) (l :: AttributeUniverse) :: *
data AttrMapSym1 (r6989586621679333036 :: Type) :: (~>) AttributeUniverse Type
attributes :: Lens' (IpeObject' g r) (IpeAttributes g r)

-- | traverse for ipe attributes
traverseIpeAttrs :: (Applicative f, AllConstrained TraverseIpeAttr (AttributesOf g)) => proxy g -> (r -> f s) -> IpeAttributes g r -> f (IpeAttributes g s)
commonAttributes :: Lens' (IpeObject r) (Attributes (AttrMapSym1 r) CommonAttributes)

-- | Defines an Layer in Ipe.
newtype LayerName
LayerName :: Text -> LayerName
layerName :: Iso' LayerName Text

-- | The definition of a view make active layer into an index ?
data View
View :: [LayerName] -> LayerName -> View
layerNames :: Lens' View [LayerName]
activeLayer :: Lens' View LayerName

-- | Adds a stylesheet to the ipe file. This will be the first stylesheet,
--   i.e. it has priority over all previously imported stylesheets.
addStyleSheet :: IpeStyle -> IpeFile r -> IpeFile r

-- | for now we pretty much ignore these
data IpeStyle
IpeStyle :: Maybe Text -> Node Text Text -> IpeStyle
styleName :: Lens' IpeStyle (Maybe Text)
styleData :: Lens' IpeStyle (Node Text Text)
basicIpeStyle :: IpeStyle

-- | The maybe string is the encoding
data IpePreamble
IpePreamble :: Maybe Text -> Text -> IpePreamble
encoding :: Lens' IpePreamble (Maybe Text)
preambleData :: Lens' IpePreamble Text
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Types.IpeFile r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Types.IpeFile r)
instance GHC.Show.Show r => GHC.Show.Show (Ipe.Types.IpePage r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Ipe.Types.IpePage r)
instance GHC.Classes.Ord Ipe.Types.IpePreamble
instance GHC.Show.Show Ipe.Types.IpePreamble
instance GHC.Read.Read Ipe.Types.IpePreamble
instance GHC.Classes.Eq Ipe.Types.IpePreamble
instance GHC.Show.Show Ipe.Types.IpeStyle
instance GHC.Classes.Eq Ipe.Types.IpeStyle
instance GHC.Show.Show Ipe.Types.View
instance GHC.Classes.Ord Ipe.Types.View
instance GHC.Classes.Eq Ipe.Types.View


-- | Matrix Attributes as defined in Ipe
module Ipe.Matrix

-- | Takes and applies the ipe Matrix attribute of this item.
applyMatrix' :: (IsTransformable (i r), Matrix ∈ AttributesOf i, Dimension (i r) ~ 2, r ~ NumType (i r)) => IpeObject' i r -> IpeObject' i r

-- | Applies the matrix to an ipe object if it has one.
applyMatrix :: Fractional r => IpeObject r -> IpeObject r

-- | Applies all matrices in the file.
applyMatrices :: Fractional r => IpeFile r -> IpeFile r

-- | Applies all Matrices on a given page.
applyMatricesPage :: Fractional r => IpePage r -> IpePage r

module Ipe.Reader

-- | Given a file path, tries to read an ipe file
readRawIpeFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpeFile r))

-- | Given a file path, tries to read an ipe file.
--   
--   This function applies all matrices to objects.
readIpeFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpeFile r))

-- | Since most Ipe file contain only one page, we provide a shortcut for
--   that as well.
--   
--   This function applies all matrices, and it makes sure there is at
--   least one layer and view in the page.
readSinglePageFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpePage r))

-- | Tries to read a single page file, throws an error when this fails. See
--   <a>readSinglePageFile</a> for further details.
readSinglePageFileThrow :: (Coordinate r, Eq r) => FilePath -> IO (IpePage r)
type ConversionError = Text

-- | Reads an Ipe stylesheet from Disk.
readIpeStylesheet :: FilePath -> IO (Either ConversionError IpeStyle)

-- | Given a path to a stylesheet, add it to the ipe file with the highest
--   priority. Throws an error when this fails.
addStyleSheetFrom :: FilePath -> IpeFile r -> IO (IpeFile r)

-- | Given a Bytestring, try to parse the bytestring into anything that is
--   IpeReadable, i.e. any of the Ipe elements.
fromIpeXML :: IpeRead (t r) => ByteString -> Either ConversionError (t r)

-- | Reads the data from a Bytestring into a proper Node
readXML :: ByteString -> Either ConversionError (Node Text Text)

-- | Reading an ipe elemtn from a Text value
class IpeReadText t
ipeReadText :: IpeReadText t => Text -> Either ConversionError t

-- | Reading an ipe lement from Xml
class IpeRead t
ipeRead :: IpeRead t => Node Text Text -> Either ConversionError t

-- | Basically IpeReadText for attributes. This class is not really meant
--   to be implemented directly. Just define an IpeReadText instance for
--   the type (Apply f at), then the generic instance below takes care of
--   looking up the name of the attribute, and calling the right
--   ipeReadText value. This class is just so that reifyConstraint in
--   <a>ipeReadRec</a> can select the right typeclass when building the
--   rec.
class IpeReadAttr t
ipeReadAttr :: IpeReadAttr t => Text -> Node Text Text -> Either ConversionError t
ipeReadTextWith :: (Text -> Either t v) -> Text -> Either ConversionError (IpeValue v)

-- | If we can ipeRead an ipe element, and we can ipeReadAttrs its
--   attributes we can properly read an ipe object using ipeReadObject
ipeReadObject :: (IpeRead (i r), f ~ AttrMapSym1 r, ats ~ AttributesOf i, RecApplicative ats, ReifyConstraint IpeReadAttr (Attr f) ats, RecAll (Attr f) ats IpeReadAttr, AllConstrained IpeAttrName ats) => Proxy i -> proxy r -> Node Text Text -> Either ConversionError (i r :+ IpeAttributes i r)

-- | Reader for records. Given a proxy of some ipe type i, and a proxy of
--   an coordinate type r, read the IpeAttributes for i from the xml node.
ipeReadAttrs :: forall proxy proxy' i r f ats. (f ~ AttrMapSym1 r, ats ~ AttributesOf i, ReifyConstraint IpeReadAttr (Attr f) ats, RecApplicative ats, RecAll (Attr f) ats IpeReadAttr, AllConstrained IpeAttrName ats) => proxy i -> proxy' r -> Node Text Text -> Either ConversionError (IpeAttributes i r)

-- | Reading the Attributes into a Rec (Attr f), all based on the types of
--   f (the type family mapping labels to types), and a list of labels
--   (ats).
ipeReadRec :: forall f ats. (RecApplicative ats, ReifyConstraint IpeReadAttr (Attr f) ats, RecAll (Attr f) ats IpeReadAttr, AllConstrained IpeAttrName ats) => Proxy f -> Proxy ats -> Node Text Text -> Either ConversionError (Rec (Attr f) ats)

-- | Represent stuff that can be used as a coordinate in ipe. (similar to
--   show/read)
class Fractional r => Coordinate r
fromSeq :: Coordinate r => Integer -> Maybe (Int, Integer) -> r
fromSeq :: (Coordinate r, Ord r, Fractional r) => Integer -> Maybe (Int, Integer) -> r
instance forall u (f :: u Data.Singletons.Internal.~> *) (at :: u). Ipe.Reader.IpeReadText (Data.Singletons.Internal.Apply f at) => Ipe.Reader.IpeReadAttr (Ipe.Attributes.Attr f at)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeRead (Ipe.Content.IpeSymbol r)
instance (Ipe.PathParser.Coordinate r, GHC.Real.Fractional r, GHC.Classes.Eq r) => Ipe.Reader.IpeRead (Ipe.Path.Path r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeRead (Ipe.Content.TextLabel r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeRead (Ipe.Content.MiniPage r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeRead (Ipe.Content.Image r)
instance (Ipe.PathParser.Coordinate r, GHC.Real.Fractional r, GHC.Classes.Eq r) => Ipe.Reader.IpeRead (Ipe.Content.IpeObject r)
instance (Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Ipe.Reader.IpeRead (Ipe.Content.Group r)
instance Ipe.Reader.IpeRead Ipe.Layer.LayerName
instance Ipe.Reader.IpeRead Ipe.Types.View
instance (Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Ipe.Reader.IpeRead (Ipe.Types.IpePage r)
instance (Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Ipe.Reader.IpeRead (Ipe.Types.IpeFile r)
instance Ipe.Reader.IpeRead Ipe.Types.IpeStyle
instance Ipe.Reader.IpeReadText Data.Text.Internal.Text
instance Ipe.Reader.IpeReadText GHC.Types.Int
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Data.Geometry.Point.Internal.Point 2 r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Data.Geometry.Matrix.Matrix 3 3 r)
instance Ipe.Reader.IpeReadText Ipe.Layer.LayerName
instance Ipe.Reader.IpeReadText Ipe.Attributes.PinType
instance Ipe.Reader.IpeReadText Ipe.Attributes.TransformationTypes
instance Ipe.Reader.IpeReadText Ipe.Attributes.FillType
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Ipe.Attributes.IpeArrow r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Ipe.Attributes.IpeDash r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Data.Geometry.Box.Internal.Rectangle () r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Data.Colour.RGB.RGB r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Ipe.Color.IpeColor r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Ipe.Attributes.IpePen r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText (Ipe.Attributes.IpeSize r)
instance Ipe.PathParser.Coordinate r => Ipe.Reader.IpeReadText [Ipe.Path.Operation r]
instance (Ipe.PathParser.Coordinate r, GHC.Real.Fractional r, GHC.Classes.Eq r) => Ipe.Reader.IpeReadText (GHC.Base.NonEmpty (Ipe.Path.PathSegment r))
instance (Ipe.PathParser.Coordinate r, GHC.Real.Fractional r, GHC.Classes.Eq r) => Ipe.Reader.IpeReadText (Ipe.Path.Path r)


-- | Functions that help reading geometric values from ipe images.
module Ipe.FromIpe

-- | Extracts the point from a Symbol. When creating a symbol this creates
--   a disk that supports a stroke color.
_asPoint :: Prism' (IpeSymbol r) (Point 2 r)

-- | Try to convert a path into a line segment, fails if the path is not a
--   line segment or a polyline with more than two points.
_asLineSegment :: Prism' (Path r) (LineSegment 2 () r)

-- | Tries to convert a path into a rectangle.
_asRectangle :: forall r. (Num r, Ord r) => Prism' (Path r) (Rectangle () r)

-- | Convert to a triangle
_asTriangle :: Prism' (Path r) (Triangle 2 () r)

-- | Convert to a polyline. Ignores all non-polyline parts
--   
--   <pre>
--   &gt;&gt;&gt; testPath ^? _asPolyLine
--   Just (PolyLine {_points = LSeq (fromList [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [200,100] :+ ()])})
--   </pre>
_asPolyLine :: Prism' (Path r) (PolyLine 2 () r)
_asSomePolygon :: Prism' (Path r) (SomePolygon () r)

-- | Convert to a simple polygon
_asSimplePolygon :: Prism' (Path r) (Polygon Simple () r)

-- | Convert to a multipolygon
_asMultiPolygon :: Prism' (Path r) (MultiPolygon () r)

-- | Use the first prism to select the ipe object to depicle with, and the
--   second how to select the geometry object from there on. Then we can
--   select the geometry object, directly with its attributes here.
--   
--   <pre>
--   &gt;&gt;&gt; testObject ^? _withAttrs _IpePath _asPolyLine
--   Just (PolyLine {_points = LSeq (fromList [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [200,100] :+ ()])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "red"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
_withAttrs :: Prism' (IpeObject r) (i r :+ IpeAttributes i r) -> Prism' (i r) g -> Prism' (IpeObject r) (g :+ IpeAttributes i r)
class HasDefaultFromIpe g where {
    type family DefaultFromIpe g :: * -> *;
}
defaultFromIpe :: (HasDefaultFromIpe g, r ~ NumType g) => Prism' (IpeObject r) (g :+ IpeAttributes (DefaultFromIpe g) r)

-- | Read all g's from some ipe page(s).
readAll :: forall g r. (HasDefaultFromIpe g, r ~ NumType g) => IpePage r -> [g :+ IpeAttributes (DefaultFromIpe g) r]

-- | Convenience function from reading all g's from an ipe file. If there
--   is an error reading or parsing the file the error is "thrown away".
readAllFrom :: forall g r. (HasDefaultFromIpe g, r ~ NumType g, Coordinate r, Eq r) => FilePath -> IO [g :+ IpeAttributes (DefaultFromIpe g) r]
instance Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Point.Internal.Point 2 r)
instance Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.LineSegment.Internal.LineSegment 2 () r)
instance Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Ellipse.Ellipse r)
instance (GHC.Float.Floating r, GHC.Classes.Eq r) => Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Ball.Circle () r)
instance (GHC.Float.Floating r, GHC.Classes.Eq r) => Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Ball.Disk () r)
instance Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.PolyLine.PolyLine 2 () r)
instance Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Polygon.Core.SimplePolygon () r)
instance Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Polygon.Core.MultiPolygon () r)
instance (GHC.Num.Num r, GHC.Classes.Ord r) => Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Box.Internal.Rectangle () r)


-- | Functions that help drawing geometric values in ipe. An <a>IpeOut</a>
--   is essenitally a function that converts a geometric type g into an
--   IpeObject.
--   
--   We also proivde a <a>HasDefaultIpeOut</a> typeclass that defines a
--   default conversion function from a geometry type g to an ipe type.
module Ipe.IpeOut
type IpeOut g i r = g -> IpeObject' i r

-- | Give the option to draw zero, one or more things, i.e. by choosing f ~
--   Maybe or f ~ []
type IpeOut' f g i r = g -> f (IpeObject' i r)

-- | Add attributes to an IpeObject'
(!) :: IpeObject' i r -> IpeAttributes i r -> IpeObject' i r

-- | Render an ipe object
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     iO $ defIO myPolygon ! attr SFill (IpeColor "blue")
--                          ! attr SLayer "alpha"
--                          ! attr SLayer "beta"
--   :}
--   IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {Attr LayerName {_layerName = "beta"}, NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "blue"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     iO $ ipeGroup [ iO $ ipePolygon myPolygon ! attr SFill (IpeColor "red")
--                   ] ! attr SLayer "alpha"
--   :}
--   IpeGroup (Group [IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "red"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})] :+ Attrs {Attr LayerName {_layerName = "alpha"}, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
iO :: ToObject i => IpeObject' i r -> IpeObject r

-- | Render to an ipe object using the defIO IpeOut
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     iO'' myPolygon $  attr SFill (IpeColor "red")
--                    &lt;&gt; attr SLayer "alpha"
--                    &lt;&gt; attr SLayer "beta"
--   :}
--   IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {Attr LayerName {_layerName = "beta"}, NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "red"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iO'' [ myPolygon , myPolygon ] $ attr SLayer "alpha"
--   IpeGroup (Group [IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr}),IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})] :+ Attrs {Attr LayerName {_layerName = "alpha"}, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
iO'' :: (HasDefaultIpeOut g, NumType g ~ r, DefaultIpeOut g ~ i, ToObject i) => g -> IpeAttributes i r -> IpeObject r

-- | generate an ipe object without any specific attributes
iO' :: HasDefaultIpeOut g => g -> IpeObject (NumType g)

-- | Class that specifies a default conversion from a geometry type g into
--   an ipe object.
class ToObject (DefaultIpeOut g) => HasDefaultIpeOut g where {
    type family DefaultIpeOut g :: * -> *;
}
defIO :: HasDefaultIpeOut g => IpeOut g (DefaultIpeOut g) (NumType g)
ipeMark :: Text -> IpeOut (Point 2 r) IpeSymbol r
ipeDiskMark :: IpeOut (Point 2 r) IpeSymbol r

-- | Size of the default bounding box used to clip lines and half-lines in
--   the default IpeOuts.
defaultBox :: Num r => Rectangle () r

-- | Renders a line as a Path. The line is clipped to the <a>defaultBox</a>
ipeLine :: (Ord r, Fractional r) => IpeOut (Line 2 r) Path r

-- | Renders the line in the given box.
--   
--   pre: the intersection of the box with the line is non-empty
ipeLineIn :: forall p r. (Ord r, Fractional r) => Rectangle p r -> IpeOut (Line 2 r) Path r

-- | Renders an Halfine.
--   
--   pre: the intersection of the box with the line is non-empty
ipeHalfLine :: (Ord r, Fractional r) => IpeOut (HalfLine 2 r) Path r

-- | Renders a ray, i.e. a half line drawing an arrow in the direction of
--   the ray.
--   
--   pre: the intersection of the box with the line is non-empty
ipeRay :: (Ord r, Fractional r) => IpeOut (HalfLine 2 r) Path r

-- | Renders the HalfLine in the given box.
--   
--   pre: the intersection of the box with the line is non-empty
ipeHalfLineIn :: forall p r. (Ord r, Fractional r) => Rectangle p r -> IpeOut (HalfLine 2 r) Path r
ipeLineSegment :: IpeOut (LineSegment 2 p r) Path r
ipePolyLine :: IpeOut (PolyLine 2 p r) Path r
ipeEllipse :: IpeOut (Ellipse r) Path r
ipeCircle :: Floating r => IpeOut (Circle p r) Path r
ipeDisk :: Floating r => IpeOut (Disk p r) Path r
ipeBezier :: IpeOut (BezierSpline 3 2 r) Path r

-- | Helper to construct a path from a singleton item
path :: PathSegment r -> Path r
pathSegment :: LineSegment 2 p r -> PathSegment r

-- | Draw a polygon
ipePolygon :: IpeOut (Polygon t p r) Path r

-- | Draw a Rectangle
ipeRectangle :: Num r => IpeOut (Rectangle p r) Path r
ipeGroup :: Foldable f => IpeOut (f (IpeObject r)) Group r

-- | Creates an text label
ipeLabel :: IpeOut (Text :+ Point 2 r) TextLabel r

-- | Annotate an IpeOut with a label
labelled :: (Show lbl, NumType g ~ r, ToObject i) => (g -> Point 2 r) -> IpeOut g i r -> IpeOut (g :+ lbl) Group r
instance (Ipe.IpeOut.HasDefaultIpeOut g, a GHC.Types.~ Ipe.Content.IpeAttributes (Ipe.IpeOut.DefaultIpeOut g) (Data.Geometry.Properties.NumType g)) => Ipe.IpeOut.HasDefaultIpeOut (g Data.Ext.:+ a)
instance Ipe.IpeOut.HasDefaultIpeOut a => Ipe.IpeOut.HasDefaultIpeOut [a]
instance Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Point.Internal.Point 2 r)
instance Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.LineSegment.Internal.LineSegment 2 p r)
instance Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.PolyLine.PolyLine 2 p r)
instance (GHC.Real.Fractional r, GHC.Classes.Ord r) => Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Line.Internal.Line 2 r)
instance (GHC.Real.Fractional r, GHC.Classes.Ord r) => Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.HalfLine.HalfLine 2 r)
instance Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Polygon.Core.Polygon t p r)
instance Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Polygon.Core.SomePolygon p r)
instance Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Polygon.Convex.ConvexPolygon p r)
instance Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Ellipse.Ellipse r)
instance GHC.Float.Floating r => Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Ball.Disk p r)
instance GHC.Float.Floating r => Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Ball.Circle p r)
instance GHC.Num.Num r => Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Box.Internal.Rectangle p r)


-- | Machinery for drawing cells.
module Data.Geometry.QuadTree.Draw

-- | Draw a quadTree cell as a Path
drawCell :: Fractional r => IpeOut (Cell r) Path r

-- | Draws an entire quadtree.
drawQuadTree :: (Fractional r, Ord r) => IpeOut (QuadTree v p r) Group r

-- | Draw a quadtree with a given method for drawing the cells.
drawQuadTreeWith :: (ToObject i, Fractional r, Ord r) => IpeOut (p :+ Cell r) i r -> IpeOut (QuadTree v p r) Group r

-- | Draw every cell of a level of the quadtree.
quadTreeLevels :: forall i r v p. (ToObject i, Fractional r, Ord r) => IpeOut (TreeNode v p :+ Cell r) i r -> IpeOut (QuadTree v p r) Group r


module Ipe.Writer

-- | Given a prism to convert something of type g into an ipe file, a file
--   path, and a g. Convert the geometry and write it to file.
--   
--   Write an IpeFiele to file.
writeIpeFile :: IpeWriteText r => FilePath -> IpeFile r -> IO ()

-- | Convert to ipe XML and write the output to a file.
writeIpeFile' :: IpeWrite t => t -> FilePath -> IO ()

-- | Creates a single page ipe file with the given page
writeIpePage :: IpeWriteText r => FilePath -> IpePage r -> IO ()

-- | Convert to Ipe xml
toIpeXML :: IpeWrite t => t -> Maybe ByteString

-- | Convert the input to ipeXml, and prints it to standard out in such a
--   way that the copied text can be pasted into ipe as a geometry object.
printAsIpeSelection :: IpeWrite t => t -> IO ()

-- | Convert input into an ipe selection.
toIpeSelectionXML :: IpeWrite t => t -> Maybe ByteString

-- | Types that correspond to an XML Element. All instances should produce
--   an Element. If the type should produce a Node with the Text
--   constructor, use the <a>IpeWriteText</a> typeclass instead.
class IpeWrite t
ipeWrite :: IpeWrite t => t -> Maybe (Node Text Text)

-- | For types that can produce a text value
class IpeWriteText t
ipeWriteText :: IpeWriteText t => t -> Maybe Text

-- | Functon to write all attributes in a Rec
ipeWriteAttrs :: (RecordToList rs, RMap rs, ReifyConstraint IpeWriteText (Attr f) rs, AllConstrained IpeAttrName rs, RecAll (Attr f) rs IpeWriteText) => Attributes f rs -> [(Text, Text)]

-- | Writing the attribute values
writeAttrValues :: (RMap rs, ReifyConstraint IpeWriteText f rs, RecAll f rs IpeWriteText) => Rec f rs -> Rec (Const (Maybe Text)) rs
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Attributes.IpeSize r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Attributes.IpePen r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Color.IpeColor r)
instance Ipe.Writer.IpeWriteText Ipe.Layer.LayerName
instance Ipe.Writer.IpeWrite t => Ipe.Writer.IpeWrite [t]
instance Ipe.Writer.IpeWrite t => Ipe.Writer.IpeWrite (GHC.Base.NonEmpty t)
instance (Ipe.Writer.IpeWrite l, Ipe.Writer.IpeWrite r) => Ipe.Writer.IpeWrite (Data.Either.Either l r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Content.IpeSymbol r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Path.Path r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Content.Group r)
instance (Data.Vinyl.TypeLevel.AllConstrained Ipe.Attributes.IpeAttrName rs, Data.Vinyl.Core.RecordToList rs, Data.Vinyl.Core.RMap rs, Data.Vinyl.Core.ReifyConstraint Ipe.Writer.IpeWriteText (Ipe.Attributes.Attr f) rs, Data.Vinyl.TypeLevel.RecAll (Ipe.Attributes.Attr f) rs Ipe.Writer.IpeWriteText, Ipe.Writer.IpeWrite g) => Ipe.Writer.IpeWrite (g Data.Ext.:+ Ipe.Attributes.Attributes f rs)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Content.MiniPage r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Content.Image r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Content.TextLabel r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Content.IpeObject r)
instance Ipe.Writer.IpeWrite Ipe.Layer.LayerName
instance Ipe.Writer.IpeWrite Ipe.Types.View
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Types.IpePage r)
instance Ipe.Writer.IpeWrite Ipe.Types.IpeStyle
instance Ipe.Writer.IpeWrite Ipe.Types.IpePreamble
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Ipe.Types.IpeFile r)
instance (Ipe.Writer.IpeWriteText r, Ipe.Writer.IpeWrite p) => Ipe.Writer.IpeWrite (Data.Geometry.PolyLine.PolyLine 2 p r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWrite (Data.Geometry.LineSegment.Internal.LineSegment 2 p r)
instance Ipe.Writer.IpeWrite ()
instance forall u (f :: u Data.Singletons.Internal.~> *) (at :: u). Ipe.Writer.IpeWriteText (Data.Singletons.Internal.Apply f at) => Ipe.Writer.IpeWriteText (Ipe.Attributes.Attr f at)
instance (Ipe.Writer.IpeWriteText l, Ipe.Writer.IpeWriteText r) => Ipe.Writer.IpeWriteText (Data.Either.Either l r)
instance Ipe.Writer.IpeWriteText Data.Text.Internal.Text
instance Ipe.Writer.IpeWriteText GHC.Base.String
instance Ipe.Writer.IpeWriteText GHC.Types.Double
instance Ipe.Writer.IpeWriteText GHC.Types.Float
instance Ipe.Writer.IpeWriteText GHC.Types.Int
instance Ipe.Writer.IpeWriteText GHC.Integer.Type.Integer
instance Ipe.Writer.IpeWriteText (Data.RealNumber.Rational.RealNumber p)
instance Data.Fixed.HasResolution p => Ipe.Writer.IpeWriteText (Data.Fixed.Fixed p)
instance GHC.Real.Integral a => Ipe.Writer.IpeWriteText (GHC.Real.Ratio a)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Data.Geometry.Point.Internal.Point 2 r)
instance Ipe.Writer.IpeWriteText v => Ipe.Writer.IpeWriteText (Ipe.Value.IpeValue v)
instance Ipe.Writer.IpeWriteText Ipe.Attributes.TransformationTypes
instance Ipe.Writer.IpeWriteText Ipe.Attributes.PinType
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Data.Colour.RGB.RGB r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Attributes.IpeDash r)
instance Ipe.Writer.IpeWriteText Ipe.Attributes.FillType
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Attributes.IpeArrow r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Path.Path r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Data.Geometry.Matrix.Matrix 3 3 r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Path.Operation r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Data.Geometry.PolyLine.PolyLine 2 () r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Data.Geometry.Polygon.Core.Polygon t () r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Data.Geometry.BezierSpline.BezierSpline 3 2 r)
instance Ipe.Writer.IpeWriteText r => Ipe.Writer.IpeWriteText (Ipe.Path.PathSegment r)
instance Ipe.Writer.IpeWriteText ()


-- | Use <tt>ipetoipe</tt> to generate pdf files.
--   
--   Note that all functions in this module require that <tt>ipetoipe</tt>
--   is installed (it is bundled with ipe) and available on the path.
module Ipe.IpeToIpe

-- | Call <tt>ipetoipe</tt> to produce an image of the specified type.
ipeToIpeWith :: Options -> FileType -> FilePath -> FilePath -> IO ()

-- | Call <tt>ipetoipe</tt> with the default options.
ipeToIpe :: FileType -> FilePath -> FilePath -> IO ()

-- | Write an ipe file to disk as an ipe readable pdf file.
--   
--   Note that like all other functions in this module, this requires
--   <tt>ipetoipe</tt> to be installed (it is bundled with ipe) and
--   available on the path.
--   
--   Note this will write soem intermediate file to your system temp dir.
writeIpeFileAsPdf :: IpeWriteText r => FilePath -> IpeFile r -> IO ()
data FileType
PDF :: FileType
XML :: FileType
data Export
RetainIpeInfo :: Export
Export :: Export
type PageNumber = Int
type ViewNumber = Int
data MarkedView
All :: MarkedView
OnlyMarkedViews :: MarkedView
data NoZip
NoZip :: NoZip
Zip :: NoZip
data PageRange
EntireFile :: PageRange

-- | only closed ranges are supported.
PageRange :: Range PageNumber -> PageRange
data Options
Options :: Export -> PageRange -> Maybe (PageNumber, ViewNumber) -> MarkedView -> Bool -> NoZip -> Options
[export] :: Options -> Export
[pages] :: Options -> PageRange
[singleView] :: Options -> Maybe (PageNumber, ViewNumber)
[markedView] :: Options -> MarkedView
[runLatex] :: Options -> Bool
[nozip] :: Options -> NoZip
defaultOptions :: Options
instance GHC.Classes.Eq Ipe.IpeToIpe.Options
instance GHC.Show.Show Ipe.IpeToIpe.Options
instance GHC.Classes.Eq Ipe.IpeToIpe.PageRange
instance GHC.Show.Show Ipe.IpeToIpe.PageRange
instance GHC.Enum.Enum Ipe.IpeToIpe.NoZip
instance GHC.Classes.Eq Ipe.IpeToIpe.NoZip
instance GHC.Show.Show Ipe.IpeToIpe.NoZip
instance GHC.Enum.Enum Ipe.IpeToIpe.MarkedView
instance GHC.Classes.Eq Ipe.IpeToIpe.MarkedView
instance GHC.Show.Show Ipe.IpeToIpe.MarkedView
instance GHC.Enum.Enum Ipe.IpeToIpe.Export
instance GHC.Classes.Eq Ipe.IpeToIpe.Export
instance GHC.Show.Show Ipe.IpeToIpe.Export
instance GHC.Enum.Enum Ipe.IpeToIpe.FileType
instance GHC.Classes.Eq Ipe.IpeToIpe.FileType
instance GHC.Show.Show Ipe.IpeToIpe.FileType


-- | Reexports the functionality for reading and writing Ipe files.
module Ipe

-- | A complete ipe file
data IpeFile r
IpeFile :: Maybe IpePreamble -> [IpeStyle] -> NonEmpty (IpePage r) -> IpeFile r
preamble :: forall r_a1yDb. Lens' (IpeFile r_a1yDb) (Maybe IpePreamble)
styles :: forall r_a1yDb. Lens' (IpeFile r_a1yDb) [IpeStyle]
pages :: forall r_a1yDb r_a1yXq. Lens (IpeFile r_a1yDb) (IpeFile r_a1yXq) (NonEmpty (IpePage r_a1yDb)) (NonEmpty (IpePage r_a1yXq))

-- | Convenience constructor for creating an ipe file without preamble and
--   with the default stylesheet.
ipeFile :: NonEmpty (IpePage r) -> IpeFile r

-- | Convenience function to construct an ipe file consisting of a single
--   page.
singlePageFile :: IpePage r -> IpeFile r

-- | Create a single page ipe file from a list of IpeObjects
singlePageFromContent :: [IpeObject r] -> IpeFile r

-- | Given a file path, tries to read an ipe file.
--   
--   This function applies all matrices to objects.
readIpeFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpeFile r))

-- | Since most Ipe file contain only one page, we provide a shortcut for
--   that as well.
--   
--   This function applies all matrices, and it makes sure there is at
--   least one layer and view in the page.
readSinglePageFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpePage r))

-- | Tries to read a single page file, throws an error when this fails. See
--   <a>readSinglePageFile</a> for further details.
readSinglePageFileThrow :: (Coordinate r, Eq r) => FilePath -> IO (IpePage r)

-- | Given a file path, tries to read an ipe file
readRawIpeFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpeFile r))
type ConversionError = Text

-- | Read all g's from some ipe page(s).
readAll :: forall g r. (HasDefaultFromIpe g, r ~ NumType g) => IpePage r -> [g :+ IpeAttributes (DefaultFromIpe g) r]

-- | Convenience function from reading all g's from an ipe file. If there
--   is an error reading or parsing the file the error is "thrown away".
readAllFrom :: forall g r. (HasDefaultFromIpe g, r ~ NumType g, Coordinate r, Eq r) => FilePath -> IO [g :+ IpeAttributes (DefaultFromIpe g) r]

-- | Given a prism to convert something of type g into an ipe file, a file
--   path, and a g. Convert the geometry and write it to file.
--   
--   Write an IpeFiele to file.
writeIpeFile :: IpeWriteText r => FilePath -> IpeFile r -> IO ()

-- | Convert to ipe XML and write the output to a file.
writeIpeFile' :: IpeWrite t => t -> FilePath -> IO ()

-- | Creates a single page ipe file with the given page
writeIpePage :: IpeWriteText r => FilePath -> IpePage r -> IO ()

-- | Convert to Ipe xml
toIpeXML :: IpeWrite t => t -> Maybe ByteString

-- | Convert the input to ipeXml, and prints it to standard out in such a
--   way that the copied text can be pasted into ipe as a geometry object.
printAsIpeSelection :: IpeWrite t => t -> IO ()

-- | Convert input into an ipe selection.
toIpeSelectionXML :: IpeWrite t => t -> Maybe ByteString

-- | An IpePage is essentially a Group, together with a list of layers and
--   a list of views.
data IpePage r
IpePage :: [LayerName] -> [View] -> [IpeObject r] -> IpePage r
layers :: forall r_a1yyZ. Lens' (IpePage r_a1yyZ) [LayerName]
views :: forall r_a1yyZ. Lens' (IpePage r_a1yyZ) [View]
content :: forall r_a1yyZ r_a1yCI. Lens (IpePage r_a1yyZ) (IpePage r_a1yCI) [IpeObject r_a1yyZ] [IpeObject r_a1yCI]

-- | Creates an empty page with one layer and view.
emptyPage :: IpePage r

-- | Creates a simple page with a single view.
fromContent :: [IpeObject r] -> IpePage r

-- | This allows you to filter the objects on some layer.
--   
--   <pre>
--   &gt;&gt;&gt; let page = IpePage [] [] []
--   
--   &gt;&gt;&gt; page^..content.onLayer "myLayer"
--   []
--   </pre>
onLayer :: LayerName -> Getting (Endo [IpeObject r]) [IpeObject r] (IpeObject r)

-- | Gets all objects that are visible in the given view.
--   
--   Note that views are indexed starting from 0. If the page does not have
--   any explicit view definitions, this function returns an empty list.
--   
--   <pre>
--   &gt;&gt;&gt; let page = IpePage [] [] []
--   
--   &gt;&gt;&gt; page^.contentInView 0
--   []
--   </pre>
contentInView :: Word -> Getter (IpePage r) [IpeObject r]

-- | Makes sure that the page has at least one layer and at least one view,
--   essentially matching the behaviour of ipe. In particular,
--   
--   <ul>
--   <li>if the page does not have any layers, it creates a layer named
--   "alpha", and</li>
--   <li>if the page does not have any views, it creates a view in which
--   all layers are visible.</li>
--   </ul>
withDefaults :: IpePage r -> IpePage r
data IpeObject r
IpeGroup :: IpeObject' Group r -> IpeObject r
IpeImage :: IpeObject' Image r -> IpeObject r
IpeTextLabel :: IpeObject' TextLabel r -> IpeObject r
IpeMiniPage :: IpeObject' MiniPage r -> IpeObject r
IpeUse :: IpeObject' IpeSymbol r -> IpeObject r
IpePath :: IpeObject' Path r -> IpeObject r
_IpePath :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Path r_a1mcO)
_IpeUse :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' IpeSymbol r_a1mcO)
_IpeGroup :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Group r_a1mcO)
_IpeTextLabel :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' TextLabel r_a1mcO)
_IpeMiniPage :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' MiniPage r_a1mcO)
_IpeImage :: forall r_a1mcO. Prism' (IpeObject r_a1mcO) (IpeObject' Image r_a1mcO)

-- | An IpeObject' is essentially the oject ogether with its attributes
type IpeObject' g r = g r :+ IpeAttributes g r

-- | Shorthand for constructing ipeObjects
ipeObject' :: ToObject i => i r -> IpeAttributes i r -> IpeObject r
class ToObject i
mkIpeObject :: ToObject i => IpeObject' i r -> IpeObject r

-- | A path is a non-empty sequence of PathSegments.
newtype Path r
Path :: LSeq 1 (PathSegment r) -> Path r
pathSegments :: forall r_asuV r_aDBP. Iso (Path r_asuV) (Path r_aDBP) (LSeq 1 (PathSegment r_asuV)) (LSeq 1 (PathSegment r_aDBP))

-- | Paths
--   
--   Paths consist of Path Segments. PathSegments come in the following
--   forms:
data PathSegment r
PolyLineSegment :: PolyLine 2 () r -> PathSegment r
PolygonPath :: SimplePolygon () r -> PathSegment r
CubicBezierSegment :: BezierSpline 3 2 r -> PathSegment r
QuadraticBezierSegment :: BezierSpline 2 2 r -> PathSegment r
EllipseSegment :: Ellipse r -> PathSegment r
ArcSegment :: PathSegment r
SplineSegment :: PathSegment r
ClosedSplineSegment :: PathSegment r

-- | Ipe Symbols, i.e. Points
--   
--   A symbol (point) in ipe
data IpeSymbol r
Symbol :: Point 2 r -> Text -> IpeSymbol r
symbolPoint :: forall r_a1ljk r_a1m5q. Lens (IpeSymbol r_a1ljk) (IpeSymbol r_a1m5q) (Point 2 r_a1ljk) (Point 2 r_a1m5q)
symbolName :: forall r_a1ljk. Lens' (IpeSymbol r_a1ljk) Text

-- | Groups and Objects
--   
--   Group Attributes
--   
--   A group is essentially a list of IpeObjects.
newtype Group r
Group :: [IpeObject r] -> Group r
groupItems :: Lens (Group r) (Group s) [IpeObject r] [IpeObject s]

-- | Text Objects
data TextLabel r
Label :: Text -> Point 2 r -> TextLabel r
data MiniPage r
MiniPage :: Text -> Point 2 r -> r -> MiniPage r
width :: MiniPage t -> t

-- | Image Objects
data Image r
Image :: () -> Rectangle () r -> Image r
imageData :: forall r_a1l8Y. Lens' (Image r_a1l8Y) ()
rect :: forall r_a1l8Y r_a1lj0. Lens (Image r_a1l8Y) (Image r_a1lj0) (Rectangle () r_a1l8Y) (Rectangle () r_a1lj0)
type IpeBitmap = Text
type IpeAttributes g r = Attributes' r (AttributesOf g)

-- | Attributes' :: * -&gt; [AttributeUniverse] -&gt; *
type Attributes' r = Attributes (AttrMapSym1 r)
type family AttributesOf (t :: * -> *) :: [AttributeUniverse]

-- | The mapping between the labels of the the attributes and the types of
--   the attributes with these labels. For example, the <a>Matrix</a>
--   label/attribute should have a value of type 'Matrix 3 3 r'.
type family AttrMap (r :: *) (l :: AttributeUniverse) :: *
data AttrMapSym1 (r6989586621679333036 :: Type) :: (~>) AttributeUniverse Type
attributes :: Lens' (IpeObject' g r) (IpeAttributes g r)

-- | traverse for ipe attributes
traverseIpeAttrs :: (Applicative f, AllConstrained TraverseIpeAttr (AttributesOf g)) => proxy g -> (r -> f s) -> IpeAttributes g r -> f (IpeAttributes g s)
commonAttributes :: Lens' (IpeObject r) (Attributes (AttrMapSym1 r) CommonAttributes)

-- | Defines an Layer in Ipe.
newtype LayerName
LayerName :: Text -> LayerName
layerName :: Iso' LayerName Text

-- | The definition of a view make active layer into an index ?
data View
View :: [LayerName] -> LayerName -> View
layerNames :: Lens' View [LayerName]
activeLayer :: Lens' View LayerName

-- | for now we pretty much ignore these
data IpeStyle
IpeStyle :: Maybe Text -> Node Text Text -> IpeStyle
styleName :: Lens' IpeStyle (Maybe Text)
styleData :: Lens' IpeStyle (Node Text Text)
basicIpeStyle :: IpeStyle

-- | Reads an Ipe stylesheet from Disk.
readIpeStylesheet :: FilePath -> IO (Either ConversionError IpeStyle)

-- | Given a path to a stylesheet, add it to the ipe file with the highest
--   priority. Throws an error when this fails.
addStyleSheetFrom :: FilePath -> IpeFile r -> IO (IpeFile r)

-- | The maybe string is the encoding
data IpePreamble
IpePreamble :: Maybe Text -> Text -> IpePreamble
encoding :: Lens' IpePreamble (Maybe Text)
preambleData :: Lens' IpePreamble Text

-- | Reading an ipe lement from Xml
class IpeRead t
ipeRead :: IpeRead t => Node Text Text -> Either ConversionError t

-- | Extracts the point from a Symbol. When creating a symbol this creates
--   a disk that supports a stroke color.
_asPoint :: Prism' (IpeSymbol r) (Point 2 r)

-- | Try to convert a path into a line segment, fails if the path is not a
--   line segment or a polyline with more than two points.
_asLineSegment :: Prism' (Path r) (LineSegment 2 () r)

-- | Tries to convert a path into a rectangle.
_asRectangle :: forall r. (Num r, Ord r) => Prism' (Path r) (Rectangle () r)

-- | Convert to a triangle
_asTriangle :: Prism' (Path r) (Triangle 2 () r)

-- | Convert to a polyline. Ignores all non-polyline parts
--   
--   <pre>
--   &gt;&gt;&gt; testPath ^? _asPolyLine
--   Just (PolyLine {_points = LSeq (fromList [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [200,100] :+ ()])})
--   </pre>
_asPolyLine :: Prism' (Path r) (PolyLine 2 () r)
_asSomePolygon :: Prism' (Path r) (SomePolygon () r)

-- | Convert to a simple polygon
_asSimplePolygon :: Prism' (Path r) (Polygon Simple () r)

-- | Convert to a multipolygon
_asMultiPolygon :: Prism' (Path r) (MultiPolygon () r)

-- | Use the first prism to select the ipe object to depicle with, and the
--   second how to select the geometry object from there on. Then we can
--   select the geometry object, directly with its attributes here.
--   
--   <pre>
--   &gt;&gt;&gt; testObject ^? _withAttrs _IpePath _asPolyLine
--   Just (PolyLine {_points = LSeq (fromList [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [200,100] :+ ()])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "red"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
_withAttrs :: Prism' (IpeObject r) (i r :+ IpeAttributes i r) -> Prism' (i r) g -> Prism' (IpeObject r) (g :+ IpeAttributes i r)
class HasDefaultFromIpe g where {
    type family DefaultFromIpe g :: * -> *;
}
defaultFromIpe :: (HasDefaultFromIpe g, r ~ NumType g) => Prism' (IpeObject r) (g :+ IpeAttributes (DefaultFromIpe g) r)

-- | Types that correspond to an XML Element. All instances should produce
--   an Element. If the type should produce a Node with the Text
--   constructor, use the <a>IpeWriteText</a> typeclass instead.
class IpeWrite t
ipeWrite :: IpeWrite t => t -> Maybe (Node Text Text)

-- | For types that can produce a text value
class IpeWriteText t
ipeWriteText :: IpeWriteText t => t -> Maybe Text

-- | Defines a color in Ipe. Colors are either RGB Values or Named values.
newtype IpeColor r
IpeColor :: IpeValue (RGB r) -> IpeColor r

-- | Creates a named color
named :: Text -> IpeColor r

module Data.Tree.Draw

-- | Draws a tree
drawTree' :: IpeOut (Tree (Point 2 r :+ p)) Group r
treeEdges :: Tree a -> [(a, a)]


-- | Helper functions to draw a PlaneGraph in ipe
module Data.PlaneGraph.Draw

-- | Draws only the values for which we have a Just attribute
drawPlaneGraph :: forall s r. (Num r, Ord r) => IpeOut (PlaneGraph s (Maybe (IpeAttributes IpeSymbol r)) (Maybe (IpeAttributes Path r)) (Maybe (IpeAttributes Path r)) r) Group r

-- | Draw everything using the defaults
drawPlaneGraph' :: forall s v e f r. (Ord r, Num r) => IpeOut (PlaneGraph s v e f r) Group r

-- | Function to draw a graph by giving functions that specify how to
--   render vertices, edges, and faces.
drawPlaneGraphWith :: (ToObject vi, ToObject ei, ToObject fi, Num r, Ord r) => IpeOut' Maybe (VertexId' s, VertexData r v) vi r -> IpeOut' Maybe (Dart s, LineSegment 2 v r :+ e) ei r -> IpeOut' Maybe (FaceId' s, SimplePolygon v r :+ f) fi r -> IpeOut' Maybe (FaceId' s, MultiPolygon (Maybe v) r :+ f) fi r -> IpeOut (PlaneGraph s v e f r) Group r

-- | Function to draw a graph by giving the outer faceId and the functions
--   that specify how to render vertices, edges, and faces.
drawPlaneGraphWith' :: (ToObject vi, ToObject ei, ToObject fi, Num r, Ord r) => FaceId' s -> IpeOut' Maybe (VertexId' s, VertexData r v) vi r -> IpeOut' Maybe (Dart s, LineSegment 2 v r :+ e) ei r -> IpeOut' Maybe (FaceId' s, SimplePolygon v r :+ f) fi r -> IpeOut' Maybe (FaceId' s, MultiPolygon (Maybe v) r :+ f) fi r -> IpeOut (PlaneGraph s v e f r) Group r

module Data.Geometry.Triangulation.Draw

-- | Draws a triangulation
drawTriangulation :: IpeOut (Triangulation p r) Group r


-- | Helper functions to draw a PlanarSubdivision in ipe
module Data.Geometry.PlanarSubdivision.Draw

-- | Draws only the values for which we have a Just attribute
drawPlanarSubdivision :: forall s r. (Num r, Ord r) => IpeOut (PlanarSubdivision s (Maybe (IpeAttributes IpeSymbol r)) (Maybe (IpeAttributes Path r)) (Maybe (IpeAttributes Path r)) r) Group r

-- | Draw everything using the defaults
drawPlanarSubdivision' :: forall s v e f r. (Num r, Ord r) => IpeOut (PlanarSubdivision s v e f r) Group r

-- | Function to draw a planar subdivision by giving functions that specify
--   how to render vertices, edges, the internal faces, and the outer face.
drawPlanarSubdivisionWith :: (ToObject vi, ToObject ei, ToObject fi, Num r, Ord r) => IpeOut' Maybe (VertexId' s, VertexData r v) vi r -> IpeOut' Maybe (Dart s, LineSegment 2 v r :+ e) ei r -> IpeOut' Maybe (FaceId' s, SomePolygon v r :+ f) fi r -> IpeOut' Maybe (FaceId' s, MultiPolygon (Maybe v) r :+ f) fi r -> IpeOut (PlanarSubdivision s v e f r) Group r


-- | Functions for Drawing arrangements
module Data.Geometry.Arrangement.Draw

-- | Draws an arrangement
drawArrangement :: (Ord r, Num r) => IpeOut (Arrangement s l v e f r) Group r
